<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
<description>
  <title-info>
    <genre>comp_db</genre>
    <author>
      <first-name>Брайан</first-name>
      <last-name>Керниган</last-name>
    </author>
    <author>
      <first-name>Деннис</first-name>
      <middle-name>М</middle-name>
      <last-name>Ритчи</last-name>
    </author>
    <book-title>Язык программирования Си. Издание 3-е, исправленное</book-title>
    <annotation>
      <p>Книга широко известных авторов, разработчиков языка Си, переработанная и дополненная с учетом стандарта ANSI для языка Си, 2-е английское издание которой вышло в 1988 году, давно стала классикой для всех изучающих и/или использующих как Си, так и Си++. Русский перевод этой книги впервые был выпущен изд- вом "Финансы и статистика" в 1992 г. и с тех пор пользуется неизменным спросом читателей.</p>
      <p>Для настоящего третьего русского издания перевод заново сверен с оригиналом, в него внесены некоторые поправки, учитывающие устоявшиеся за прошедшие годы изменения в терминологии, а так же учтены замечания, размещенные автором на странице http://cm.bell-labs.com/cm/cs/cbook/2ediffs.html.</p>
      <p>Для программистов, преподавателей и студентов.</p>
      <p>Издание подготовлено при участии издательства "Финансы и статистика"</p>
    </annotation>
    <date>2001</date>
    <lang>ru</lang>
    <src-lang>en</src-lang>
    <translator>
      <first-name>Вик</first-name>
      <middle-name>С</middle-name>
      <last-name>Штаркман</last-name>
    </translator>
  </title-info>
  <src-title-info>
    <genre>comp_programming</genre>
    <author>
      <first-name>Brian</first-name>
      <middle-name>W.</middle-name>
      <last-name>Kernighan</last-name>
    </author>
    <author>
      <first-name>Dennis</first-name>
      <middle-name>M.</middle-name>
      <last-name>Ritchie</last-name>
    </author>
    <book-title>The C programming Language. Second Edition</book-title>
    <date>1998, 1978</date>
    <lang>en</lang>
    <src-lang>en</src-lang>
  </src-title-info>
  
  <publish-info>
    <book-name>Язык программирования Си.\Пер. с англ., 3-е изд., испр.</book-name>
    <publisher>Невский Диалект</publisher>
    <city>Санкт-Петербург</city>
    <year>2001</year>
    <isbn>0-13-110362-8</isbn>
  </publish-info>
</description>
<body>
  <title>
   <p>Б. Керниган, Д. Ритчи</p>
   <p>Язык программирования Си</p>
   <p>Издание 3-е, исправленное</p>
  </title>
  <section>
   <title>
    <p>Предисловие</p>
   </title>
   <section>
    <p>С момента публикации в 1978 г. книги "Язык программирования Си" в мире компьютеров произошла революция. Большие машины стали еще больше, а возможности персональных ЭВМ теперь сопоставимы с возможностями больших машин десятилетней давности. Язык Си за это время также изменился, хотя и не очень сильно; что же касается сферы применения Си, то она далеко вышла за рамки его начального назначения как инструментального языка операционной системы UNIX.</p>
    <p>Рост популярности Си, накапливающиеся с годами изменения, создание компиляторов коллективами разработчиков, ранее не причастных к проектированию языка, - все это послужило стимулом к более точному и отвечающему времени определению языка по сравнению с первым изданием книги. В 1983 г. Американский институт национальных стандартов (American National Standards Institute - ANSI) учредил комитет, перед которым была поставлена цель выработать "однозначное и машинно-независимое определение языка Си", полностью сохранив при этом его стилистику. Результатом работы этого комитета и явился стандарт ANSI языка Си.</p>
    <p>Стандарт формализует средства языка, которые в первом издании были только намечены, но не описаны, такие, например, как присваивание структурам и перечисления. Он вводит новый вид описания функций, позволяющий проводить повсеместную проверку согласованности вызовов функций с их определением; специфицирует стандартную библиотеку с широким набором функций ввода-вывода, управления памятью, манипуляций со строками символов и другими функциями; уточняет семантику, бывшую в первоначальном определении неясной, и явно выделяет то, что остается машинно-зависимым.</p>
    <p>Во втором издании книги "Язык программирования Си" представлена версия Си, принятая в качестве стандарта ANSI. Мы решили описать язык заново, отметив при этом те места, в которых он претерпел изменения. В большинство параграфов это не привнесло существенных перемен, самые заметные различия касаются новой формы описания и определения функции. Следует отметить, что современные компиляторы уже обеспечили поддержку значительной части стандарта.</p>
    <p>Мы попытались сохранить краткость первого издания. Си - небольшой язык, и чтобы его описать большой книги не требуется. В новом издании улучшено описание наиболее важных средств, таких как указатели, которые занимают центральное место в программировании на Си; доработаны старые примеры, а в некоторые главы добавлены новые. Так, для усиления трактовки сложных объявлений в качестве примеров включены программы перевода объявлений в их словесные описания и обратно. Как и раньше, все примеры были протестированы прямо по текстам, написанным в воспринимаемой машиной форме.</p>
    <p>Приложение A - это справочное руководство, но отнюдь не стандарт. В нем мы попытались уложить самое существенное на минимуме страниц. По замыслу это приложение должно легко читаться программистом-пользователем: для разработчиков же компилятора определением языка должен служить сам стандарт. В приложении B приведены возможности стандартной библиотеки. Оно также представляет собой справочник для прикладных программистов, но не для разработчиков компиляторов. Приложение C содержит краткий перечень отличий представленной версии языка Си от его начальной версии.</p>
    <p>В предисловии к первому изданию мы говорили о том, что "чем больше работаешь с Си, тем он становится удобнее". Это впечатление осталось и после десяти лет работы с ним. Мы надеемся, что данная книга поможет вам изучить Си и успешно его использовать.</p>
    <p>Мы в большом долгу перед друзьями, которые помогали нам в выпуске второго издания книги. Джон Бентли, Дуг Гунн, Дуг Макилрой, Питер Нельсон и Роб Пайк сделали четкие замечания почти по каждой странице первого варианта рукописи. Мы благодарны Алу Ахо, Деннису Аллиссону, Джою Кемпбеллу, Г. Р. Эмлину, Карен Фортганг, Аллену Голубу, Эндрю Хьюму, Дэйву Кристолу, Джону Линдерману, Дэйву Проссеру, Гину Спаффорду и Крису Ван Уику за внимательное прочтение книги. Мы получили полезные советы от Билла Чезвика, Марка Кернигана, Эндрю Коэнига, Робина Лейка, Тома Лондона, Джима Ридза, Кловиза Тондо и Питера Вайнбергера. Дейв Проссер ответил на многочисленные вопросы, касающиеся деталей стандарта ANSI. Мы широко пользовались транслятором с Си++ Бьерна Страуструпа для локальной проверки наших программ, а Дейв Кристол предоставил нам ANSI Си-компилятор для окончательной их проверки. Рич Дрешлер очень помог в наборе книги. Мы искренне благодарим всех.</p>
    <p><emphasis>Брайан В. Керниган, Деннис М. Ритчи</emphasis></p>
   </section>
   <section>
    <title>
     <p>Предисловие к первому изданию</p>
    </title>
    <p>Си - это универсальный язык программирования с компактным способом записи выражений, современными механизмами управления структурами данных и богатым набором операторов. Си не является ни языком "очень высокого уровня", ни "большим" языком, не рассчитан он и на какую-то конкретную область применения. Однако благодаря широким возможностям и универсальности для решения многих задач он удобнее и эффективнее, чем предположительно более мощные языки.</p>
    <p>Первоначально Си был создан Деннисом Ритчи как инструмент написания операционной системы UNIX для машины PDP-11 и реализован в рамках этой операционной системы. И операционная система, и Си- компилятор, и, по существу, все прикладные программы системы UNIX (включая и те, которые использовались для подготовки текста этой книги - <emphasis>Имеется в виду оригинал этой книги на английском языке. - Примеч. пер.</emphasis>) написаны на Си. Фирменные Си-компиляторы существуют и на нескольких машинах других типов, среди которых 1ВМ/370, Honeywell 6000 и Interdata 8/32. Си не привязан к конкретной аппаратуре или системе, однако на нем легко писать программы, которые без каких-либо изменений переносятся на другие машины, где осуществляется его поддержка.</p>
    <p>Цель нашей книги - помочь читателю научиться программировать на Си. Издание включает введение- учебник, позволяющий новичкам начать программировать как можно скорее, а также главы, посвященные основным свойствам языка, и справочное руководство. В ее основу положены изучение, написание и проработка примеров, а не простое перечисление правил. Почти все наши примеры - это законченные реальные программы, а не разобщенные фрагменты. Все они были оттестированы на машине точно в том виде, как приводятся в книге. Помимо демонстрации эффективного использования языка, там, где это было возможно, мы стремились проиллюстрировать полезные алгоритмы и принципы хорошего стиля написания программ и их разумного проектирования.</p>
    <p>Эта книга не является вводным курсом по программированию. Предполагается, что читатель знаком с такими основными понятиями, как "переменная", "присваивание", "цикл", "функция". Тем не менее и новичок сможет изучить язык, хотя для него будет очень полезным общение с более знающими специалистами.</p>
    <p>Наш опыт показал, что Си - удобный, выразительный и гибкий язык, пригодный для программирования широкого класса задач. Его легко выучить, и чем больше работаешь с Си, тем он становится удобнее. Мы надеемся, что эта книга поможет вам хорошо его освоить.</p>
    <p>Вдумчивая критика и предложения многих друзей и коллег помогали нам написать книгу. В частности, Майк Бианки, Джим Блу, Стью Фелдман, Дуг Макилрой, Билл Рум, Боб Розин и Ларри Рослер со вниманием прочли все многочисленные варианты этой книги. Мы в долгу у Ала Ахо, Стива Бьерна, Дана Дворака, Чака Хейли, Мариои Харрис, Рика Холта, Стива Джонсона, Джона Машея, Боба Митца, Ральфа Мухи, Питера Нельсона, Эллиота Пинсона, Билла Плейджера, Джерри Спивака, Кена Томпсона и Питера Вайнбергера за полезные советы, полученные от них на различных стадиях подготовки рукописи, а также у Майка Леска и Джо Оссанны за помощь при подготовке ее к изданию.</p>
    <p><emphasis>Брайан В. Керниган, Деннис М. Ритчи</emphasis></p>
   </section>
  </section>
  <section>
   <title>
    <p>Введение</p>
   </title>
   <p>Си - универсальный язык программирования. Он тесно связан с системой UNIX, так как был разработан в этой системе, которая как и большинство программ, работающих в ней, написаны на Си. Однако язык не привязан жестко к какой-то одной операционной системе или машине. Хотя он и назван "языком системного программирования", поскольку удобен для написания компиляторов и операционных систем, оказалось, что на нем столь же хорошо писать большие программы другого профиля.</p>
   <p>Многие важные идеи Си взяты из языка BCPL, автором которого является Мартин Ричардс. Влияние BCPL на Си было косвенным - через язык B, разработанный Кеном Томпсоном в 1970 г. для первой системы UNIX, реализованной на PDP-7.</p>
   <p>BCPL и B - "бестиповые" языки. В отличие от них Си обеспечивает разнообразие типов данных. Базовыми типами являются символы, а также целые и числа с плавающей точкой различных размеров. Кроме того, имеется возможность получать целую иерархию производных типов данных из указателей, массивов, структур и объединений. Выражения формируются из операторов и операндов. Любое выражение, включая присваивание и вызов функции, может быть инструкцией. Указатели обеспечивают машинно-независимую адресную арифметику.</p>
   <p>В Си имеются основные управляющие конструкции, используемые в хорошо структурированных программах: составная инструкция ({…}), ветвление по условию (<emphasis>if-else</emphasis>), выбор одной альтернативы из многих (<emphasis>switch</emphasis>), циклы с проверкой наверху (<emphasis>while</emphasis>, <emphasis>for</emphasis>) и с проверкой внизу (<emphasis>do</emphasis>), а также средство прерывания цикла (<emphasis>break</emphasis>).</p>
   <p>В качестве результата функции могут возвращать значения базовых типов, структур, объединений и указателей. Любая функция допускает рекурсивное обращение к себе. Как правило, локальные переменные функции - "автоматические", т. е. они создаются заново при каждом обращении к ней. Определения функций нельзя вкладывать друг в друга, но объявления переменных разрешается строить в блочно-структурной манере. Функции программы на Си могут храниться в отдельных исходных файлах и компилироваться независимо. Переменные по отношению к функции могут быть внутренними и внешними. Последние могут быть доступными в пределах одного исходного файла или всей программы.</p>
   <p>На этапе препроцессирования выполняется макроподстановка в текст программы, включение других исходных файлов и условная компиляция.</p>
   <p>Си - язык сравнительно "низкого уровня". Однако это вовсе не умаляет его достоинств, просто Си имеет дело с теми же объектами, что и большинство компьютеров, т. е. с символами, числами и адресами. С ними можно оперировать при помощи арифметических и логических операций, выполняемых реальными машинами.</p>
   <p>В Си нет прямых операций над составными объектами, такими как строки символов, множества, списки и массивы. В нем нет операций, которые бы манипулировали с целыми массивами или строками символов, хотя структуры разрешается копировать целиком как единые объекты. В языке нет каких-либо средств распределения памяти, помимо возможности определения статических переменных и стекового механизма при выделении места для локальных переменных внутри функций. Нет в нем "кучи" и "сборщика мусора". Наконец, в самом Си нет средств ввода-вывода, инструкций READ (читать) и WRITE (писать) и каких-либо методов доступа к файлам. Все это - механизмы высокого уровня, которые в Си обеспечиваются исключительно с помощью явно вызываемых функций. Большинство реализованных Си-систем содержат в себе разумный стандартный набор этих функций.</p>
   <p>В продолжение сказанного следует отметить, что Си предоставляет средства лишь последовательного управления ходом вычислений: механизм ветвления по условиям, циклы, составные инструкции, подпрограммы и не содержит средств мультипрограммирования, параллельных процессов, синхронизации и организации сопрограмм.</p>
   <p>Отсутствие некоторых из перечисленных средств может показаться серьезным недостатком ("выходит, чтобы сравнить две строки символов, нужно обращаться к функции?"). Однако компактность языка имеет реальные выгоды. Поскольку Си относительно мал, то и описание его кратко, и овладеть им можно быстро. Программист может реально рассчитывать на то, что он будет знать, понимать и на практике регулярно пользоваться всеми возможностями языка.</p>
   <p>В течение многих лет единственным определением языка Си было первое издание книги "Язык программирования Си". В 1983 г. Институтом американских национальных стандартов (ANSI) учреждается комитет для выработки современного исчерпывающего определения языка Си. Результатом его работы явился стандарт для Си ("ANSI-C"), выпущенный в 1988 г. Большинство положений этого стандарта уже учтено в современных компиляторах.</p>
   <p>Стандарт базируется на первоначальном справочном руководстве. По сравнению с последним язык изменился относительно мало. Одной из целей стандарта было обеспечить, чтобы в большинстве случаев существующие программы оставались правильными или вызывали предупреждающие сообщения компиляторов об изменении поведения.</p>
   <p>Для большинства программистов самое важное изменение - это новый синтаксис объявления и определения функций. Объявление функции может теперь включать и описание ее аргументов. В соответствии с этим изменился и синтаксис определения функции. Дополнительная информация значительно облегчает компилятору выявление ошибок, связанных с несогласованностью аргументов; по нашему мнению, это очень полезное добавление к языку.</p>
   <p>Следует также отметить ряд небольших изменений. В языке узаконены присваивание структур и перечисления, которые уже некоторое время широко используются. Вычисления с плавающей точкой теперь допускаются и с одинарной точностью. Уточнены свойства арифметики, особенно для беззнаковых типов. Усовершенствован препроцессор. Большинство программистов эти изменения затронут очень слабо.</p>
   <p>Второй значительный вклад стандарта - это определение библиотеки, поставляемой вместе с Си- компилятором, в которой специфицируются функции доступа к возможностям операционной системы (например чтения-записи файлов), форматного ввода-вывода, динамического выделения памяти, манипуляций со строками символов и т. д. Набор стандартных заголовочных файлов обеспечивает единообразный доступ к объявлениям функций и типов данных. Гарантируется, что программы, использующие эту библиотеку при взаимодействии с операционной системой, будут работать также и на других машинах. Большинство программ, составляющих библиотеку, созданы по образу и подобию "стандартной библиотеки ввода-вывода" системы UNIX. Эта библиотека описана в первом издании книги и широко используется в других системах. И здесь программисты не заметят существенных различий. Так как типы данных и управляющих структур языка Си поддерживаются командами большинства существующих машин, исполнительная система (run-time library), обеспечивающая независимый запуск и выполнение программ, очень мала. Обращения к библиотечным функциям пишет сам программист (не компилятор), поэтому при желании их можно легко заменить на другие. Почти все программы, написанные на Си, если они не касаются каких-либо скрытых в операционной системе деталей, переносимы на другие машины.</p>
   <p>Си соответствует аппаратным возможностям многих машин, однако он не привязан к архитектуре какой- либо конкретной машины. Проявляя некоторую дисциплину, можно легко писать переносимые программы, т. е. программы, которые без каких-либо изменений могут работать на разных машинах. Стандарт предоставляет возможность для явного описания переносимости с помощью набора констант, отражающих характеристики машины, на которой программа будет работать.</p>
   <p>Си не является "строго типизированным" языком, но в процессе его развития контроль за типами был усилен. В первой версии Си хоть не одобрялся, но разрешался бесконтрольный обмен указателей и целых, что вызывало большие нарекания, но это уже давным-давно запрещено. Согласно стандарту теперь требуется явное объявление или явное указание преобразования, что уже и реализовано в хороших компиляторах. Новый вид объявления функций - еще один шаг в этом направлении. Компилятор теперь предупреждает о большей части ошибок в типах и автоматически не выполняет преобразования данных несовместимых типов. Однако основной философией Си остается то, что программисты сами знают, что делают; язык лишь требует явного указания об их намерениях.</p>
   <p>Си, как и любой другой язык программирования, не свободен от недостатков. Уровень старшинства некоторых операторов не является общепринятым, некоторые синтаксические конструкции могли бы быть лучше. Тем не менее, как оказалось, Си - чрезвычайно эффективный и выразительный язык, пригодный для широкого класса задач.</p>
   <p>Книга имеет следующую структуру. Глава 1 представляет собой обзор основных средств языка Си. Ее назначение - побудить читателя по возможности быстрее приступить к программированию, так как мы убеждены, что единственный способ изучить новый язык - это писать на нем программы. Эта часть книги предполагает наличие знаний по основным элементам программирования. Никаких пояснений того, что такое компьютер, компиляция или что означает выражение вида n=n+1 не дается. Хотя мы и пытались там, где это возможно, показать полезные приемы программирования, эта книга не призвана быть справочником ни по работе со структурами данных, ни по алгоритмам: когда оказывалось необходимым выбрать, на что сделать ударение, мы предпочитали сконцентрировать внимание на языке.</p>
   <p>В главах 2-6 различные средства языка обсуждаются более подробно и несколько более формально, чем в главе 1; при этом по-прежнему упор делается на примеры, являющиеся законченными программами, а не изолированными фрагментами. Глава 2 знакомит с базовыми типами данных, с операторами и выражениями. В главе 3 рассматриваются средства управления последовательностью вычислений: <emphasis>if-else</emphasis>, <emphasis>switch</emphasis>, <emphasis>while</emphasis>, <emphasis>for</emphasis> и т.д. В главе 4 речь идет о функциях и структуре программы (внешних переменных, правилах видимости, делении программы на несколько исходных файлов и т. д.), а также о препроцессоре. В главе 5 обсуждаются указатели и адресная арифметика. Глава 6 посвящена структурам и объединениям.</p>
   <p>В главе 7 описана стандартная библиотека, обеспечивающая общий интерфейс с операционной системой. Эта библиотека узаконена в качестве стандарта ANSI, иначе говоря, она должна быть представлена на всех машинах, где существует Си, благодаря чему программы, использующие ввод-вывод и другие возможности операционной системы, без каких-либо изменений можно переносить с одной машины на другую.</p>
   <p>Глава 8 содержит описание интерфейса между программами на Си и операционной системой UNIX, в частности описание ввода-вывода, файловой системы и распределения памяти. Хотя некоторые параграфы этой главы отражают специфику системы UNIX, программисты, пользующиеся другими системами, все же найдут в них много полезных сведений, включая определенный взгляд на то, как реализуется одна из версий стандартной библиотеки, и некоторые предложения по переносимости программ.</p>
   <p>Приложение A является справочником по языку. Строгое определение синтаксиса и семантики языка Си содержится в официальном документе стандарта ANSI. Последний, однако, более всего подходит разработчикам компилятора. Наш справочник определяет язык более сжато, не прибегая к педантично юридическому стилю, которым пользуется стандарт. Приложение B - сводка по содержимому стандартной библиотеки и предназначена скорее пользователям, чем реализаторам. В приложении C приводится краткий перечень отличий от первой версии языка. В сомнительных случаях, однако, окончательным судьей по языку остается стандарт и компилятор, которым вы пользуетесь.</p>
  </section>
  <section>
   <title>
    <p>Глава 1. Обзор языка</p>
   </title>
   <section>
    <p>Начнем с быстрого ознакомления с языком Си. Наша цель - показать на реальных программах существенные элементы языка, не вдаваясь в мелкие детали, формальные правила и исключения из них. Поэтому мы не стремимся к полноте и даже точности (заботясь, однако, о корректности примеров). Нам бы хотелось как можно скорее подвести вас к моменту, когда вы сможете писать полезные программы. Чтобы сделать это, мы должны сконцентрировать внимание на основах: переменных и константах, арифметике, управлении последовательностью вычислений, функциях и простейшем вводе-выводе. В настоящей главе мы умышленно не затрагиваем тех средств языка, которые важны при написании больших программ: указателей, структур, большой части богатого набора операторов, некоторых управляющих инструкций и стандартной библиотеки.</p>
    <p>Такой подход имеет свои недостатки. Наиболее существенный из них состоит в том, что отдельное характерное свойство языка не описывается полностью в одном месте, и подобная лаконичность при обучении может привести к неправильному восприятию некоторых положений. В силу ограниченного характера подачи материала в примерах не используется вся мощь языка, и потому они не столь кратки и элегантны, как могли бы быть. Мы попытались по возможности смягчить эти эффекты, но считаем необходимым предупредить о них. Другой недостаток заключается в том, что в последующих главах какие-то моменты нам придется повторить. Мы надеемся, что польза от повторений превысит вызываемое ими раздражение.</p>
    <p>В любом случае опытный программист должен суметь экстраполировать материал данной главы на свои программистские нужды. Новичкам же рекомендуем дополнить ее чтение написанием собственных маленьких программ. И те и другие наши читатели могут рассматривать эту главу как "каркас", на который далее, начиная с главы 2, будут "навешиваться" элементы языка.</p>
   </section>
   <section>
    <title>
     <p>1.1 Начнем, пожалуй</p>
    </title>
    <p>Единственный способ выучить новый язык программирования - это писать на нем программы. При изучении любого языка первой, как правило, предлагают написать приблизительно следующую программу:</p>
    <p><code><emphasis>Напечатать слова</emphasis> Hello, world</code></p>
    <p>Вот первое препятствие, и чтобы его преодолеть, вы должны суметь где-то создать текст программы, успешно его скомпилировать, загрузить, запустить на выполнение и разобраться, куда будет отправлен результат. Как только вы овладеете этим, все остальное окажется относительно просто. Си-программа, печатающая "Hello, world", выглядит так:</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> printf("Hello, world\n");</code></p>
    <p><code>}</code></p>
    <p>Как запустить эту программу, зависит от системы, которую вы используете. Так, в операционной системе UNIX необходимо сформировать исходную программу в файле с именем, заканчивающимся символами ".c", например в файле hello.c, который затем компилируется с помощью команды</p>
    <p><code>cc hello.c</code></p>
    <p>Если вы все сделали правильно - не пропустили где-либо знака и не допустили орфографических ошибок, то компиляция пройдет "молча" и вы получите файл, готовый к исполнению и названный a.out. Если вы теперь запустите этот файл на выполнение командой</p>
    <p><code>a.out</code></p>
    <p>программа напечатает</p>
    <p><code>Hello, world</code></p>
    <p>В других системах правила запуска программы на выполнение могут быть иными; чтобы узнать о них, поговорите со специалистами.</p>
    <p>Теперь поясним некоторые моменты, касающиеся самой программы. Программа на Си, каких бы размеров она ни была, состоит из <emphasis>функций и переменных</emphasis>. Функции содержат <emphasis>инструкции</emphasis>, описывающие вычисления, которые необходимо выполнить, а переменные хранят значения, используемые в процессе этих вычислений. Функции в Си похожи на подпрограммы и функции Фортрана или на процедуры и функции Паскаля. Приведенная программа - это функция с именем <emphasis>main</emphasis>. Обычно вы вольны придумывать любые имена для своих функций, но "main" - особое имя: любая программа начинает свои вычисления с первой инструкции функции <emphasis>main</emphasis>.</p>
    <p>Обычно <emphasis>main</emphasis> для выполнения своей работы пользуется услугами других функций; одни из них пишутся самим программистом, а другие берутся готовыми из имеющихся в его распоряжении библиотек. Первая строка программы:</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p>сообщает компилятору, что он должен включить информацию о стандартной библиотеке ввода-вывода. Эта строка встречается в начале многих исходных файлов Си-программ. Стандартная библиотека описана в главе 7 и приложении В.</p>
    <p>Один из способов передачи данных между функциями состоит в том, что функция при обращении к другой функции передает ей список значений, называемых <emphasis>аргументами</emphasis>. Этот список берется в скобки и помещается после имени функции. В нашем примере <emphasis>main</emphasis> определена как функция, которая не ждет никаких аргументов, что отмечено пустым списком ().</p>
    <p>Первая программа на Си:</p>
    <table>
     <tr align="left">
      <td align="left" valign="top">#include ‹stdio.h› </td>
      <td align="left" valign="top">Включение информации о стандартной библиотеке. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">main() </td>
      <td align="left" valign="top">Определение функции с именем <emphasis>main</emphasis>, не получающей никаких аргументов. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">{</td>
      <td align="left" valign="top">Инструкции <emphasis>main</emphasis> заключаются о фигурные скобки.</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">printf("Hello, world\n"); </td>
      <td align="left" valign="top">Функция <emphasis>main</emphasis> вызывает библиотечную функцию <emphasis>printf</emphasis> для печати заданной последовательности символов; \n - символ новой строки. </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top">}</td>
      <td align="left" valign="top">Инструкции функции заключаются в фигурные скобки {}. Функция <emphasis>main</emphasis> содержит только одну инструкцию printf("Hello, world\n");</td>
     </tr>
    </table>
    <p>Функция вызывается по имени, после которого, в скобках, указывается список аргументов. Таким образом, приведенная выше строка - это вызов функции <emphasis>printf</emphasis> с аргументом "Hello, world\n". Функция <emphasis>printf</emphasis> - это библиотечная функция, которая в данном случае напечатает последовательность символов, заключенную в двойные кавычки.</p>
    <p>Последовательность символов в двойных кавычках, такая как "Hello, world\n", называется <emphasis>строкой символов</emphasis>, или <emphasis>строковой константой</emphasis>. Пока что в качестве аргументов для <emphasis>printf</emphasis> и других функций мы будем использовать только строки символов.</p>
    <p>В Си комбинация <strong>\n</strong> внутри строки символов обозначает символ <emphasis>новой строки</emphasis> и при печати вызывает переход к левому краю следующей строки. Если вы удалите \n (стоит поэкспериментировать), то обнаружите, что, закончив печать, машина не переходит на новую строку. Символ новой строки в текстовый аргумент printf следует включать явным образом. Если вы попробуете выполнить, например,</p>
    <p><code>printf("Hello, world</code></p>
    <p><code>");</code></p>
    <p>компилятор выдаст сообщение об ошибке.</p>
    <p>Символ новой строки никогда не вставляется автоматически, так что одну строку можно напечатать по шагам с помощью нескольких обращений к <emphasis>printf</emphasis>. Нашу первую программу можно написать и так:</p>
    <p><code>#include ‹stdio.h›</code></p>
    <empty-line/>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> printf("Hello, ");</code></p>
    <p><code> printf("world");</code></p>
    <p><code> printf('\n');</code></p>
    <p><code>}</code></p>
    <p>В результате ее выполнения будет напечатана та же строка, что и раньше.</p>
    <p>Заметим, что <strong>\n</strong> обозначает только один символ. Такие особые комбинации символов, начинающиеся с обратной наклонной черты, как <strong>\n</strong>, и называемые эскейп-последовательностями, широко применяются для обозначения трудно представимых или невидимых символов. Среди прочих в Си имеются символы <strong>\t</strong>, <strong>\b</strong>, <strong>\"</strong>, <strong>\\</strong>, обозначающие соответственно табуляцию, возврат на один символ назад ("забой" последнего символа), двойную кавычку, саму наклонную черту. Полный список таких символов представлен в параграфе 2.3.</p>
    <p><strong>Упражнение 1.1</strong>. Выполните программу, печатающую "Hello, world", в вашей системе. Поэкспериментируйте, удаляя некоторые части программы, и посмотрите, какие сообщения об ошибках вы получите.</p>
    <p><strong>Упражнение 1.2</strong>. Выясните, что произойдет, если в строковую константу аргумента <emphasis>printf</emphasis> вставить \c, где c - символ, не входящий в представленный выше список.</p>
   </section>
   <section>
    <title>
     <p>1.2 Переменные и арифметические выражения</p>
    </title>
    <p>Приведенная ниже программа выполняет вычисления по формуле °С = (5/9)(°F-32) и печатает таблицу соответствия температур по Фаренгейту температурам по Цельсию:</p>
    <p><code>0   –17</code></p>
    <p><code>20  –6</code></p>
    <p><code>40  4 </code></p>
    <p><code>60  15 </code></p>
    <p><code>80  26 </code></p>
    <p><code>100 37 </code></p>
    <p><code>120 48 </code></p>
    <p><code>140 60 </code></p>
    <p><code>160 71 </code></p>
    <p><code>180 82 </code></p>
    <p><code>200 93 </code></p>
    <p><code>220 104 </code></p>
    <p><code>240 115 </code></p>
    <p><code>260 126 </code></p>
    <p><code>280 137 </code></p>
    <p><code>300 148</code></p>
    <p>Как и предыдущая, эта программа состоит из определения одной-единственной функции <emphasis>main</emphasis>. Она длиннее программы, печатающей "здравствуй, мир", но по сути не сложнее. На ней мы продемонстрируем несколько новых возможностей, включая комментарий, объявления, переменные, арифметические выражения, циклы и форматный вывод.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>/* печать таблицы температур по Фаренгейту</code></p>
    <p><code>и Цельсию для fahr = 0, 20,…, 300 */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int fahr, celsius;</code></p>
    <p><code> int lower, upper, step;</code></p>
    <p><code> lower = 0; /* нижняя граница таблицы температур */</code></p>
    <p><code> upper = 300; /* верхняя граница */</code></p>
    <p><code> step = 20; /* шаг */</code></p>
    <p><code> fahr = lower;</code></p>
    <p><code> while (fahr ‹= upper) {</code></p>
    <p><code>  celsius = 5 * (fahr-32) / 9;</code></p>
    <p><code>  printf("%d\t%d\n", fahr, celsius);</code></p>
    <p><code>  fahr = fahr + step;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>Две строки:</p>
    <p><code>/* печать таблицы температур по Фаренгейту</code></p>
    <p><code>и Цельсию для fahr = 0, 20,… 300 */</code></p>
    <p>являются <emphasis>комментарием</emphasis>, который в данном случае кратко объясняет, что делает программа. Все символы, помещенные между /* и */, игнорируются компилятором, и этим можно свободно пользоваться, чтобы сделать программу более понятной. Комментарий можно располагать в любом месте, где могут стоять символы пробела, табуляции или символ новой строки.</p>
    <p>В Си любая переменная должна быть объявлена раньше, чем она будет использована; обычно все переменные объявляются в начале функции перед первой исполняемой инструкцией. В <emphasis>объявлении</emphasis> описываются свойства переменных. Оно состоит из названия типа и списка переменных, например:</p>
    <p><code>int fahr, celsius;</code></p>
    <p><code>int lower, upper, step;</code></p>
    <p>Тип <emphasis>int</emphasis> означает, что значения перечисленных переменных есть целые, в отличие от него тип <emphasis>float</emphasis> указывает на значения с плавающей точкой, т. е. на числа, которые могут иметь дробную часть. Диапазоны значений обоих типов зависят от используемой машины.</p>
    <p>Числа типа <emphasis>int</emphasis> бывают как 16-разрядные (лежат в диапазоне от -32768 до 32767), так и 32-разрядные. Числа типа <emphasis>float</emphasis> обычно представляются 32-разрядными словами, имеющими по крайней мере 6 десятичных значащих цифр (лежат приблизительно в диапазоне от 10<sup>-38</sup> до 10<sup>+38</sup>.</p>
    <p>Помимо <strong>int</strong> и <strong>float</strong> в Си имеется еще несколько базовых типов для данных, это:</p>
    <p><strong>char</strong> - символ-единичный байт;</p>
    <p><strong>short</strong> - короткое целое;</p>
    <p><strong>long</strong> - длинное целое;</p>
    <p><strong>double</strong> - с плавающей точкой с двойной точностью.</p>
    <p>Размеры объектов указанных типов также зависят от машины. Из базовых типов можно создавать: <emphasis>массивы, структуры</emphasis> и <emphasis>объединения, указатели</emphasis> на объекты базовых типов и функции, возвращающие значения этих типов в качестве результата. Обо всем этом мы расскажем позже.</p>
    <p>Вычисления в программе преобразования температур начинаются с <emphasis>инструкций присваивания</emphasis>.</p>
    <p><code>lower = 0;</code></p>
    <p><code>upper = 300;</code></p>
    <p><code>step = 20;</code></p>
    <p><code>fahr = lower;</code></p>
    <p>которые устанавливают указанные в них переменные в начальные значения. Любая инструкция заканчивается точкой с запятой.</p>
    <p>Все строки таблицы вычисляются одним и тем же способом, поэтому мы воспользуемся циклом, повторяющим это вычисление для каждой строки. Необходимые действия выполнит цикл <strong>while</strong>:</p>
    <p><code>while(fahr ‹= upper) {</code></p>
    <p><code> …</code></p>
    <p><code>}</code></p>
    <p>Он работает следующим образом. Проверяется условие в скобках. Если оно истинно (значение <emphasis>fahr</emphasis> меньше или равно значению <emphasis>upper</emphasis>), то выполняется тело цикла (три инструкции, заключенные в фигурные скобки). Затем опять проверяется условие, и если оно истинно, то тело цикла выполняется снова. Когда условие становится ложным (<emphasis>fahr</emphasis> превысило <emphasis>upper</emphasis>), цикл завершается, и вычисления продолжаются с инструкции, следующей за циклом. Поскольку никаких инструкций за циклом нет, программа завершает работу.</p>
    <p>Телом цикла <emphasis>while</emphasis> может быть одна или несколько инструкций, заключенных в фигурные скобки, как в программе преобразования температур, или одна-единственная инструкция без скобок, как в цикле</p>
    <p><code>(while i ‹ j)</code></p>
    <p><code> i = 2 * i;</code></p>
    <p>И в том и в другом случае инструкции, находящиеся под управлением <emphasis>while</emphasis>, мы будем записывать со сдвигом, равным одной позиции табуляции, которая в программе указывается четырьмя пробелами; благодаря этому будут ясно видны инструкции, расположенные внутри цикла. Отступы подчеркивают логическую структуру программы. Си-компилятор не обращает внимания на внешнее оформление программы, но наличие в нужных местах отступов и пробелов существенно влияет на то, насколько легко она будет восприниматься человеком при просмотре. Чтобы лучше была видна логическая структура выражения, мы рекомендуем на каждой строке писать только по одной инструкции и с обеих сторон от операторов ставить пробелы. Положение скобок не так важно, хотя существуют различные точки зрения на этот счет. Мы остановились на одном из нескольких распространенных стилей их применения. Выберите тот, который больше всего вам нравится, и строго ему следуйте.</p>
    <p>Большая часть вычислений выполняется в теле цикла. Температура по Фаренгейту переводится в температуру по Цельсию и присваивается переменной <emphasis>celsius</emphasis> посредством инструкции</p>
    <p><code>celsius = 5 * (fahr-32) / 9;</code></p>
    <p>Причина, по которой мы сначала умножаем на 5 и затем делим на 9, а не сразу умножаем на 5/9, связана с тем, что в Си, как и во многих других языках, деление целых сопровождается <emphasis>отбрасыванием</emphasis>, т. е. потерей дробной части. Так как 5 и 9 - целые, отбрасывание в 5/9 дало бы нуль, и на месте температур по Цельсию были бы напечатаны нули.</p>
    <p>Этот пример прибавил нам еще немного знаний о том, как работает функция <emphasis>printf</emphasis>. Функция <emphasis>printf</emphasis> - это универсальная функция форматного ввода-вывода, которая будет подробно описана в главе 7. Ее первый аргумент - строка символов, в которой каждый символ % соответствует одному из последующих аргументов (второму, третьему, …), а информация, расположенная за символом %, указывает на вид, в котором выводится каждый из этих аргументов. Например, %d специфицирует выдачу аргумента в виде целого десятичного числа, и инструкция</p>
    <p><code>printf("%d\t%d\n", fahr, celsius);</code></p>
    <p>печатает целое <emphasis>fahr</emphasis>, выполняет табуляцию (\t) и печатает целое <emphasis>celsius</emphasis>.</p>
    <p>В функции <emphasis>printf</emphasis> каждому спецификатору первого аргумента (конструкции, начинающейся с <strong>%</strong>) соответствует второй аргумент, третий аргумент и т. д. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.</p>
    <p>Кстати, <emphasis>printf</emphasis> не является частью языка Си, и вообще в языке нет никаких специальных конструкций, определяющих ввод-вывод. Функция <emphasis>printf</emphasis> - лишь полезная функция стандартной библиотеки, которая обычно доступна для Си-программ. Поведение функции <emphasis>printf</emphasis>, однако, оговорено стандартом ANSI, и ее свойства должны быть одинаковыми во всех Си-системах, удовлетворяющих требованиям стандарта.</p>
    <p>Желая сконцентрировать ваше внимание на самом Си, мы не будем много говорить о вводе-выводе до главы 7. В частности, мы отложим разговор о форматном вводе. Если вам потребуется ввести числа, советуем прочитать в параграфе 7.4 то, что касается функции <emphasis>scanf</emphasis>. Эта функция отличается от <emphasis>printf</emphasis> лишь тем, что она вводит данные, а не выводит.</p>
    <p>Существуют еще две проблемы, связанные с программой преобразования температур. Одна из них (более простая) состоит в том, что выводимый результат выглядит несколько неряшливо, поскольку числа не выровнены по правой позиции колонок. Это легко исправить, добавив в каждый из спецификаторов формата %d указание о ширине поля; при этом программа будет печатать числа, прижимая их к правому краю указанных полей. Например, мы можем написать</p>
    <p>printf("%3d%6d\n", fahr, celsius);</p>
    <p>чтобы в каждой строке первое число печатать в поле из трех позиций, а второе - из шести. В результате будет напечатано:</p>
    <p><code>  0   -17</code></p>
    <p><code> 20    -6</code></p>
    <p><code> 40     4</code></p>
    <p><code> 60    15</code></p>
    <p><code> 80    26</code></p>
    <p><code>100    37</code></p>
    <p>Вторая, более серьезная проблема связана с тем, что мы пользуемся целочисленной арифметикой и поэтому не совсем точно вычисляем температуры по шкале Цельсия. Например, 0°F на самом деле (с точностью до десятой) равно -17.8°С, а не -17. Чтобы получить более точные значения температур, нам надо пользоваться не целочисленной арифметикой, а арифметикой с плавающей точкой. Это потребует некоторых изменений в программе.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>/* печать таблицы температур по Фаренгейту и Цельсию для</code></p>
    <p><code>fahr = 0, 20,…, 300; вариант с плавающей точкой */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> float fahr, celsius;</code></p>
    <p><code> int lower, upper, step;</code></p>
    <p><code> lower = 0; /* нижняя граница таблицы температур */</code></p>
    <p><code> upper = 300; /* верхняя граница */</code></p>
    <p><code> step = 20; /* шаг */</code></p>
    <p><code> fahr = lower;</code></p>
    <p><code> while (fahr ‹= upper) {</code></p>
    <p><code>  celsius = (5.0/9.0) * (fahr-32.0);</code></p>
    <p><code>  printf("%3.0f %6.1f\n", fahr, celsius);</code></p>
    <p><code>  fahr = fahr + step;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>Программа мало изменилась. Она отличается от предыдущей лишь тем, что <emphasis>fahr</emphasis> и <emphasis>celsius</emphasis> объявлены как <strong>float</strong>, а формула преобразования написана в более естественном виде. В предыдущем варианте нельзя было писать 5/9, так как целочисленное деление в результате обрезания дало бы нуль. Десятичная точка в константе указывает на то, что последняя рассматривается как число с плавающей точкой, и 5.0/9.0, таким образом, есть частное от деления двух значений с плавающей точкой, которое не предполагает отбрасывания дробной части. В том случае, когда арифметическая операция имеет целые операнды, она выполняется по правилам целочисленной арифметики. Если же один операнд с плавающей точкой, а другой - целый, то перед тем, как операция будет выполнена, последний будет преобразован в число с плавающей точкой. Если бы мы написали <emphasis>fahr-32</emphasis> то 32 автоматически было бы преобразовано в число с плавающей точкой. Тем не менее при записи констант с плавающей точкой мы всегда используем десятичную точку, причем даже в тех случаях, когда константы на самом деле имеют целые значения. Это делается для того, чтобы обратить внимание читающего программу на их природу.</p>
    <p>Более подробно правила, определяющие, в каких случаях целые переводятся в числа с плавающей точкой, рассматриваются в главе 2. А сейчас заметим, что присваивание</p>
    <p><code>fahr=lower;</code></p>
    <p>и проверка</p>
    <p><code>while(fahr ‹= upper)</code></p>
    <p>работают естественным образом, т. е. перед выполнением операции значение <emphasis>int</emphasis> приводится к <emphasis>float</emphasis>.</p>
    <p>Спецификация <emphasis>%3.0f</emphasis> в <emphasis>printf</emphasis> определяет печать числа с плавающей точкой (в данном случае числа <emphasis>fahr</emphasis>) в поле шириной не более трех позиций без десятичной точки и дробной части. Спецификация <emphasis>%6.1f</emphasis> описывает печать другого числа (<emphasis>celsius</emphasis>) в поле из шести позиций с одной цифрой после десятичной точки. Напечатано будет следующее:</p>
    <p><code>  0  -17.8</code></p>
    <p><code> 20   -6.7</code></p>
    <p><code> 40    4.4</code></p>
    <p>Ширину и точность можно не задавать; <emphasis>%6f</emphasis> означает, что число будет занимать не более шести позиций; <emphasis>%.2f</emphasis> - число имеет две цифры после десятичной точки, но ширина не ограничена; <emphasis>%f</emphasis> просто указывает на печать числа с плавающей точкой.</p>
    <p><emphasis>%d</emphasis> - печать десятичного целого. </p>
    <p><emphasis>%6d</emphasis> - печать десятичного целого в поле из шести позиций. </p>
    <p><emphasis>%f</emphasis> - печать числа с плавающей точкой. </p>
    <p><emphasis>%6f</emphasis> - печать числа с плавающей точкой в поле из шести позиций. </p>
    <p><emphasis>%.2f</emphasis> - печать числа с плавающей точкой с двумя цифрами после десятичной точки. </p>
    <p><emphasis>%6.2f</emphasis> - печать числа с плавающей точкой и двумя цифрами после десятичной точки в поле из шести позиций. </p>
    <p>Кроме того, <emphasis>printf</emphasis> допускает следующие спецификаторы: <strong>%o</strong> для восьмеричного числа; <strong>%x</strong> для шестнадцатеричного числа; <strong>%c</strong> для символа; <strong>%s</strong> для строки символов и <strong>%%</strong> для самого %.</p>
    <p><strong>Упражнение 1.3</strong>. Усовершенствуйте программу преобразования температур таким образом, чтобы над таблицей она печатала заголовок.</p>
    <p><strong>Упражнение 1.4</strong>. Напишите программу, которая будет печатать таблицу соответствия температур по Цельсию температурам по Фаренгейту.</p>
   </section>
   <section>
    <title>
     <p>1.3 Инструкция for</p>
    </title>
    <p>Существует много разных способов для написания одной и той же программы. Видоизменим нашу программу преобразования температур:</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>/* печать таблицы температур по Фаренгейту и Цельсию */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int fahr;</code></p>
    <p><code> for (fahr = 0; fahr ‹= 300; fahr = fahr + 20)</code></p>
    <p><code> printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));</code></p>
    <p><code>}</code></p>
    <p>Эта программа печатает тот же результат, но выглядит она, несомненно, по-другому. Главное отличие заключается в отсутствии большинства переменных. Осталась только переменная <emphasis>fahr</emphasis>, которую мы объявили как <emphasis>int</emphasis>. Нижняя и верхняя границы и шаг присутствуют в виде констант в инструкции <emphasis>for</emphasis> - новой для нас конструкции, а выражение, вычисляющее температуру по Цельсию, теперь задано третьим аргументом функции <emphasis>printf</emphasis>, а не в отдельной инструкции присваивания.</p>
    <p>Последнее изменение является примером применения общего правила: в любом контексте, где возможно использовать значение переменной какого-то типа, можно использовать более сложное выражение того же типа. Так, на месте третьего аргумента функции <emphasis>printf</emphasis> согласно спецификатору <emphasis>%6.1f</emphasis> должно быть значение с плавающей точкой, следовательно, здесь может быть любое выражение этого типа.</p>
    <p>Инструкция <emphasis>for</emphasis> описывает цикл, который является обобщением цикла <emphasis>while</emphasis>. Если вы сравните его с ранее написанным <emphasis>while</emphasis>, то вам станет ясно, как он работает. Внутри скобок имеются три выражения, разделяемые точкой с запятой. Первое выражение - инициализация</p>
    <p><code>fahr = 0</code></p>
    <p>выполняется один раз перед тем, как войти в цикл. Второе - проверка условия продолжения цикла</p>
    <p><code>fahr ‹= 300</code></p>
    <p>Условие вычисляется, и если оно истинно, выполняется тело цикла (в нашем случае это одно обращение к <emphasis>printf</emphasis>). Затем осуществляется приращение шага:</p>
    <p><code>fahr = fahr + 20</code></p>
    <p>и условие вычисляется снова. Цикл заканчивается, когда условие становится ложным. Как и в случае с <emphasis>while</emphasis>, тело <emphasis>for</emphasis>-цикла может состоять из одной инструкции или из нескольких, заключенных в фигурные скобки. На месте этих трех выражений (инициализации, условия и приращения шага) могут стоять произвольные выражения.</p>
    <p>Выбор между <emphasis>while</emphasis> и <emphasis>for</emphasis> определяется соображениями ясности программы. Цикл <emphasis>for</emphasis> более удобен в тех случаях, когда инициализация и приращение шага логически связаны друг с другом общей переменной и выражаются единичными инструкциями, поскольку названный цикл компактнее цикла <emphasis>while</emphasis>, а его управляющие части сосредоточены в одном месте.</p>
    <p><strong>Упражнение 1.5</strong>. Измените программу преобразования температур так, чтобы она печатала таблицу в обратном порядке, т. е. от 300 до 0.</p>
   </section>
   <section>
    <title>
     <p>1.4 Именованные константы</p>
    </title>
    <p>Прежде чем мы закончим рассмотрение программы преобразования температур, выскажем еще одно соображение. Очень плохо, когда по программе рассеяны "загадочные числа", такие как 300, 20. Тот, кто будет читать программу, не найдет в них и намека на то, что они собой представляют. Кроме того, их трудно заменить на другие каким-то систематическим способом. Одна из возможностей справиться с такими числами - дать им осмысленные имена. Строка <strong>#define</strong> определяет <emphasis>символьное имя</emphasis>, или <emphasis>именованную константу</emphasis>, для заданной строки символов:</p>
    <p><code>#define <emphasis>имя подставляемый-текст</emphasis></code></p>
    <p>С этого момента при любом появлении <emphasis>имени</emphasis> (если только оно встречается не в тексте, заключенном в кавычки, и не является частью определения другого имени) оно будет заменяться на соответствующий ему <emphasis>подставляемый-текст</emphasis>. <emphasis>Имя</emphasis> имеет тот же вид, что и переменная: последовательность букв и цифр, начинающаяся с буквы. <emphasis>Подставляемый-текст </emphasis>может быть любой последовательностью символов, среди которых могут встречаться не только цифры.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <empty-line/>
    <p><code>#define LOWER 0 /* нижняя граница таблицы */</code></p>
    <p><code>#define UPPER 300 /* верхняя граница */</code></p>
    <p><code>#define STEP 20 /* размер шага */</code></p>
    <empty-line/>
    <p><code>/* печать таблицы температур по Фаренгейту и Цельсию */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int fahr;</code></p>
    <p><code> for (fahr = LOWER; fahr ‹= UPPER; fahr = fahr + STEP)</code></p>
    <p><code> printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));</code></p>
    <p><code>}</code></p>
    <p>Величины <emphasis>LOWER, UPPER</emphasis> и <emphasis>STEP</emphasis> - именованные константы, а не переменные, поэтому для них нет объявлений. По общепринятому соглашению имена именованных констант набираются заглавными буквами, чтобы они отличались от обычных переменных, набираемых строчными. Заметим, что в конце <emphasis>#define</emphasis>-строки точка с запятой не ставится.</p>
   </section>
   <section>
    <title>
     <p>1.5 Ввод-вывод символов</p>
    </title>
    <section>
     <p>Теперь мы намерены рассмотреть семейство программ по обработке текстов. Вы обнаружите, что многие существующие программы являются просто расширенными версиями обсуждаемых здесь прототипов.</p>
     <p>Стандартная библиотека поддерживает очень простую модель ввода-вывода. Текстовый ввод-вывод вне зависимости от того, откуда он исходит или куда направляется, имеет дело с потоком символов. <emphasis>Текстовый поток</emphasis> - это последовательность символов, разбитая на строки, каждая из которых содержит нуль или более символов и завершается символом новой строки. Обязанность следить за тем, чтобы любой поток ввода-вывода отвечал этой модели, возложена на библиотеку: программист, пользуясь библиотекой, не должен заботиться о том, в каком виде строки представляются вне программы.</p>
     <p>Стандартная библиотека включает несколько функций для чтения и записи одного символа. Простейшие из них - <emphasis>getchar</emphasis> и <emphasis>putchar</emphasis>. За одно обращение к <emphasis>getchar</emphasis> считывается <emphasis>следующий символ ввода</emphasis> из текстового потока, и этот символ выдается в качестве результата. Так, после выполнения</p>
     <p><code>c = getchar();</code></p>
     <p>переменная <emphasis>c</emphasis> содержит очередной символ ввода. Обычно символы поступают с клавиатуры. Ввод из файлов рассматривается в главе 7.</p>
     <p>Обращение к <emphasis>putchar</emphasis> приводит к печати одного символа. Так,</p>
     <p><code>putchar(c);</code></p>
     <p>напечатает содержимое целой переменной <emphasis>c</emphasis> в виде символа (обычно на экране). Вызовы <emphasis>putchar</emphasis> и <emphasis>printf</emphasis> могут произвольным образом перемежаться. Вывод будет формироваться в том же порядке, что и обращения к этим функциям.</p>
    </section>
    <section>
     <title>
      <p>1.5.1 Копирование файла</p>
     </title>
     <p>При наличии функций <emphasis>getchar</emphasis> и <emphasis>putchar</emphasis>, ничего больше не зная о вводе-выводе, можно написать удивительно много полезных программ. Простейший пример - это программа, копирующая по одному символу с входного потока в выходной поток:</p>
     <p><code><emphasis>чтение символа</emphasis></code></p>
     <p><code><strong>while</strong> (<emphasis>символ не является признаком конца файла</emphasis>)</code></p>
     <p><code><emphasis>вывод только что прочитанного символа</emphasis></code></p>
     <p><code><emphasis>чтение символа</emphasis></code></p>
     <p>Оформляя ее в виде программы ни Си, получим</p>
     <p>#include ‹stdio.h›</p>
     <empty-line/>
     <p>/* копирование ввода на вывод, 1-я версия */</p>
     <p><code>main()</code></p>
     <p><code>{</code></p>
     <p><code> int c;</code></p>
     <p><code> c = getchar();</code></p>
     <p><code> while (c != EOF) {</code></p>
     <p><code>  putchar(c);</code></p>
     <p><code>  c = getchar();</code></p>
     <p><code> }</code></p>
     <p><code>}</code></p>
     <p>Оператор отношения <strong>!=</strong> означает "не равно".</p>
     <p>Каждый символ, вводимый с клавиатуры или появляющийся на экране, как и любой другой символ внутри машины, кодируется комбинацией битов. Тип <strong>char</strong> специально предназначен для хранения символьных данных, однако для этого также годится и любой целый тип. Мы пользуемся типом <strong>int</strong> и делаем это по одной важной причине, которая требует разъяснений.</p>
     <p>Существует проблема: как отличить конец ввода от обычных читаемых данных. Решение заключается в том, чтобы функция <emphasis>getchar</emphasis> по исчерпании входного потока выдавала в качестве результата такое значение, которое нельзя было бы спутать ни с одним реальным символом. Это значение есть <strong>EOF</strong> (аббревиатура от <emphasis>end of file</emphasis> - конец файла). Мы должны объявить переменную <emphasis>c</emphasis> такого типа, чтобы его "хватило" для представления всех возможных результатов, выдаваемых функцией <emphasis>getchar</emphasis>. Нам не подходит тип <emphasis>char</emphasis>, так как <emphasis>c</emphasis> должна быть достаточно "емкой", чтобы помимо любого значения типа <emphasis>char</emphasis> быть в состоянии хранить и <emphasis>EOF</emphasis>. Вот почему мы используем <emphasis>int</emphasis>, а не <emphasis>char</emphasis>.</p>
     <p><strong>EOF</strong> - целая константа, определенная в <strong>‹stdio.h›</strong>. Какое значение имеет эта константа - неважно, лишь бы оно отличалось от любого из возможных значений типа <emphasis>char</emphasis>. Использование именованной константы с унифицированным именем гарантирует, что программа не будет зависеть от конкретного числового значения, которое, возможно, в других Си-системах будет иным.</p>
     <p>Программу копирования можно написать более сжато. В Си любое присваивание, например</p>
     <p><code>c = getchar()</code></p>
     <p>трактуется как выражение со значением, равным значению левой части после присваивания. Это значит, что присваивание может встречаться внутри более сложного выражения. Если присваивание переменной <emphasis>c</emphasis> расположить в проверке условия цикла <emphasis>while</emphasis>, то программу копирования можно будет записать в следующем виде:</p>
     <p><code>#include ‹stdio.h›</code></p>
     <p><code>/* копирование ввода на вывод; 2-я версия */</code></p>
     <p><code>main()</code></p>
     <p><code>{</code></p>
     <p><code> int c;</code></p>
     <empty-line/>
     <p><code> while ((с = getchar()) != EOF)</code></p>
     <p><code>  putchar(c);</code></p>
     <p><code>}</code></p>
     <p>Цикл <emphasis>while</emphasis>, пересылая в <emphasis>c</emphasis> полученное от <emphasis>getchar</emphasis> значение, сразу же проверяет: не является ли оно "концом файла". Если это не так, выполняется тело цикла <emphasis>while</emphasis> и печатается символ. По окончании ввода завершается работа цикла <emphasis>while</emphasis>, а тем самым и <emphasis>main</emphasis>.</p>
     <p>В данной версии ввод "централизован". - в программе имеется только одно обращение к <emphasis>getchar</emphasis>. В результате она более компактна и легче воспринимается при чтении. Вам часто придется сталкиваться с такой формой записи, где присваивание делается вместе с проверкой. (Чрезмерное увлечение ею, однако, может запутать программу, поэтому мы постараемся пользоваться указанной формой разумно.)</p>
     <p>Скобки внутри условия, вокруг присваивания, необходимы. <emphasis>Приоритет !=</emphasis> выше, чем приоритет =, из чего следует, что при отсутствии скобок проверка!= будет выполняться до операции присваивания =. Таким образом, запись</p>
     <p><code>c = getchar() != EOF</code></p>
     <p>эквивалентна записи</p>
     <p><code>c = (getchar() != EOF)</code></p>
     <p>А это совсем не то, что нам нужно: переменной <emphasis>c</emphasis> будет присваиваться 0 или 1 в зависимости от того, встретит или не встретит <emphasis>getchar</emphasis> признак конца файла. (Более подробно об этом см. в главе 2.)</p>
     <p><strong>Упражнение 1.6</strong>. Убедитесь в том, что выражение <emphasis>getchar()!= EOF</emphasis> получает значение 0 или 1.</p>
     <p><strong>Упражнение 1.7</strong>. Напишите программу, печатающую значение <emphasis>EOF</emphasis>.</p>
    </section>
    <section>
     <title>
      <p>1.5.2 Подсчет символов</p>
     </title>
     <p>Следующая программа занимается подсчетом символов; она имеет много сходных черт с программой копирования.</p>
     <p><code>#include ‹stdio.h›</code></p>
     <empty-line/>
     <p><code>/* подсчет вводимых символов; 1-я версия */</code></p>
     <p><code>main()</code></p>
     <p><code>{</code></p>
     <p><code> long nc;</code></p>
     <p><code> nc = 0;</code></p>
     <empty-line/>
     <p><code> while (getchar() != EOF)</code></p>
     <p><code>  ++nc;</code></p>
     <p><code> printf("%ld\n", nc);</code></p>
     <p><code>}</code></p>
     <p>Инструкция</p>
     <p><code>++nc;</code></p>
     <p>представляет новый оператор <strong>++</strong>, который означает <emphasis>увеличить на единицу</emphasis>. Вместо этого можно было бы написать <emphasis>nc=nc+1</emphasis>, но <emphasis>++nc</emphasis> намного короче, а часто и эффективнее. Существует аналогичный оператор <strong>--</strong>, означающий <emphasis>уменьшить на единицу</emphasis>. Операторы <strong>++</strong> и <strong>--</strong> могут быть как префиксными (<emphasis>++nc</emphasis>), так и постфиксными (<emphasis>nc++</emphasis>). Как будет показано в главе 2, эти две формы в выражениях имеют разные значения, но и <emphasis>++nc</emphasis>, и <emphasis>nc++</emphasis> добавляют к <emphasis>nc</emphasis> единицу. В данном случае мы остановились на префиксной записи.</p>
     <p>Программа подсчета символов накапливает сумму в переменной типа <emphasis>long</emphasis>. Целые типа <emphasis>long</emphasis> имеют не менее 32 битов. Хотя на некоторых машинах типы <emphasis>int</emphasis> и <emphasis>long</emphasis> имеют одинаковый размер, существуют, однако, машины, в которых <emphasis>int</emphasis> занимает 16 бит с максимально возможным значением 32767, а это - сравнительно маленькое число, и счетчик типа <emphasis>int</emphasis> может переполниться. Спецификация <emphasis>%ld</emphasis> в <emphasis>printf</emphasis> указывает, что соответствующий аргумент имеет тип <emphasis>long</emphasis>.</p>
     <p>Возможно охватить еще больший диапазон значений, если использовать тип <emphasis>double</emphasis> (т. е. <emphasis>float</emphasis> с двойной точностью). Применим также инструкцию <emphasis>for</emphasis> вместо <emphasis>while</emphasis>, чтобы продемонстрировать другой способ написания цикла.</p>
     <p><code>#include ‹stdio.h›</code></p>
     <empty-line/>
     <p><code>/* подсчет вводимых символов; 2-й версия */</code></p>
     <p><code>main()</code></p>
     <p><code>{</code></p>
     <p><code> double nc;</code></p>
     <p><code> for (nc = 0; getchar() != EOF; ++nc)</code></p>
     <p><code>  ;</code></p>
     <p><code> printf("%.0f\n", nc);</code></p>
     <p><code>}</code></p>
     <p>В <emphasis>printf</emphasis> спецификатор <emphasis>%f</emphasis> применяется как для <emphasis>float</emphasis>, так и для <emphasis>double</emphasis>; спецификатор <emphasis>%.0f</emphasis> означает печать без десятичной точки и дробной части (последняя в нашем случае отсутствует).</p>
     <p>Тело указанного <emphasis>for</emphasis>-цикла пусто, поскольку кроме проверок и приращений счетчика делать ничего не нужно. Но правила грамматики Си требуют, чтобы <emphasis>for</emphasis>- цикл имел тело. Выполнение этого требования обеспечивает изолированная точка с запятой, называемая <emphasis>пустой инструкцией</emphasis>. Мы поставили точку с запятой на отдельной строке для большей наглядности.</p>
     <p>Наконец, заметим, что если ввод не содержит ни одного символа, то при первом же обращении к <emphasis>getchar</emphasis> условие в <emphasis>while</emphasis> или <emphasis>for</emphasis> не будет выполнено и программа выдаст нуль, что и будет правильным результатом. Это важно. Одно из привлекательных свойств циклов <emphasis>while</emphasis> и <emphasis>for</emphasis> состоит в том, что условие проверяется до того, как выполняется тело цикла. Если ничего делать не надо, то ничего делаться и не будет, пусть даже тело цикла не выполнится ни разу. Программа должна вести себя корректно и при нулевом количестве вводимых символов. Само устройство циклов <emphasis>while</emphasis> и <emphasis>for</emphasis> дает дополнительную уверенность в правильном поведении программы в случае граничных условий.</p>
    </section>
    <section>
     <title>
      <p>1.5.3 Подсчет строк</p>
     </title>
     <p>Следующая программа подсчитывает строки. Как упоминалось выше, стандартная библиотека обеспечивает такую модель ввода-вывода, при которой входной текстовый поток состоит из последовательности строк, каждая из которых заканчивается символом новой строки. Следовательно, подсчет строк сводится к подсчету числа символов новой строки.</p>
     <p><code>#include ‹stdio.h›</code></p>
     <p><code>/* подсчет строк входного потока */</code></p>
     <p><code>main()</code></p>
     <p><code>{</code></p>
     <p><code> int c, nl;</code></p>
     <p><code> nl = 0;</code></p>
     <p><code> while ((с = getchar()) != EOF)</code></p>
     <p><code>  if (c == '\n')</code></p>
     <p><code>   ++nl;</code></p>
     <p><code> printf("%d\n", nl);</code></p>
     <p><code>}</code></p>
     <p>Тело цикла теперь образует инструкция <emphasis>if</emphasis>, под контролем которой находится увеличение счетчика <emphasis>nl</emphasis> на единицу. Инструкция if проверяет условие в скобках и, если оно истинно, выполняет следующую за ним инструкцию (или группу инструкций, заключенную в фигурные скобки). Мы опять делаем отступы в тексте программы, чтобы показать, что чем управляется.</p>
     <p>Двойной знак равенства в языке Си обозначает оператор "равно" (он аналогичен оператору <emphasis>=</emphasis> в Паскале и <emphasis>.EQ.</emphasis> в Фортране). Удваивание знака <emphasis>=</emphasis> в операторе проверки на равенство сделано для того, чтобы отличить его от единичного <emphasis>=</emphasis>, используемого в Си для обозначения присваивания. Предупреждаем: начинающие программировать на Си иногда пишут <emphasis>=</emphasis>, а имеют в виду <emphasis>==</emphasis>. Как мы увидим в главе 2, в этом случае результатом будет обычно вполне допустимое по форме выражение, на которое компилятор не выдаст никаких предупреждающих сообщений (Современные компиляторы, как правило, выдают предупреждение о возможной ошибке. - <emphasis>Примеч. ред.</emphasis>).</p>
     <p>Символ, заключенный в одиночные кавычки, представляет собой целое значение, равное коду этого символа (в кодировке, принятой на данной машине). Это так называемая <emphasis>символьная константа</emphasis>. Существует и другой способ для написания маленьких целых значений. Например, 'A' есть символьная константа, в наборе символов ASCII ее значение равняется 65 - внутреннему представлению символа <emphasis>A</emphasis>. Конечно, 'A' в роли константы предпочтительнее, чем 65, поскольку смысл первой записи более очевиден, и она не зависит от конкретного способа кодировки символов.</p>
     <p>Эскейп-последовательности, используемые в строковых константах, допускаются также и в символьных константах. Так, <strong>'\n'</strong> обозначает код символа новой строки, который в ASCII равен 10. Следует обратить особое внимание на то, что <strong>'\n'</strong> обозначает один символ (код которого в выражении рассматривается как целое значение), в то время как <strong>"\n"</strong> - строковая константа, в которой чисто случайно указан один символ. Более подробно различие между символьными и строковыми константами разбирается в главе 2.</p>
     <p><strong>Упражнение 1.8</strong>. Напишите программу для подсчета пробелов, табуляций и новых строк.</p>
     <p><strong>Упражнение 1.9</strong>. Напишите программу, копирующую символы ввода в выходной поток и заменяющую стоящие подряд пробелы на один пробел.</p>
     <p><strong>Упражнение 1.10</strong>. Напишите программу, копирующую вводимые символы в выходной поток с заменой символа табуляции на <strong>\t</strong>, символа забоя на <strong>\b</strong> и каждой обратной наклонной черты на <strong>\\</strong>. Это сделает видимыми все символы табуляции и забоя.</p>
    </section>
    <section>
     <title>
      <p>1.5.4 Подсчет слов</p>
     </title>
     <p>Четвертая из нашей серии полезных программ подсчитывает строки, слова и символы, причем под словом здесь имеется в виду любая строка символов, не содержащая в себе пробелов, табуляций и символов новой строки. Эта программа является упрощенной версией программы <strong>wc</strong> системы UNIX.</p>
     <p><code>#include ‹stdio.h›</code></p>
     <empty-line/>
     <p><code>#define IN 1 /* внутри слова */</code></p>
     <p><code>#define OUT 0 /* вне слова */</code></p>
     <empty-line/>
     <p><code>/* подсчет строк, слов и символов */</code></p>
     <p><code>main()</code></p>
     <p><code>{</code></p>
     <p><code> int с, nl, nw, nc, state;</code></p>
     <p><code> state = OUT;</code></p>
     <p><code> nl = nw = nc = 0;</code></p>
     <p><code> while ((с = getchar()) != EOF) {</code></p>
     <p><code>  ++nc;</code></p>
     <p><code>  if (c == '\n')</code></p>
     <p><code>   ++nl;</code></p>
     <p><code>  if (c == ' ' || c == '\n' || c == '\t')</code></p>
     <p><code>   state = OUT;</code></p>
     <p><code>  else if (state == OUT) {</code></p>
     <p><code>   state = IN;</code></p>
     <p><code>   ++nw;</code></p>
     <p><code>  }</code></p>
     <p><code> }</code></p>
     <p><code> printf("%d %d %d\n", nl, nw, nc);</code></p>
     <p><code>}</code></p>
     <p>Каждый раз, встречая первый символ слова, программа изменяет значение счетчика слов на 1. Переменная <emphasis>state</emphasis> фиксирует текущее состояние - находимся мы внутри или вне слова. Вначале ей присваивается значение OUT, что соответствует состоянию "вне слова". Мы предпочитаем пользоваться именованными константами IN и OUT, а не собственно значениями 1 и 0, чтобы сделать программу более понятной. В такой маленькой программе этот прием мало что дает, но в большой программе увеличение ее ясности окупает незначительные дополнительные усилия, потраченные на то, чтобы писать программу в таком стиле с самого начала. Вы обнаружите, что большие изменения гораздо легче вносить в те программы, в которых магические числа встречаются только в виде именованных констант.</p>
     <p>Строка</p>
     <p><code>nl = nw = nc = 0;</code></p>
     <p>устанавливает все три переменные в нуль. Такая запись не является какой-то особой конструкцией и допустима потому, что присваивание есть выражение со своим собственным значением, а операции присваивания выполняются справа налево. Указанная строка эквивалентна</p>
     <p><code>nl = (nw = (nc = 0));</code></p>
     <p>Оператор <strong>||</strong> означает <strong>ИЛИ</strong>, так что строка</p>
     <p><code>if (c == ' ' || c == '\n' || c == '\t')</code></p>
     <p>читается как "если c есть пробел, <emphasis>или</emphasis> c есть новая строка, <emphasis>или</emphasis> c есть табуляция". (Напомним, что видимая эскейп-последовательность \t обозначает символ табуляции.) Существует также оператор <strong>&amp;&amp;</strong>, означающий <strong>И</strong>. Его приоритет выше, чем приоритет <strong>||</strong>. Выражения, связанные операторами &amp;&amp; или ||, вычисляются слева направо; при этом гарантируется, что вычисления сразу прервутся, как только будет установлена истинность или ложность условия. Если c есть пробел, то дальше проверять, является значение c символом новой строки или же табуляции, не нужно. В этом частном случае данный способ вычислений не столь важен, но он имеет значение в более сложных ситуациях, которые мы вскоре рассмотрим.</p>
     <p>В примере также встречается слово <strong>else</strong>, которое указывает на альтернативные действия, выполняемые в случае, когда условие, указанное в <strong>if</strong>, не является истинным. В общем виде условная инструкция записывается так:</p>
     <p><code><strong>if</strong> (<emphasis>выражение</emphasis>)</code></p>
     <p><code><emphasis> инструкция<sub>1</sub></emphasis></code></p>
     <p><code><strong>else</strong></code></p>
     <p><code><emphasis> инструкция<sub>2</sub></emphasis></code></p>
     <p>В конструкции <strong>if-else</strong> выполняется одна и только одна из двух инструкций. Если <emphasis>выражение</emphasis> истинно, то выполняется <emphasis>инструкция<sub>1</sub></emphasis>, если нет, то - <emphasis>инструкция<sub>2</sub></emphasis>. Каждая из этих двух инструкций представляет собой либо одну инструкцию, либо несколько, заключенных в фигурные скобки. В нашей программе после <emphasis>else</emphasis> стоит инструкция <emphasis>if</emphasis>, управляющая двумя такими инструкциями.</p>
     <p><strong>Упражнение 1.11</strong>. Как протестировать программу подсчета слов? Какой ввод вероятнее всего обнаружит ошибки, если они были допущены?</p>
     <p><strong>Упражнение 1.12</strong>. Напишите программу, которая печатает содержимое своего ввода, помещая по одному слову на каждой строке.</p>
    </section>
   </section>
   <section>
    <title>
     <p>1.6 Массивы</p>
    </title>
    <p>А теперь напишем программу, подсчитывающую по отдельности каждую цифру, символы-разделители (<emphasis>пробелы, табуляции и новые-строки</emphasis>) и все другие символы. Это несколько искусственная программа, но она позволит нам в одном примере продемонстрировать еще несколько возможностей языка Си. Имеется двенадцать категорий вводимых символов. Удобно все десять счетчиков цифр хранить в массиве, а не в виде десяти отдельных переменных. Вот один из вариантов этой программы:</p>
    <p><code>#include ‹stdio.h›</code></p>
    <empty-line/>
    <p><code>/* подсчет цифр, символов-разделителей и прочих символов */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int с, i, nwhite, nother;</code></p>
    <p><code> int ndigit[10];</code></p>
    <empty-line/>
    <p><code> nwhite = nother = 0;</code></p>
    <p><code> for (i = 0; i ‹ 10, ++i)</code></p>
    <p><code>  ndigit[i]= 0;</code></p>
    <empty-line/>
    <p><code> while ((c = getchar())!= EOF)</code></p>
    <p><code>  if (c ›='0' &amp;&amp; с ‹= '9')</code></p>
    <p><code>   ++ndigit[c - '0'];</code></p>
    <p><code>  else if (c == ' ' || c == '\n' || c == '\t')</code></p>
    <p><code>   ++nwhite;</code></p>
    <p><code>  else</code></p>
    <p><code>   ++nother;</code></p>
    <empty-line/>
    <p><code> printf("цифры =");</code></p>
    <p><code> for (i = 0; i ‹ 10; ++i)</code></p>
    <p><code>  printf("%d", ndigit[i]);</code></p>
    <p><code> printf(", символы-разделители =%d, прочие =%d\n", nwhite, nother);</code></p>
    <p><code>}</code></p>
    <p>В результате выполнения этой программы будет напечатан следующий результат:</p>
    <p><code>цифры = 9 3 0 0 0 0 0 0 0 1, символы-разделители = 123, прочие = 345</code></p>
    <p>Объявление</p>
    <p><code>int ndigit[10];</code></p>
    <p>объявляет <emphasis>ndigit</emphasis> массивом из 10 значений типа <emphasis>int</emphasis>. В Си элементы массива всегда нумеруются начиная с нуля, так что элементами этого массива будут ndigit[0], ndigit[1], …, ndigit[9], что учитывается в <emphasis>for</emphasis>-циклах (при инициализации и печати массива).</p>
    <p>Индексом может быть любое целое выражение, образуемое целыми переменными (например <emphasis>i</emphasis>) и целыми константами.</p>
    <p>Приведенная программа опирается на определенные свойства кодировки цифр. Например, проверка</p>
    <p><code> if (c ›= '0' &amp;&amp; c ‹= '9') …</code></p>
    <p>определяет, является ли находящийся в <emphasis>c</emphasis> символ цифрой. Если это так, то</p>
    <p><code>c -'0'</code></p>
    <p>есть числовое значение цифры. Сказанное справедливо только в том случае, если для ряда значений '0','1',…, '9' каждое следующее значение на 1 больше предыдущего. К счастью, это правило соблюдается во всех наборах символов.</p>
    <p>По определению, значения типа <emphasis>char</emphasis> являются просто малыми целыми, так что переменные и константы типа <emphasis>char</emphasis> в арифметических выражениях идентичны значениям типа <emphasis>int</emphasis>. Это и естественно, и удобно; например, c-'0' есть целое выражение с возможными значениями от 0 до 9, которые соответствуют символам от '0' до '9', хранящимся в переменной c. Таким образом, значение данного выражения является правильным индексом для массива ndigit.</p>
    <p>Следующий фрагмент определяет, является символ цифрой, символом-разделителем или чем-нибудь иным.</p>
    <p><code>if (c ›= '0' &amp;&amp; c ‹= '9')</code></p>
    <p><code> ++n[c-'0'];</code></p>
    <p><code>else if (c ==' ' || c == '\n' || c == '\t')</code></p>
    <p><code> ++nwhite;</code></p>
    <p><code>else</code></p>
    <p><code> ++nother;</code></p>
    <p>Конструкция вида</p>
    <p><code><strong>if</strong> (<emphasis>условие<sub>1</sub></emphasis>)</code></p>
    <p><code><emphasis> инструкция<sub>1</sub></emphasis></code></p>
    <p><code><strong>else if</strong> (<emphasis>условие<sub>2</sub></emphasis>)</code></p>
    <p><code><emphasis> инструкция<sub>2</sub></emphasis></code></p>
    <p><code>:</code></p>
    <p><code>:</code></p>
    <p><code><strong>else</strong></code></p>
    <p><code><emphasis> инструкция<sub>n</sub></emphasis></code></p>
    <p>часто применяется для выбора одного из нескольких альтернативных путей, имеющихся в программе. <emphasis>Условия</emphasis> вычисляются по порядку в направлении сверху вниз до тех пор, пока одно из них не будет удовлетворено; в этом случае будет выполнена соответствующая ему <emphasis>инструкция</emphasis>, и работа всей конструкции завершится. (Любая из инструкций может быть группой инструкций в фигурных скобках.) Если ни одно из условий не удовлетворено, выполняется последняя инструкция, расположенная сразу за <emphasis>else</emphasis>, если таковая имеется. Если же <emphasis>else</emphasis> и следующей за ней инструкции нет (как это было в программе подсчета слов), то никакие действия вообще не производятся. Между первым <emphasis>if</emphasis> и завершающим <emphasis>else</emphasis> может быть сколько угодно комбинаций вида</p>
    <p><code><strong>else if</strong> (<emphasis>условие</emphasis>)</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p>Когда их несколько, программу разумно форматировать так, как мы здесь показали. Если же каждый следующий <emphasis>if</emphasis> сдвигать вправо относительно предыдущего <emphasis>else</emphasis>, то при длинном каскаде проверок текст окажется слишком близко прижатым к правому краю страницы.</p>
    <p>Инструкция <strong>switch</strong>, речь о которой пойдет в главе 3, обеспечивает другой способ изображения многопутевого ветвления на языке Си. Он более подходит, в частности, тогда, когда условием перехода служит совпадение значения некоторого выражения целочисленного типа с одной из констант, входящих в заданный набор. Вариант нашей программы, реализованной с помощью <strong>switch</strong>, приводится в параграфе 3.4.</p>
    <p><strong>Упражнение 1.13</strong>. Напишите программу, печатающую гистограммы длин вводимых слов. Гистограмму легко рисовать горизонтальными полосами. Рисование вертикальными полосами - более трудная задача.</p>
    <p><strong>Упражнение 1.14</strong>. Напишите программу, печатающую гистограммы частот встречаемости вводимых символов.</p>
   </section>
   <section>
    <title>
     <p>1.7 Функции</p>
    </title>
    <p>Функции в Си играют ту же роль, что и подпрограммы и функции в Фортране или процедуры и функции в Паскале. Функция обеспечивает удобный способ отдельно оформить некоторое вычисление и пользоваться им далее, не заботясь о том, как оно реализовано. После того, как функции написаны, можно забыть, <emphasis>как</emphasis> они сделаны, достаточно знать лишь, <emphasis>что</emphasis> они умеют делать. Механизм использования функции в Си удобен, легок и эффективен. Нередко вы будете встречать короткие функции, вызываемые лишь единожды: они оформлены в виде функции с одной-единственной целью - получить более ясную программу.</p>
    <p>До сих пор мы пользовались готовыми функциями вроде main, getchar и putchar, теперь настала пора нам самим написать несколько функций. В Си нет оператора возведения в степень вроде ** в Фортране. Поэтому проиллюстрируем механизм определения функции на примере функции <strong>power(m, n)</strong>, которая возводит целое m в целую положительную степень n. Так, power(2, 5) имеет значение 32. На самом деле для практического применения эта функция малопригодна, так как оперирует лишь малыми целыми степенями, однако она вполне может послужить иллюстрацией. (В стандартной библиотеке есть функция <strong>pow(x, y)</strong>, вычисляющая x в степени y.)</p>
    <p>Итак, мы имеем функцию power и главную функцию main, пользующуюся ее услугами, так что вся программа выглядит следующим образом:</p>
    <p><code>#include ‹stdio.h›</code></p>
    <empty-line/>
    <p><code>int power(int m, int n);</code></p>
    <empty-line/>
    <p><code>/* тест функции power */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int i;</code></p>
    <p><code> for (i = 0; i ‹ 10; ++i)</code></p>
    <p><code>  printf("%d %d %d\n", i, power(2,i), power(-3,i));</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* возводит base в n-ю степень, n ›= 0 */</code></p>
    <p><code>int power(int base, int n)</code></p>
    <p><code>{</code></p>
    <p><code> int i, p;</code></p>
    <empty-line/>
    <p><code> p = 1;</code></p>
    <p><code> for (i = 1; i ‹= n; ++i)</code></p>
    <p><code>  p = p * base;</code></p>
    <p><code> return p;</code></p>
    <p><code>}</code></p>
    <p>Определение любой функции имеет следующий вид:</p>
    <p><code><emphasis>тип-результата имя-функции</emphasis> (<emphasis>список параметров, если он есть</emphasis>)</code></p>
    <p><code>{</code></p>
    <p><code><emphasis> объявления</emphasis></code></p>
    <p><code><emphasis> инструкции</emphasis></code></p>
    <p><code>}</code></p>
    <p>Определения функций могут располагаться в любом порядке в одном или в нескольких исходных файлах, но любая функция должна быть целиком расположена в каком-то одном. Если исходный текст программы распределен по нескольким файлам, то, чтобы ее скомпилировать и загрузить, вам придется сказать несколько больше, чем при использовании одного файла; но это уже относится к операционной системе, а не к языку. Пока мы предполагаем, что обе функции находятся в одном файле, так что будет достаточно тех знаний, которые вы уже получили относительно запуска программ на Си.</p>
    <p>В следующей строке из функции main к power обращаются дважды.</p>
    <p><code>printf("%d %d %d\n", i, power(2,i), power(-3,i));</code></p>
    <p>При каждом вызове функции power передаются два аргумента, и каждый раз главная программа main в ответ получает целое число, которое затем приводится к должному формату и печатается. Внутри выражения power(2, i) представляет собой целое значение точно так же, как 2 или i. (Не все функции в качестве результата выдают целые значения; подробно об этом будет сказано в главе 4.)</p>
    <p>В первой строке определения power:</p>
    <p><code>int power(int base, int n);</code></p>
    <p>указываются типы параметров, имя функции и тип результата. Имена параметров локальны внутри <emphasis>power</emphasis>, это значит, что они скрыты для любой другой функции, так что остальные подпрограммы могут свободно пользоваться теми же именами для своих целей. Последнее утверждение справедливо также для переменных i и p: i в power и i в main не имеют между собой ничего общего.</p>
    <p>Далее <emphasis>параметром</emphasis> мы будем называть переменную из списка параметров, заключенного в круглые скобки и заданного в определении функции, а <emphasis>аргументом</emphasis> - значение, используемое при обращении к функции. Иногда в том же смысле мы будем употреблять термины <emphasis>формальный аргумент</emphasis> и <emphasis>фактический аргумент</emphasis>.</p>
    <p>Значение, вычисляемое функцией power, возвращается в main с помощью инструкции <strong>return</strong>. За словом <emphasis>return</emphasis> может следовать любое выражение:</p>
    <p><code><strong>return</strong> <emphasis>выражение</emphasis>;</code></p>
    <p>Функция не обязательно возвращает какое-нибудь значение. Инструкция <emphasis>return</emphasis> без выражения только передает управление в ту программу, которая ее вызвала, не передавая ей никакого результирующего значения. То же самое происходит, если в процессе вычислений мы выходим на конец функции, обозначенный в тексте последней закрывающей фигурной скобкой. Возможна ситуация, когда вызывающая функция игнорирует возвращаемый ей результат.</p>
    <p>Вы, вероятно, обратили внимание на инструкцию <emphasis>return</emphasis> в конце <emphasis>main</emphasis>. Поскольку main есть функция, как и любая другая она может вернуть результирующее значение тому, кто ее вызвал, - фактически в ту среду, из которой была запущена программа. Обычно возвращается нулевое значение, что говорит о нормальном завершении выполнения. Ненулевое значение сигнализирует о необычном или ошибочном завершении. До сих пор ради простоты мы опускали return в main, но с этого момента будем задавать return как напоминание о том, что программы должны сообщать о состоянии своего завершения в операционную систему.</p>
    <p>Объявление</p>
    <p><code>int power(int m, int n);</code></p>
    <p>стоящее непосредственно перед <emphasis>main</emphasis>, сообщает, что функция power ожидает двух аргументов типа <emphasis>int</emphasis> и возвращает результат типа <emphasis>int</emphasis>. Это объявление, называемое <emphasis>прототипом функции</emphasis>, должно быть согласовано с определением и всеми вызовами <emphasis>power</emphasis>. Если определение функции или вызов не соответствует своему прототипу, это ошибка.</p>
    <p>Имена параметров не требуют согласования. Фактически в прототипе они могут быть произвольными или вообще отсутствовать, т. е. прототип можно было бы записать и так:</p>
    <p><code>int power(int, int);</code></p>
    <p>Однако удачно подобранные имена поясняют программу, и мы будем часто этим пользоваться.</p>
    <p>Историческая справка. Самые большие отличия ANSI-Си от более ранних версий языка как раз и заключаются в способах объявления и определения функций. В первой версии Си функцию power требовалось задавать в следующем виде:</p>
    <p>/* power: возводит base в n-ю степень, n ›= 0 */</p>
    <p>/* (версия в старом стиле языка Си) */</p>
    <p>power(base, n)</p>
    <p><code>int base, n;</code></p>
    <p><code>{</code></p>
    <p><code> int i, р;</code></p>
    <p><code> p = 1;</code></p>
    <p><code> for (i = 1; i ‹= n; ++i)</code></p>
    <p><code>  р = р * base;</code></p>
    <p><code> return р;</code></p>
    <p><code>}</code></p>
    <p>Здесь имена параметров перечислены в круглых скобках, а их типы заданы перед первой открывающей фигурной скобкой. В случае отсутствия указания о типе параметра, считается, что он имеет тип <emphasis>int</emphasis>. (Тело функции не претерпело изменений.)</p>
    <p>Описание power в начале программы согласно первой версии Си должно было бы выглядеть следующим образом:</p>
    <p><code>int power();</code></p>
    <p>Нельзя было задавать список параметров, и поэтому компилятор не имел возможности проверить правильность обращений к power. Так как при отсутствии объявления power предполагалось, что функция возвращает значение типа int, то в данном случае объявление целиком можно было бы опустить.</p>
    <p>Новый синтаксис для прототипов функций облегчает компилятору обнаружение ошибок в количестве аргументов и их типах. Старый синтаксис объявления и определения функции все еще допускается стандартом ANSI, по крайней мере на переходный период, но если ваш компилятор поддерживает новый синтаксис, мы настоятельно рекомендуем пользоваться только им.</p>
    <p><strong>Упражнение 1.15</strong>. Перепишите программу преобразования температур, выделив само преобразование в отдельную функцию.</p>
   </section>
   <section>
    <title>
     <p>1.8 Аргументы. Вызов по значению</p>
    </title>
    <p>Одно свойство функций в Си, вероятно, будет в новинку для программистов, которые уже пользовались другими языками, в частности Фортраном. В Си все аргументы функции передаются "по значению". Это следует понимать так, что вызываемой функции посылаются значения ее аргументов во временных переменных, а не сами аргументы. Такой способ передачи аргументов несколько отличается от "вызова по ссылке" в Фортране и спецификации var при параметре в Паскале, которые позволяют подпрограмме иметь доступ к самим аргументам, а не к их локальным копиям.</p>
    <p>Главное отличие заключается в том, что в Си вызываемая функция не может непосредственно изменить переменную вызывающей функции: она может изменить только ее частную, временную копию.</p>
    <p>Однако вызов по значению следует отнести к достоинствам языка, а не к его недостаткам. Благодаря этому свойству обычно удается написать более компактную программу, содержащую меньшее число посторонних переменных, поскольку параметры можно рассматривать как должным образом инициализированные локальные переменные вызванной подпрограммы. В качестве примера приведем еще одну версию функции power, в которой как раз использовано это свойство.</p>
    <p><code>/* power: возводит base в n-ю степень; n ›= 0, версия 2 */</code></p>
    <p><code>int power(int base, int n)</code></p>
    <p><code>{</code></p>
    <p><code> int p;</code></p>
    <p><code> for (p = 1; n › 0; -n)</code></p>
    <p><code>  p = p * base;</code></p>
    <p><code> return p;</code></p>
    <p><code>}</code></p>
    <p>Параметр n выступает здесь в роли временной переменной, в которой циклом <emphasis>for</emphasis> в убывающем порядке ведется счет числа шагов до тех пор, пока ее значение не станет нулем. При этом отпадает надобность в дополнительной переменной i для счетчика цикла. Что бы мы ни делали с n внутри power, это не окажет никакого влияния на сам аргумент, копия которого была передана функции power при ее вызове.</p>
    <p>При желании можно сделать так, чтобы функция смогла изменить переменную в вызывающей программе. Для этого последняя должна передать адрес подлежащей изменению переменной (<emphasis>указатель</emphasis> на переменную), а в вызываемой функции следует объявить соответствующий параметр как указатель и организовать через него косвенный доступ к этой переменной. Все, что касается указателей, мы рассмотрим в главе 5.</p>
    <p>Механизм передачи массива в качестве аргумента несколько иной. Когда аргументом является имя массива, то функции передается значение, которое является адресом начала этого массива; никакие элементы массива не копируются. С помощью индексирования относительно полученного значения функция имеет доступ к любому элементу массива. Разговор об этом пойдет в следующем параграфе.</p>
   </section>
   <section>
    <title>
     <p>1.9 Символьные массивы</p>
    </title>
    <p>Самый распространенный вид массива в Си - массив символов. Чтобы проиллюстрировать использование символьных массивов и работающих с ними функций, напишем программу, которая читает набор текстовых строк и печатает самую длинную из них. Ее схема достаточно проста:</p>
    <p><code><strong>while</strong> (<emphasis>есть ли еще строка?</emphasis>)</code></p>
    <p><code><strong> if</strong> (<emphasis>данная строка длиннее самой длинной из предыдущих</emphasis>)</code></p>
    <p><code><emphasis>  запомнить ее</emphasis></code></p>
    <p><code><emphasis>  запомнить ее длину</emphasis></code></p>
    <p><code><emphasis>напечатать самую длинную строку</emphasis></code></p>
    <p>Из схемы видно, что программа естественным образом распадается на части. Одна из них получает новую строку, другая проверяет ее, третья запоминает, а остальные управляют процессом вычислений.</p>
    <p>Поскольку процесс четко распадается на части, хорошо бы так и перевести его на Си. Поэтому сначала напишем отдельную функцию getline для получения очередной строки. Мы попытаемся сделать эту функцию полезной и для других применений. Как минимум getline должна сигнализировать о возможном конце файла, а еще лучше, если она будет выдавать длину строки - или нуль в случае исчерпания файла. Нуль годится для признака конца файла, поскольку не бывает строк нулевой длины, даже строка, содержащая только один символ новой строки, имеет длину 1.</p>
    <p>Когда мы обнаружили строку более длинную, чем самая длинная из всех предыдущих, то нам надо будет где-то ее запомнить. Здесь напрашивается вторая функция, copy, которая умеет копировать новую строку в надежное место.</p>
    <p>Наконец, нам необходима главная программа, которая бы управляла функциями getline и copy. Вот как выглядит наша программа в целом:</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#define MAXLINE 1000 /* максимальный размер вводимой строки */</code></p>
    <empty-line/>
    <p><code>int getline(char line[], int MAXLINE);</code></p>
    <p><code>void copy(char to[], char from[]);</code></p>
    <empty-line/>
    <p><code>/* печать самой длинной строки */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int len; /* длина текущей строки */</code></p>
    <p><code> int max; /* длина максимальной из просмотренных строк */</code></p>
    <p><code> char line[MAXLINE]; /* текущая строка */</code></p>
    <p><code> char longest[MAXLINE]; /* самая длинная строка */</code></p>
    <empty-line/>
    <p><code> max = 0;</code></p>
    <p><code> while (len = getline(line, MAXLINE)) › 0)</code></p>
    <p><code>  if (len › max) {</code></p>
    <p><code>   max = len;</code></p>
    <p><code>   copy(longest, line);</code></p>
    <p><code>  }</code></p>
    <p><code> if (max › 0) /* была ли хоть одна строка? */</code></p>
    <p><code>  printf("%s", longest);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* getline: читает строку в s, возвращает длину */</code></p>
    <p><code>int getline(char s[], int lim)</code></p>
    <p><code>{</code></p>
    <p><code> int c, i;</code></p>
    <empty-line/>
    <p><code> for (i = 0; i ‹ lim-1 &amp;&amp; (c = getchar()) != EOF &amp;&amp; с != '\n'; ++i)</code></p>
    <p><code>  s[i] = c;</code></p>
    <p><code> if (c == '\n') {</code></p>
    <p><code>  s[i] = c;</code></p>
    <p><code>  ++i;</code></p>
    <p><code> }</code></p>
    <p><code> s[i] = '\0';</code></p>
    <p><code> return i;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* copy: копирует из 'from' в 'to'; to достаточно большой */</code></p>
    <p><code>void copy(char to[], char from[])</code></p>
    <p><code>{</code></p>
    <p><code> int i;</code></p>
    <empty-line/>
    <p><code> i = 0;</code></p>
    <p><code> while ((to[i] = from[i]) != '\0')</code></p>
    <p><code>  ++i;</code></p>
    <p><code>}</code></p>
    <p>Мы предполагаем, что функции <emphasis>getline</emphasis> и <emphasis>copy</emphasis>, описанные в начале программы, находятся в том же файле, что и <emphasis>main</emphasis>.</p>
    <p>Функции <emphasis>main</emphasis> и <emphasis>getline</emphasis> взаимодействуют между собой через пару аргументов и возвращаемое значение. В <emphasis>getline</emphasis> аргументы определяются строкой</p>
    <p><code>int getline(char s[], int lim);</code></p>
    <p>Как мы видим, ее первый аргумент <emphasis>s</emphasis> есть массив, а второй, <emphasis>lim</emphasis>, имеет тип <emphasis>int</emphasis>. Задание размера массива в определении имеет целью резервирование памяти. В самой <emphasis>getline</emphasis> задавать длину массива <emphasis>s</emphasis> нет необходимости, так как его размер указан в <emphasis>main</emphasis>. Чтобы вернуть значение вызывающей программе, <emphasis>getline</emphasis> использует <emphasis>return</emphasis> точно так же, как это делает функция <emphasis>power</emphasis>. В приведенной строке также сообщается, что <emphasis>getline</emphasis> возвращает значение типа <emphasis>int</emphasis>, но так как при отсутствии указания о типе подразумевается <emphasis>int</emphasis>, то перед <emphasis>getline</emphasis> слово <emphasis>int</emphasis> можно опустить.</p>
    <p>Одни функции возвращают результирующее значение, другие (такие как <emphasis>copy</emphasis>) нужны только для того, чтобы произвести какие-то действия, не выдавая никакого значения. На месте типа результата в <emphasis>copy</emphasis> стоит <strong>void</strong>. Это явное указание на то, что никакого значения данная функция не возвращает.</p>
    <p>Функция <emphasis>getline</emphasis> в конец создаваемого ею массива помещает символ <strong>'\0'</strong> (<strong>null</strong>-символ, кодируемый нулевым байтом), чтобы пометить конец строки символов. То же соглашение относительно окончания нулем соблюдается и в случае строковой константы вроде</p>
    <p><code>"hello\n"</code></p>
    <p>В данном случае для него формируется массив из символов этой строки с '\0' в конце.</p>
    <p><strong>h е l l o \n \0 </strong></p>
    <p>Спецификация <emphasis>%s</emphasis> в формате <emphasis>printf</emphasis> предполагает, что соответствующий ей аргумент - строка символов, оформленная указанным выше образом. Функция <emphasis>copy</emphasis> в своей работе также опирается на тот факт, что читаемый ею аргумент заканчивается символом '\0', который она копирует наряду с остальными символами. (Всё сказанное предполагает, что '\0' не встречается внутри обычного текста.)</p>
    <p>Попутно стоит заметить, что при работе даже с такой маленькой программой мы сталкиваемся с некоторыми конструктивными трудностями. Например, что должна делать <emphasis>main</emphasis>, если встретится строка, превышающая допустимый размер? Функция <emphasis>getline</emphasis> работает надежно: если массив полон, она прекращает пересылку, даже если символа новой строки не обнаружила. Получив от <emphasis>getline</emphasis> длину строки и увидев, что она совпадает с MAXLINE, главная программа main могла бы "отловить" этот особый случай и справиться с ним. В интересах краткости описание этого случая мы здесь опускаем.</p>
    <p>Пользователи <emphasis>getline</emphasis> не могут заранее узнать, сколь длинными будут вводимые строки, поэтому <emphasis>getline</emphasis> делает проверки на переполнение. А вот пользователям функции <emphasis>copy</emphasis> размеры копируемых строк известны (или они могут их узнать), поэтому дополнительный контроль здесь не нужен.</p>
    <p><strong>Упражнение 1.16</strong>. Перепишите main предыдущей программы так, чтобы она могла печатать самую длинную строку без каких-либо ограничений на ее размер.</p>
    <p><strong>Упражнение 1.17</strong>. Напишите программу печати всех вводимых строк, содержащих более 80 символов.</p>
    <p><strong>Упражнение 1.18</strong>. Напишите программу, которая будет в каждой вводимой строке заменять стоящие подряд символы пробелов и табуляций на один пробел и удалять пустые строки.</p>
    <p><strong>Упражнение 1.19</strong>. Напишите функцию <emphasis>reverse(s)</emphasis>, размещающую символы в строке <emphasis>s</emphasis> в обратном порядке. Примените ее при написании программы, которая каждую вводимую строку располагает в обратном порядке.</p>
   </section>
   <section>
    <title>
     <p>1.10 Внешние переменные и область видимости</p>
    </title>
    <p>Переменные <emphasis>line</emphasis>, <emphasis>longest</emphasis> и прочие принадлежат только функции <emphasis>main</emphasis>, или, как говорят, локальны в ней. Поскольку они объявлены внутри <emphasis>main</emphasis>, никакие другие функции прямо к ним обращаться не могут. То же верно и применительно к переменным других функций. Например, <emphasis>i</emphasis> в <emphasis>getline</emphasis> не имеет никакого отношения к <emphasis>i</emphasis> в <emphasis>copy</emphasis>. Каждая локальная переменная функции возникает только в момент обращения к этой функции и исчезает после выхода из нее. Вот почему такие переменные, следуя терминологии других языков, называют <emphasis>автоматическими</emphasis>. (В главе 4 обсуждается класс памяти <strong>static</strong>, который позволяет локальным переменным сохранять свои значения в промежутках между вызовами.)</p>
    <p>Так как автоматические переменные образуются и исчезают одновременно с входом в функцию и выходом из нее, они не сохраняют своих значений от вызова к вызову и должны устанавливаться заново при каждом новом обращении к функции. Если этого не делать, они будут содержать "мусор".</p>
    <p>В качестве альтернативы автоматическим переменным можно определить <emphasis>внешние</emphasis> переменные, к которым разрешается обращаться по их именам из любой функции. (Этот механизм аналогичен области COMMON в Фортране и определениям переменных в самом внешнем блоке в Паскале.) Так как внешние переменные доступны повсеместно, их можно использовать вместо аргументов для связи между функциями по данным. Кроме того, поскольку внешние переменные существуют постоянно, а не возникают и исчезают на период выполнения функции, свои значения они сохраняют и после возврата из функций, их установивших.</p>
    <p>Внешняя переменная должна быть <emphasis>определена</emphasis>, причем только один раз, вне текста любой функции; в этом случае ей будет выделена память. Она должна быть <emphasis>объявлена</emphasis> во всех функциях, которые хотят ею пользоваться. Объявление содержит сведения о типе переменной. Объявление может быть явным, в виде инструкции <strong>extern</strong>, или неявным, когда нужная информация получается из контекста. Чтобы конкретизировать сказанное, перепишем программу печати самой длинной строки с использованием <emphasis>line</emphasis>, <emphasis>longest</emphasis> и <emphasis>max</emphasis> в качестве внешних переменных. Это потребует изменений в вызовах, объявлениях и телах всех трех функций.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <empty-line/>
    <p><code>#define MAXLINE 1000 /* максимальный размер вводимой строки */</code></p>
    <empty-line/>
    <p><code>int max; /* длина максимальной из просмотренных строк */</code></p>
    <p><code>char line[MAXLINE]; /* текущая строка */</code></p>
    <p><code>char longest[MAXLINE]; /* самая длинная строка */</code></p>
    <empty-line/>
    <p><code>int getline(void);</code></p>
    <p><code>void copy(void);</code></p>
    <empty-line/>
    <p><code>/* печать самой длинной строки: специализированная версия */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int len;</code></p>
    <p><code> extern int max;</code></p>
    <p><code> extern char longest[];</code></p>
    <p><code> max = 0;</code></p>
    <p><code> while ((len = getline()) › 0)</code></p>
    <p><code> if (len › max) {</code></p>
    <p><code>  max = len;</code></p>
    <p><code>  copy();</code></p>
    <p><code> }</code></p>
    <p><code> if (max › 0) /* была хотя бы одна строка */</code></p>
    <p><code>  printf("%s", longest);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* getline: специализированная версия */</code></p>
    <p><code>int getline(void)</code></p>
    <p><code>{</code></p>
    <p><code> int c, i;</code></p>
    <p><code> extern char line[];</code></p>
    <p><code> for (i = 0; i ‹ MAXLINE-1 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c!= '\n'; ++i)</code></p>
    <p><code>  line[i] = c;</code></p>
    <p><code> if (c == '\n') {</code></p>
    <p><code>  line[i]= c;</code></p>
    <p><code>  ++i;</code></p>
    <p><code> }</code></p>
    <p><code> line[i] = '\0';</code></p>
    <p><code> return i;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* copy: специализированная версия */</code></p>
    <p><code>void copy(void)</code></p>
    <p><code>{</code></p>
    <p><code> int i;</code></p>
    <p><code> extern char line[], longest[];</code></p>
    <empty-line/>
    <p><code> i = 0;</code></p>
    <p><code> while ((longest[i] = line[i]) != '\0')</code></p>
    <p><code>  ++i;</code></p>
    <p><code>}</code></p>
    <p>Внешние переменные для <emphasis>main, getline</emphasis> и <emphasis>copy</emphasis> определяются в начале нашего примера, где им присваивается тип и выделяется память. Определения внешних переменных синтаксически ничем не отличаются от определения локальных переменных, но поскольку они расположены вне функций, эти переменные считаются внешними. Чтобы функция могла пользоваться внешней переменной, ей нужно прежде всего сообщить имя соответствующей переменной. Это можно сделать, например, задав объявление <emphasis>extern</emphasis>, которое по виду отличается от объявления внешней переменной только тем, что оно начинается с ключевого слова <emphasis>extern</emphasis>.</p>
    <p>В некоторых случаях объявление <emphasis>extern</emphasis> можно опустить. Если определение внешней переменной в исходном файле расположено выше функции, где она используется, то в объявлении <emphasis>extern</emphasis> нет необходимости. Таким образом, в <emphasis>main, getline</emphasis> и <emphasis>copy</emphasis> объявления <emphasis>extern</emphasis> избыточны. Обычно определения внешних переменных располагают в начале исходного файла, и все объявления <emphasis>extern</emphasis> для них опускают.</p>
    <p>Если же программа расположена в нескольких исходных файлах и внешняя переменная определена в <emphasis>файле1</emphasis>, а используется в <emphasis>файле2</emphasis> и <emphasis>файлеЗ</emphasis>, то объявления <emphasis>extern</emphasis> в <emphasis>файле2</emphasis> и <emphasis>файлеЗ</emphasis> обязательны, поскольку необходимо указать, что во всех трех файлах функции обращаются к одной и той же внешней переменной. На практике обычно удобно собрать все объявления внешних переменных и функций в отдельный файл, называемый <strong>заголовочным</strong> (<emphasis>header</emphasis>-файлом), и помещать его с помощью <strong>#include</strong> в начало каждого исходного файла. В именах header-файлов по общей договоренности используется суффикс <strong>.h</strong>. В этих файлах, в частности в <emphasis>‹stdio.h›</emphasis>, описываются также функции стандартной библиотеки. Более подробно о заголовочных файлах говорится в главе 4, а применительно к стандартной библиотеке - в главе 7 и приложении B.</p>
    <p>Так как специализированные версии getline и copy не имеют аргументов, на первый взгляд кажется, что логично их прототипы задать в виде getline() и copy(). Но из соображений совместимости со старыми Си-программами стандарт рассматривает пустой список как сигнал к тому, чтобы выключить все проверки на соответствие аргументов. Поэтому, когда нужно сохранить контроль и явно указать отсутствие аргументов, следует пользоваться словом <strong>void</strong>. Мы вернемся к этой проблеме в главе 4.</p>
    <p>Заметим, что по отношению к внешним переменным в этом параграфе мы очень аккуратно используем понятия <emphasis>определение</emphasis> и <emphasis>объявление</emphasis>. "Определение" располагается в месте, где переменная создается и ей отводится память; "объявление" помещается там, где фиксируется природа переменной, но никакой памяти для нее не отводится.</p>
    <p>Следует отметить тенденцию все переменные делать внешними. Дело в том, что, как может показаться на первый взгляд, это приводит к упрощению связей - ведь списки аргументов становятся короче, а переменные доступны везде, где они нужны; однако они оказываются доступными и там, где не нужны. Так что чрезмерный упор на внешние переменные чреват большими опасностями - он приводит к созданию программ, в которых связи по данным не очевидны, поскольку переменные могут неожиданным и даже таинственным способом изменяться. Кроме того, такая программа с трудом поддается модификациям. Вторая версия программы поиска самой длинной строки хуже, чем первая, отчасти по этим причинам, а отчасти из-за нарушения общности двух полезных функций, вызванного тем, что в них вписаны имена конкретных переменных, с которыми они оперируют.</p>
    <p>Итак, мы рассмотрели то, что можно было бы назвать ядром Си. Описанных "кирпичиков" достаточно, чтобы создавать полезные программы значительных размеров, и было бы чудесно, если бы вы, прервав чтение, посвятили этому какое-то время. В следующих упражнениях мы предлагаем вам создать несколько более сложные программы, чем рассмотренные выше.</p>
    <p><strong>Упражнение 1.20</strong>. Напишите программу detab, заменяющую символы табуляции во вводимом тексте нужным числом пробелов (до следующего "стопа" табуляции). Предполагается, что "стопы" табуляции расставлены на фиксированном расстоянии друг от друга, скажем, через n позиций. Как лучше задавать n - в виде значения переменной или в виде именованной константы?</p>
    <p><strong>Упражнение 1.21</strong>. Напишите программу entab, заменяющую строки из пробелов минимальным числом табуляций и пробелов таким образом, чтобы вид напечатанного текста не изменился. Используйте те же "стопы" табуляции, что и в detab. В случае, когда для выхода на очередной "стоп" годится один пробел, что лучше - пробел или табуляция?</p>
    <p><strong>Упражнение 1.22</strong>. Напишите программу, печатающую символы входного потока так, чтобы строки текста не выходили правее n-й позиции. Это значит, что каждая строка, длина которой превышает n, должна печататься с переносом на следующие строки. Место переноса следует " искать" после последнего символа, отличного от символа-разделителя, расположенного левее n-й позиции. Позаботьтесь о том, чтобы ваша программа вела себя разумно в случае очень длинных строк, а также когда до n-й позиции не встречается ни одного символа пробела или табуляции.</p>
    <p><strong>Упражнение 1.23</strong>. Напишите программу, убирающую все комментарии из любой Си-программы. Не забудьте должным образом обработать строки символов и строковые константы. Комментарии в Си не могут быть вложены друг в друга.</p>
    <p><strong>Упражнение 1.24</strong>. Напишите программу, проверяющую Си-программы на элементарные синтаксические ошибки вроде несбалансированности скобок всех видов. Не забудьте о кавычках (одиночных и двойных), эскейп-последовательностях (\…) и комментариях. (Это сложная программа, если писать ее для общего случая.)</p>
   </section>
  </section>
  <section>
   <title>
    <p>Глава 2. Типы, операторы и выражения</p>
   </title>
   <section>
    <p>Переменные и константы являются основными объектами данных, с которыми имеет дело программа. Переменные перечисляются в объявлениях, где устанавливаются их типы и, возможно, начальные значения. Операции определяют действия, которые совершаются с этими переменными. Выражения комбинируют переменные и константы для получения новых значений. Тип объекта определяет множество значений, которые этот объект может принимать, и операций, которые над ними, могут выполняться. Названные "кирпичики" и будут предметом обсуждения в этой главе.</p>
    <p>Стандартом ANSI было утверждено значительное число небольших изменений и добавлений к основным типам и выражениям. Любой целочисленный тип теперь может быть со знаком, <strong>signed</strong>, и без знака, <strong>unsigned</strong>. Предусмотрен способ записи беззнаковых констант и шестнадцатеричных символьных констант. Операции с плавающей точкой допускаются теперь и с одинарной точностью. Введен тип <strong>long double</strong>, обеспечивающий повышенную точность. Строковые константы конкатенируются ("склеиваются") теперь во время компиляции. Частью языка стали перечисления (<strong>enum</strong>), формализующие для типа установку диапазона значений. Объекты для защиты их от каких-либо изменений разрешено помечать как <strong>const</strong>. В связи с введением новых типов расширены правила автоматического преобразования из одного арифметического типа в другой.</p>
   </section>
   <section>
    <title>
     <p>2.1 Имена переменных</p>
    </title>
    <p>Хотя мы ничего не говорили об этом в главе 1, но существуют некоторые ограничения на задание имен переменных и именованных констант.</p>
    <p>Имена составляются из букв и цифр; первым символом должна быть буква. Символ подчеркивания "_" считается буквой; его иногда удобно использовать, чтобы улучшить восприятие длинных имен переменных. Не начинайте имена переменных с подчеркивания, так как многие переменные библиотечных программ начинаются именно с этого знака. Большие (прописные) и малые (строчные) буквы различаются, так что x и X - это два разных имени. Обычно в программах на Си малыми буквами набирают переменные, а большими - именованные константы.</p>
    <p>Для внутренних имен значимыми являются первые 31 символ. Для имен функций и внешних переменных число значимых символов может быть меньше 31, так как эти имена обрабатываются ассемблерами и загрузчиками и языком не контролируются. Уникальность внешних имен гарантируется только в пределах 6 символов, набранных безразлично в каком регистре. Ключевые слова <strong>if</strong>, <strong>else</strong>, <strong>int</strong>, <strong>float</strong> и т. д. зарезервированы, и их нельзя использовать в качестве имен переменных. Все они набираются на нижнем регистре (т. е. малыми буквами).</p>
    <p>Разумно давать переменным осмысленные имена в соответствии с их назначением, причем такие, чтобы их было трудно спутать друг с другом. Мы предпочитаем короткие имена для локальных переменных, особенно для счетчиков циклов, и более длинные для внешних переменных.</p>
   </section>
   <section>
    <title>
     <p>2.2 Типы и размеры данных</p>
    </title>
    <p>В Си существует всего лишь несколько базовых типов:</p>
    <p><strong>char</strong> - единичный байт, который может содержать один символ из допустимого символьного набора;</p>
    <p><strong>int</strong> - целое, обычно отображающее естественное представление целых в машине;</p>
    <p><strong>float</strong> - число с плавающей точкой одинарной точности;</p>
    <p><strong>double</strong> - число с плавающей точкой двойной точности.</p>
    <p>Имеется также несколько квалификаторов, которые можно использовать вместе с указанными базовыми типами. Например, квалификаторы <strong>short</strong> (короткий) и <strong>long</strong> (длинный) применяются к целым:</p>
    <p><code>short int sh;</code></p>
    <p><code>long int counter;</code></p>
    <p>В таких объявлениях слово <strong>int</strong> можно опускать, что обычно и делается. Если только не возникает противоречий со здравым смыслом, <strong>short int</strong> и <strong>long int</strong> должны быть разной длины, а <strong>int</strong> соответствовать естественному размеру целых на данной машине. Чаще всего для представления целого, описанного с квалификатором <strong>short</strong>, отводится 16 бит, с квалификатором <strong>long</strong> - 32 бита, а значению типа <strong>int</strong> - или 16, или 32 бита. Разработчики компилятора вправе сами выбирать подходящие размеры, сообразуясь с характеристиками своего компьютера и соблюдая следующие ограничения: значения типов <strong>short</strong> и <strong>int</strong> представляются по крайней мере 16 битами; типа <strong>long</strong> - по крайней мере 32 битами; размер <strong>short</strong> не больше размера <strong>int</strong>, который в свою очередь не больше размера <strong>long</strong>.</p>
    <p>Квалификаторы <strong>signed</strong> (со знаком) или <strong>unsigned</strong> (без знака) можно применять к типу <strong>char</strong> и любому целочисленному типу. Значения <strong>unsigned</strong> всегда положительны или равны нулю и подчиняются законам арифметики по модулю 2<sup>n</sup>, где n - количество бит в представлении типа. Так, если значению <strong>char</strong> отводится 8 битов, то <strong>unsigned char</strong> имеет значения в диапазоне от 0 до 255, a <strong>signed char</strong> - от -128 до 127 (в машине с двоичным дополнительным кодом). Являются ли значения типа просто <strong>char</strong> знаковыми или беззнаковыми, зависит от реализации, но в любом случае коды печатаемых символов положительны.</p>
    <p>Тип <strong>long double</strong> предназначен для арифметики с плавающей точкой повышенной точности. Как и в случае целых, размеры объектов с плавающей точкой зависят от реализации; <strong>float</strong>, <strong>double</strong> и <strong>long double</strong> могут представляться одним размером, а могут - двумя или тремя разными размерами.</p>
    <p>Именованные константы для всех размеров вместе с другими характеристиками машины и компилятора содержатся в стандартных заголовочных файлах <strong>‹limits.h›</strong> и <strong>‹float.h›</strong> (см. приложение B).</p>
    <p><strong>Упражнение 2.1</strong>. Напишите программу, которая будет выдавать диапазоны значений типов <strong>char</strong>, <strong>short</strong>, <strong>int</strong> и <strong>long</strong>, описанных как <strong>signed</strong> и как <strong>unsigned</strong>, с помощью печати соответствующих значений из стандартных заголовочных файлов и путем прямого вычисления. Определите диапазоны чисел с плавающей точкой различных типов. Вычислить эти диапазоны сложнее.</p>
   </section>
   <section>
    <title>
     <p>2.3 Константы</p>
    </title>
    <p>Целая константа, например 1234, имеет тип <strong>int</strong>. Константа типа <strong>long</strong> завершается буквой <strong>l</strong> или <strong>L</strong>, например 123456789L: слишком большое целое, которое невозможно представить как <strong>int</strong>, будет представлено как <strong>long</strong>. Беззнаковые константы заканчиваются буквой <strong>u</strong> или <strong>U</strong>, а окончание <strong>ul</strong> или <strong>UL</strong> говорит о том, что тип константы - <strong>unsigned long</strong>.</p>
    <p>Константы с плавающей точкой имеют десятичную точку (123.4), или экспоненциальную часть (1е-2), или же и то и другое. Если у них нет окончания, считается, что они принадлежат к типу <strong>double</strong>. Окончание <strong>f</strong> или <strong>F</strong> указывает на тип <strong>float</strong>, а <strong>l</strong> или <strong>L</strong> - на тип <strong>long double</strong>.</p>
    <p>Целое значение помимо десятичного может иметь восьмеричное или шестнадцатеричное представление. Если константа начинается с нуля, то она представлена в восьмеричном виде, если с 0x или с 0X, то - в шестнадцатеричном. Например, десятичное целое 31 можно записать как 037 или как 0X1F. Записи восьмеричной и шестнадцатеричной констант могут завершаться буквой <strong>L</strong> (для указания на тип <strong>long</strong>) и <strong>U</strong> (если нужно показать, что константа беззнаковая). Например, константа 0XFUL имеет значение 15 и тип <strong>unsigned long</strong>.</p>
    <p><strong>Символьная константа</strong> есть целое, записанное в виде символа, обрамленного одиночными кавычками, например 'x'. Значением символьной константы является числовой код символа из набора символов на данной машине. Например, символьная константа '0' в кодировке ASCII имеет значение 48, которое никакого отношения к числовому значению 0 не имеет. Когда мы пишем '0', а не какое-то значение (например 46), зависящее от способа кодировки, мы делаем программу независимой от частного значения кода, к тому же она и легче читается. Символьные константы могут участвовать в операциях над числами точно так же, как и любые другие целые, хотя чаще они используются для сравнения с другими символами.</p>
    <p>Некоторые символы в символьных и строковых константах записываются с помощью эскейп-последовательностей, например \n (символ новой строки); такие последовательности изображаются двумя символами, но обозначают один. Кроме того, произвольный восьмеричный код можно задать в виде</p>
    <p><code>'\ooo'</code></p>
    <p>где ооо - одна, две или три восьмеричные цифры (0:7) или</p>
    <p><code>'\xhh'</code></p>
    <p>где hh - одна, две или более шестнадцатеричные цифры (0…9, а…f, A…F). Таким образом, мы могли бы написать</p>
    <p><code>#define VTAB '013' /* вертикальная табуляция в ASCII */</code></p>
    <p><code>#define BELL '\007' /* звонок в ASCII */</code></p>
    <p>или в шестнадцатеричном виде:</p>
    <p><code>#define VTAB '\xb' /* вертикальная табуляций в ASCII */</code></p>
    <p><code>#define BELL '\x7' /* звонок в ASCII */</code></p>
    <p>Полный набор эскейп-последовательностей таков:</p>
    <p><code><strong>\а</strong> сигнал-звонок</code></p>
    <p><code><strong>\b</strong> возврат-на-шаг (забой)</code></p>
    <p><code><strong>\f</strong> перевод-страницы</code></p>
    <p><code><strong>\n</strong> новая-строка</code></p>
    <p><code><strong>\r</strong> возврат-каретки</code></p>
    <p><code><strong>\t</strong> горизонтальная-табуляция</code></p>
    <p><code><strong>\v</strong> вертикальная-табуляция</code></p>
    <p><code><strong>\\</strong> обратная наклонная черта</code></p>
    <p><code><strong>\?</strong> знак вопроса</code></p>
    <p><code><strong>\'</strong> одиночная кавычка</code></p>
    <p><code><strong>\"</strong> двойная кавычка</code></p>
    <p><code><strong>\ooo</strong> восьмеричный код</code></p>
    <p><code><strong>\xhh</strong> шестнадцатеричный код</code></p>
    <p>Символьная константа '\0' - это символ с нулевым значением, так называемый символ <strong>null</strong>. Вместо просто 0 часто используют запись '\0', чтобы подчеркнуть символьную природу выражения, хотя и в том и другом случае запись обозначает нуль.</p>
    <p>Константные выражения - это выражения, оперирующие только с константами. Такие выражения вычисляются во время компиляции, а не во время выполнения, и поэтому их можно использовать в любом месте, где допустимы константы, как, например, в</p>
    <p><code>#define MAXLINE 1000</code></p>
    <p><code>char line[MAXLINE+1];</code></p>
    <p>или в</p>
    <p><code>#define LEAP 1 /* in leap years - в високосные годы */</code></p>
    <p><code>int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];</code></p>
    <p><strong>Строковая константа</strong>, или <emphasis>строковый литерал</emphasis>, - это нуль или более символов, заключенных в двойные кавычки, как, например,</p>
    <p><code>"Я строковая константа"</code></p>
    <p>или</p>
    <p><code>"" /* пустая строка */</code></p>
    <p>Кавычки не входят в строку, а служат только ее ограничителями. Так же, как и в символьные константы, в строки можно включать эскейп-последовательности; \", например, представляет собой двойную кавычку. Строковые константы можно конкатенировать ("склеивать") во время компиляции; например, запись двух строк</p>
    <p><code>"Здравствуй," " мир!"</code></p>
    <p>эквивалентна записи одной следующей строки:</p>
    <p><code>"Здравствуй, мир!"</code></p>
    <p>Указанное свойство позволяет разбивать длинные строки на части и располагать эти части на отдельных строчках.</p>
    <p>Фактически строковая константа - это массив символов. Во внутреннем представлении строки в конце обязательно присутствует нулевой символ '\0', поэтому памяти для строки требуется на один байт больше, чем число символов, расположенных между двойными кавычками. Это означает, что на длину задаваемой строки нет ограничения, но чтобы определить ее длину, требуется просмотреть всю строку. Функция <strong>strlen(s)</strong> вычисляет длину строки s без учета завершающего ее символа '\0'. Ниже приводится наша версия этой функции:</p>
    <p><code>/* strlen: возвращает длину строки s */</code></p>
    <p><code>int strlen(char s[])</code></p>
    <p><code>{</code></p>
    <p><code> int i;</code></p>
    <p><code> i = 0;</code></p>
    <p><code> while (s[i] != '\0')</code></p>
    <p><code>  ++i;</code></p>
    <p><code> return i;</code></p>
    <p><code>}</code></p>
    <p>Функция <strong>strlen</strong> и некоторые другие, применяемые к строкам, описаны в стандартном заголовочном файле <strong>‹string.h›</strong>.</p>
    <p>Будьте внимательны и помните, что символьная константа и строка, содержащая один символ, не одно и то же: 'x' не то же самое, что "x". Запись 'x' обозначает целое значение, равное коду буквы x из стандартного символьного набора, а запись "x" - массив символов, который содержит один символ (букву x) и '\0'.</p>
    <p>В Си имеется еще один вид константы - константа перечисления. Перечисление - это список целых констант, как, например, в</p>
    <p><code>enum boolean {NO, YES};</code></p>
    <p>Первое имя в enum имеет значение 0, следующее - 1 и т.д. (если для значений констант не было явных спецификаций). Если не все значения специфицированы, то они продолжают прогрессию, начиная от последнего специфицированного значения, как в следующих двух примерах:</p>
    <p><code>enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t',</code></p>
    <p><code>                        NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };</code></p>
    <p><code>enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,</code></p>
    <p><code>                        JUL, AUG, SEP, OCT, NOV, DEC };</code></p>
    <p><code>                        /* FEB есть 2, MAR есть 3 и т.д. */</code></p>
    <p>Имена в различных перечислениях должны отличаться друг от друга. Значения внутри одного перечисления могут совпадать.</p>
    <p>Средство <strong>enum</strong> обеспечивает удобный способ присвоить константам имена, причем в отличие от <strong>#define</strong> значения констант при этом способе могут генерироваться автоматически. Хотя разрешается объявлять переменные типа <strong>enum</strong>, однако компилятор не обязан контролировать, входят ли присваиваемые этим переменным значения в их тип. Но сама возможность такой проверки часто делает enum лучше, чем #define. Кроме того, отладчик получает возможность печатать значения переменных типа enum в символьном виде.</p>
   </section>
   <section>
    <title>
     <p>2.4 Объявления</p>
    </title>
    <p>Все переменные должны быть объявлены раньше, чем будут использоваться, при этом некоторые объявления могут быть получены неявно - из контекста. Объявление специфицирует тип и содержит список из одной или нескольких переменных этого типа, как, например, в</p>
    <p><code>int lower, upper, step;</code></p>
    <p><code>char с, line[1000];</code></p>
    <p>Переменные можно распределять по объявлениям произвольным образом, так что указанные выше списки можно записать и в следующем виде:</p>
    <p><code>int lower;</code></p>
    <p><code>int upper;</code></p>
    <p><code>int step;</code></p>
    <p><code>char c;</code></p>
    <p><code>char line[1000];</code></p>
    <p>Последняя форма записи занимает больше места, тем не менее она лучше, поскольку позволяет добавлять к каждому объявлению комментарий. Кроме того, она более удобна для последующих модификаций.</p>
    <p>В своем объявлении переменная может быть инициализирована, как, например:</p>
    <p><code>char esc = '\\';</code></p>
    <p><code>int i = 0;</code></p>
    <p><code>int limit = MAXLINE+1;</code></p>
    <p><code>float eps = 1.0e-5;</code></p>
    <p>Инициализация неавтоматической переменной осуществляется только один раз - перед тем, как программа начнет выполняться, при этом начальное значение должно быть константным выражением. Явно инициализируемая автоматическая переменная получает начальное значение каждый раз при входе в функцию или блок, ее начальным значением может быть любое выражение. Внешние и статические переменные по умолчанию получают нулевые значения. Автоматические переменные, явным образом не инициализированные, содержат неопределенные значения ("мусор").</p>
    <p>К любой переменной в объявлении может быть применен квалификатор <strong>const</strong> для указания того, что ее значение далее не будет изменяться.</p>
    <p><code>const double е = 2.71828182845905;</code></p>
    <p><code>const char msg[] = "предупреждение: ";</code></p>
    <p>Применительно к массиву квалификатор <strong>const</strong> указывает на то, что ни один из его элементов не будет меняться. Указание <strong>const</strong> можно также применять к аргументу- массиву, чтобы сообщить, что функция не изменяет этот массив:</p>
    <p><code>int strlen(const char[]);</code></p>
    <p>Реакция на попытку изменить переменную, помеченную квалификатором <strong>const</strong> зависит от реализации компилятора.</p>
   </section>
   <section>
    <title>
     <p>2.5 Арифметические операторы</p>
    </title>
    <p>Бинарными (т. е. с двумя операндами) арифметическими операторами являются <strong>+</strong>, <strong>-</strong>, <strong>*</strong>, <strong>/</strong>, а также оператор деления по модулю <strong>%</strong>. Деление целых сопровождается отбрасыванием дробной части, какой бы она ни была. Выражение</p>
    <p><code>x % y</code></p>
    <p>дает остаток от деления x на y и, следовательно, нуль, если x делится на y нацело. Например, год является високосным, если он делится на 4, но не делится на 100. Кроме того, год является високосным, если он делится на 400. Следовательно,</p>
    <p><code>if ((year % 4 == 0 &amp;&amp; year % 100 !=0 || year % 400 == 0)</code></p>
    <p><code> printf("%d високосный год\n", year);</code></p>
    <p><code>else</code></p>
    <p><code> printf("%d невисокосный год\n", year);</code></p>
    <p>Оператор <strong>%</strong> к операндам типов <strong>float</strong> и <strong>double</strong> не применяется. В какую сторону (в сторону увеличения или уменьшения числа) будет усечена дробная часть при выполнении <strong>/</strong> и каким будет знак результата операции <strong>%</strong> с отрицательными операндами, зависит от машины.</p>
    <p>Бинарные операторы <strong>+</strong> и <strong>-</strong> имеют одинаковый приоритет, который ниже приоритета операторов <strong>*</strong>, <strong>/</strong> и <strong>%</strong>, который в свою очередь ниже приоритета унарных операторов <strong>+</strong> и <strong>-</strong>. Арифметические операции одного приоритетного уровня выполняются слева направо.</p>
    <p>В конце этой главы (параграф 2.12) приводится таблица 2.1,в которой представлены приоритеты всех операторов и очередность их выполнения.</p>
   </section>
   <section>
    <title>
     <p>2.6 Операторы отношения и логические операторы</p>
    </title>
    <p>Операторами отношения являются</p>
    <p><code>›</code></p>
    <p><code>›=</code></p>
    <p><code>‹</code></p>
    <p><code>‹=</code></p>
    <p>Все они имеют одинаковый приоритет. Сразу за ними идет приоритет операторов сравнения на равенство:</p>
    <p><code>== </code></p>
    <p><code>!=</code></p>
    <p>Операторы отношения имеют более низкий приоритет, чем арифметические, поэтому выражение вроде i ‹ lim-1 будет выполняться так же, как i ‹ (lim-1), т.е. как мы и ожидаем.</p>
    <p>Более интересны логические операторы &amp;<strong>&amp;</strong> и <strong>||</strong>. Выражения, между которыми стоят операторы &amp;&amp; или ||, вычисляются слева направо. Вычисление прекращается, как только становится известна истинность или ложность результата. Многие Си-программы опираются на это свойство, как, например, цикл из функции getline, которую мы приводили в главе 1:</p>
    <p><code>for (i = 0; i ‹ lim-1 &amp;&amp; (с = getchar()) != EOF &amp;&amp; с != '\n'; ++i)</code></p>
    <p><code> s[i] = c;</code></p>
    <p>Прежде чем читать очередной символ, нужно проверить, есть ли для него место в массиве s, иначе говоря, сначала необходимо проверить соблюдение условия i ‹ lim-1. Если это условие не выполняется, мы не должны продолжать вычисление, в частности читать следующий символ. Так же было бы неправильным сравнивать c и EOF до обращения к getchar; следовательно, и вызов getchar, и присваивание должны выполняться перед указанной проверкой.</p>
    <p>Приоритет оператора <strong>&amp;&amp;</strong> выше, чем таковой оператора <strong>||</strong>, однако их приоритеты ниже, чем приоритет операторов отношения и равенства. Из сказанного следует, что выражение вида</p>
    <p><code>i ‹ lim-1 &amp;&amp; (с = getchar()) != '\n' &amp;&amp; с != EOF</code></p>
    <p>не нуждается в дополнительных скобках. Но, так как приоритет <strong>!=</strong> выше, чем приоритет присваивания, в</p>
    <p><code>(с = getchar()) != '\n'</code></p>
    <p>скобки необходимы, чтобы сначала выполнить присваивание, а затем сравнение с '\n'.</p>
    <p>По определению численным результатом вычисления выражения отношения или логического выражения является 1, если оно истинно, и 0, если оно ложно.</p>
    <p>Унарный оператор <strong>!</strong> преобразует ненулевой операнд в 0, а нуль в 1. Обычно оператор <strong>!</strong> используют в конструкциях вида</p>
    <p><code>if (!valid)</code></p>
    <p>что эквивалентно</p>
    <p><code>if (valid == 0)</code></p>
    <p>Трудно сказать, какая из форм записи лучше. Конструкция вида !valid хорошо читается ("если не правильно"), но в более сложных выражениях может оказаться, что ее не так-то легко понять.</p>
    <p><strong>Упражнение 2.2</strong>. Напишите цикл, эквивалентный приведенному выше or-циклу, не пользуясь операторами &amp;&amp; и ||.</p>
   </section>
   <section>
    <title>
     <p>2.7 Преобразования типов</p>
    </title>
    <p>Если операнды оператора принадлежат к разным типам, то они приводятся к некоторому общему типу. Приведение выполняется в соответствии с небольшим числом правил. Обычно автоматически производятся лишь те преобразования, которые без какой-либо потери информации превращают операнды с меньшим диапазоном значений в операнды с большим диапазоном, как, например, преобразование целого в число с плавающей точкой в выражении вроде f+i. Выражения, не имеющие смысла, например число с плавающей точкой в роли индекса, не допускаются. Выражения, в которых могла бы теряться информация (скажем, при присваивании длинных целых переменным более коротких типов или при присваивании значений с плавающей точкой целым переменным), могут повлечь за собой предупреждение, но они допустимы.</p>
    <p>Значения типа <strong>char</strong> - это просто малые целые, и их можно свободно использовать в арифметических выражениях, что значительно облегчает всевозможные манипуляции с символами. В качестве примера приведем простенькую реализацию функции atoi, преобразующей последовательность цифр в ее числовой эквивалент.</p>
    <p><code>/* atoi: преобразование s в целое */</code></p>
    <p><code>int atoi(char s[])</code></p>
    <p><code>{</code></p>
    <p><code> int i, n;</code></p>
    <p><code> n = 0;</code></p>
    <p><code> for (i = 0; s[i] ›= '0' &amp;&amp; s[i] ‹= '9'; ++i)</code></p>
    <p><code>  n = 10 * n + (s[i] - '0');</code></p>
    <p><code> return n;</code></p>
    <p><code>}</code></p>
    <p>Как мы уже говорили в главе 1, выражение</p>
    <p><code>s[i] -'0'</code></p>
    <p>дает числовое значение символа, хранящегося в s[i], так как значения '0', '1' и пр. образуют непрерывную возрастающую последовательность.</p>
    <p>Другой пример приведения <strong>char</strong> к <strong>int</strong> связан с функцией lower, которая одиночный символ из набора ASCII, если он является заглавной буквой, превращает в строчную. Если же символ не является заглавной буквой, lower его не изменяет.</p>
    <p><code>/* lower: преобразование c в строчную, только для ASCII */</code></p>
    <p><code>int lower(int c)</code></p>
    <p><code>{</code></p>
    <p><code> if (c ›= 'A' &amp;&amp; c ‹='Z')</code></p>
    <p><code> return c +'a'-'A';</code></p>
    <p><code>else</code></p>
    <p><code> return c;</code></p>
    <p><code>}</code></p>
    <p>В случае ASCII эта программа будет работать правильно, потому что между одноименными буквами верхнего и нижнего регистров - одинаковое расстояние (если их рассматривать как числовые значения). Кроме того, латинский алфавит - плотный, т. е. между буквами A и Z расположены только буквы. Для набора EBCDIC последнее условие не выполняется, и поэтому наша программа в этом случае будет преобразовывать не только буквы.</p>
    <p>Стандартный заголовочный файл <strong>‹ctype.h›</strong>, описанный в приложении B, определяет семейство функций, которые позволяют проверять и преобразовывать символы независимо от символьного набора. Например, функция tolower(c) возвращает букву c в коде нижнего регистра, если она была в коде верхнего регистра, поэтому tolower - универсальная замена функции lower, рассмотренной выше. Аналогично проверку</p>
    <p><code>c ›= '0' &amp;&amp; c ‹= '9'</code></p>
    <p>можно заменить на isdigit(c)</p>
    <p>Далее мы будем пользоваться функциями из ‹ctype.h›.</p>
    <p>Существует одна тонкость, касающаяся преобразования символов в целые числа: язык не определяет, являются ли переменные типа <strong>char</strong> знаковыми или беззнаковыми. При преобразовании <strong>char</strong> в <strong>int</strong> может ли когда- нибудь получиться отрицательное целое? На машинах с разной архитектурой ответы могут отличаться. На некоторых машинах значение типа <strong>char</strong> с единичным старшим битом будет превращено в отрицательное целое (посредством "распространения знака"). На других - преобразование <strong>char</strong> в <strong>int</strong> осуществляется добавлением нулей слева, и, таким образом, получаемое значение всегда положительно.</p>
    <p>Гарантируется, что любой символ из стандартного набора печатаемых символов никогда не будет отрицательным числом, поэтому в выражениях такие символы всегда являются положительными операндами. Но произвольный восьмибитовый код в переменной типа <strong>char</strong> на одних машинах может быть отрицательным числом, а на других - положительным. Для совместимости переменные типа <strong>char</strong>, в которых хранятся несимвольные данные, следует специфицировать явно как <strong>signed</strong> или <strong>unsigned</strong>.</p>
    <p>Отношения вроде i › j и логические выражения, перемежаемые операторами <strong>amp;&amp;</strong> и <strong>||</strong>, определяют выражение-условие, которое имеет значение 1, если оно истинно, и 0, если ложно. Так, присваивание</p>
    <p><code>d = c ›= '0' &amp;&amp; c ‹= '9'</code></p>
    <p>установит d в значение 1, если c есть цифра, и 0 в противном случае. Однако функции, подобные isdigit, в качестве истины могут выдавать любое ненулевое значение. В местах проверок внутри if, while, for и пр. "истина" просто означает "не нуль".</p>
    <p>Неявные арифметические преобразования, как правило, осуществляются естественным образом. В общем случае, когда оператор вроде + или * с двумя операндами (бинарный оператор) имеет разнотипные операнды, прежде чем операция начнет выполняться, "низший" тип повышается до "высшего". Результат будет иметь высший тип. В параграфе 6 приложения A правила преобразования сформулированы точно. Если же в выражении нет беззнаковых операндов, можно удовлетвориться следующим набором неформальных правил:</p>
    <p>· Если какой-либо из операндов принадлежит типу <strong>long double</strong>, то и другой приводится к <strong>long double</strong>.</p>
    <p>· В противном случае, если какой-либо из операндов принадлежит типу <strong>double</strong>, то и другой приводится к <strong>double</strong>.</p>
    <p>· В противном случае, если какой-либо из операндов принадлежит типу <strong>float</strong>, то и другой приводится к <strong>float</strong>.</p>
    <p>· В противном случае операнды типов <strong>char</strong> и <strong>short</strong> приводятся к <strong>int</strong>.</p>
    <p>· И наконец, если один из операндов типа <strong>long</strong>, то и другой приводится к <strong>long</strong>.</p>
    <p>Заметим, что операнды типа <strong>float</strong> не приводятся автоматически к типу <strong>double</strong>; в этом данная версия языка отличается от первоначальной. Вообще говоря, математические функции, аналогичные собранным в библиотеке <strong>‹math.h›</strong>, базируются на вычислениях с двойной точностью. В основном <strong>float</strong> используется для экономии памяти на больших массивах и не так часто - для ускорения счета на тех машинах, где арифметика с двойной точностью слишком дорога с точки зрения расхода времени и памяти.</p>
    <p>Правила преобразования усложняются с появлением операндов типа <strong>unsigned</strong>. Проблема в том, что сравнения знаковых и беззнаковых значений зависят от размеров целочисленных типов, которые на разных машинах могут отличаться. Предположим, что значение типа <strong>int</strong> занимает 16 битов, а значение типа <strong>long</strong> - 32 бита. Тогда -1L ‹ 1U, поскольку 1U принадлежит типу <strong>unsigned int</strong> и повышается до типа <strong>signed long</strong>. Но -1L ›1UL, так как -1L повышается до типа <strong>unsigned long</strong> и воспринимается как большое положительное число.</p>
    <p>Преобразования имеют место и при присвоениях: значение правой части присвоения приводится к типу левой части, который и является типом результата.</p>
    <p>Тип <strong>char</strong> превращается в <strong>int</strong> путем распространения знака или другим описанным выше способом.</p>
    <p>Тип <strong>long int</strong> преобразуются в <strong>short int</strong> или в значения типа <strong>char</strong> путем отбрасывания старших разрядов. Так, в</p>
    <p><code>int i;</code></p>
    <p><code>char c;</code></p>
    <p><code>i = c;</code></p>
    <p><code>c = i;</code></p>
    <p>значение c не изменится. Это справедливо независимо от того, распространяется знак при переводе <strong>char</strong> в <strong>int</strong> или нет. Однако, если изменить очередность присваиваний, возможна потеря информации.</p>
    <p>Если x принадлежит типу <strong>float</strong>, а i - типу <strong>int</strong>, то и x=i, и i=z вызовут преобразования, причем перевод <strong>float</strong> в <strong>int</strong> сопровождается отбрасыванием дробной части. Если <strong>double</strong> переводится во <strong>float</strong>, то значение либо округляется, либо обрезается; это зависит от реализации.</p>
    <p>Так как аргумент в вызове функции есть выражение, при передаче его функции также возможно преобразование типа. При отсутствии прототипа (функции аргументы тина <strong>char</strong> и <strong>short</strong> переводятся в <strong>int</strong>, a <strong>float</strong> - в <strong>double</strong>. Вот почему мы объявляли аргументы типа <strong>int</strong> или <strong>double</strong> даже тогда, когда в вызове функции использовали аргументы типа <strong>char</strong> или <strong>float</strong>.</p>
    <p>И наконец, для любого выражения можно явно ("насильно") указать преобразование его типа, используя унарный оператор, называемый приведением. Конструкция вида</p>
    <p><code>(<emphasis>имя-типа</emphasis>) <emphasis>выражение</emphasis></code></p>
    <p>приводит выражение к указанному в скобках типу по перечисленным выше правилам. Смысл операции приведения можно представить себе так: выражение как бы присваивается некоторой переменной указанного типа, и эта переменная используется вместо всей конструкции. Например, библиотечная функция sqrt рассчитана на аргумент типа <strong>double</strong> и выдает чепуху, если ей подсунуть что-нибудь другое (sqrt описана в). Поэтому, если n имеет целочисленный тип, мы можем написать</p>
    <p><code>sqrt((double) n)</code></p>
    <p>и перед тем, как значение n будет передано функции, оно будет переведено в <strong>double</strong>. Заметим, что операция приведения всего лишь вырабатывает значение n указанного типа, но саму переменную n не затрагивает. Приоритет оператора приведения столь же высок, как и любого унарного оператора, что зафиксировано в таблице, помещенной в конце этой главы.</p>
    <p>В том случае, когда аргументы описаны в прототипе функции, как тому и следует быть, при вызове функции нужное преобразование выполняется автоматически. Так, при наличии прототипа функции sqrt:</p>
    <p><code>double sqrt(double);</code></p>
    <p>перед обращением к sqrt в присваивании</p>
    <p><code>root2 = sqrt(2);</code></p>
    <p>целое 2 будет переведено в значение <strong>double</strong> 2.0 автоматически без явного указания операции приведения.</p>
    <p>Операцию приведения проиллюстрируем на переносимой версии генератора псевдослучайных чисел и функции, инициализирующей "семя". И генератор, и функция входят в стандартную библиотеку.</p>
    <p><code>unsigned long int next = 1;</code></p>
    <p><code>/* rand: возвращает псевдослучайное целое 0…32767 */</code></p>
    <p><code>int rand(void)</code></p>
    <p><code>{</code></p>
    <p><code> next = next * 1103515245 + 12345;</code></p>
    <p><code> return (unsigned int)(next/65536) % 32768;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* srand: устанавливает "семя" для rand() */</code></p>
    <p><code>void srand(unsigned int seed)</code></p>
    <p><code>{</code></p>
    <p><code> next = seed;</code></p>
    <p><code>}</code></p>
    <p><strong>Упражнение 2.3</strong>. Напишите функцию htol(s), которая преобразует последовательность шестнадцатеричных цифр, начинающуюся с 0x или 0X, в соответствующее целое. Шестнадцатеричными цифрами являются символы 0…9, a…f, А…F.</p>
   </section>
   <section>
    <title>
     <p>2.8 Операторы инкремента и декремента</p>
    </title>
    <p>В Си есть два необычных оператора, предназначенных для увеличения и уменьшения переменных. Оператор инкремента <strong>++</strong> добавляет 1 к своему операнду, а оператор декремента <strong>--</strong> вычитает 1. Мы уже неоднократно использовали ++ для наращивания значения переменных, как, например, в</p>
    <p><code>if (c == '\n')</code></p>
    <p><code> ++nl;</code></p>
    <p>Необычность операторов ++ и -- в том, что их можно использовать и как префиксные (помещая перед переменной: ++n), и как постфиксные (помещая после переменной: n++) операторы. В обоих случаях значение n увеличивается на 1, но выражение ++n увеличивает n до того, как его значение будет использовано, а n++ - после того. Предположим, что n содержит 5, тогда</p>
    <p><code>x = n++;</code></p>
    <p>установит x в значение 5, а</p>
    <p><code>x = ++n;</code></p>
    <p>установит x в значение 6. И в том и другом случае n станет равным 6. Операторы инкремента и декремента можно применять только к переменным. Выражения вроде (i+j)++ недопустимы.</p>
    <p>Если требуется только увеличить или уменьшить значение переменной (но не получить ее значение), как например</p>
    <p><code>if (c=='\n')</code></p>
    <p><code> nl++;</code></p>
    <p>то безразлично, какой оператор выбрать - префиксный или постфиксный. Но существуют ситуации, когда требуется оператор вполне определенного типа. Например, рассмотрим функцию squeeze(s, c), которая удаляет из строки s все символы, совпадающие с c:</p>
    <p><code>/* squeeze: удаляет все c из s*/</code></p>
    <p><code>void squeeze(char s[], int с)</code></p>
    <p><code>{</code></p>
    <p><code> int i, j;</code></p>
    <p><code> for (i = j =0; s[i] != '\0'; i++)</code></p>
    <p><code> if (s[i] != c)</code></p>
    <p><code>  s[j++] = s[i];</code></p>
    <p><code> s[i] = '\0';</code></p>
    <p><code>}</code></p>
    <p>Каждый раз, когда встречается символ, отличный от c, он копируется в текущую j-ю позицию, и только после этого переменная j увеличивается на 1, подготавливаясь таким образом к приему следующего символа. Это в точности совпадает со следующими действиями:</p>
    <p><code>if (s[i] != с)</code></p>
    <p><code>{</code></p>
    <p><code> s[j] = s[i];</code></p>
    <p><code> j++;</code></p>
    <p><code>}</code></p>
    <p>Другой пример - функция getline, которая нам известна по главе 1. Приведенную там запись</p>
    <p><code>if (c =='\n') {</code></p>
    <p><code> s[i] = c;</code></p>
    <p><code> ++i;</code></p>
    <p><code>}</code></p>
    <p>можно переписать более компактно:</p>
    <p><code>if (с == '\n')</code></p>
    <p><code> s[i++] = с;</code></p>
    <p>В качестве третьего примера рассмотрим стандартную функцию strcat(s,t), которая строку t помещает в конец строки s. Предполагается, что в s достаточно места, чтобы разместить там суммарную строку. Мы написали strcat так, что она не возвращает никакого результата. На самом деле библиотечная strcat возвращает указатель на результирующую строку.</p>
    <p><code>/* strcat: помещает t в конец s; s достаточно велика */</code></p>
    <p><code>void strcat (char s[], char t[])</code></p>
    <p><code>{</code></p>
    <p><code> int i, j;</code></p>
    <p><code> i = j = 0;</code></p>
    <p><code> while (s[i] != '\0') /* находим конец s */</code></p>
    <p><code>  i++;</code></p>
    <p><code> while ((s[i++] = t[j++]) != '\0') /* копируем t */</code></p>
    <p><code> ;</code></p>
    <p><code>}</code></p>
    <p>При копировании очередного символа из t в s постфиксный оператор ++ применяется и к i, и к j, чтобы на каждом шаге цикла переменные i и j правильно отслеживали позиции перемещаемого символа.</p>
    <p><strong>Упражнение 2.4</strong>. Напишите версию функции squeeze(s1,s2), которая удаляет из s1 все символы, встречающиеся в строке s2.</p>
    <p><strong>Упражнение 2.5</strong>. Напишите функцию any(s1,s2), которая возвращает либо ту позицию в s1, где стоит первый символ, совпавший с любым из символов в s2, либо -1 (если ни один символ из s1 не совпадает с символами из s2). (Стандартная библиотечная функция strpbrk делает то же самое, но выдает не номер позиции символа, а указатель на символ.)</p>
   </section>
   <section>
    <title>
     <p>2.9 Побитовые операторы</p>
    </title>
    <p>В Си имеются шесть операторов для манипулирования с битами. Их можно применять только к целочисленным операндам, т. е. к операндам типов <strong>char</strong>, <strong>short</strong>, <strong>int</strong> и long, знаковым и беззнаковым.</p>
    <p><code>&amp; - побитовое И</code></p>
    <p><code>| - побитовое ИЛИ</code></p>
    <p><code>^ - побитовое исключающее ИЛИ.</code></p>
    <p><code>‹‹ - сдвиг влево.</code></p>
    <p><code>›› - сдвиг вправо.</code></p>
    <p><code>~ - побитовое отрицание (унарный).</code></p>
    <p>Оператор <strong>&amp;</strong> (побитовое И) часто используется для обнуления некоторой группы разрядов. Например</p>
    <p><code>n = n &amp; 0177;</code></p>
    <p>обнуляет в n все разряды, кроме младших семи.</p>
    <p>Оператор <strong>|</strong> (побитовое ИЛИ) применяют для установки разрядов; так,</p>
    <p><code>x = x | SET_ON;</code></p>
    <p>устанавливает единицы в тех разрядах x, которым соответствуют единицы в SET_ON.</p>
    <p>Оператор <strong>^</strong> (побитовое исключающее ИЛИ) в каждом разряде установит 1, если соответствующие разряды операндов имеют различные значения, и 0, когда они совпадают.</p>
    <p>Поразрядные операторы <strong>&amp;</strong> и <strong>|</strong> следует отличать от логических операторов <strong>&amp;&amp;</strong> и <strong>||</strong>, которые при вычислении слева направо дают значение истинности. Например, если x равно 1, а y равно 2, то x &amp; y даст нуль, а x &amp;&amp; y - единицу.</p>
    <p>Операторы <strong>‹‹</strong> и <strong>››</strong> сдвигают влево или вправо свой левый операнд на число битовых позиций, задаваемое правым операндом, который должен быть неотрицательным. Так, x ‹‹ 2 сдвигает значение x влево на 2 позиции, заполняя освобождающиеся биты нулями, что эквивалентно умножению x на 4. Сдвиг вправо беззнаковой величины всегда сопровождается заполнением освобождающихся разрядов нулями. Сдвиг вправо знаковой величины на одних машинах происходит с распространением знака ("арифметический сдвиг"), на других - с заполнением освобождающихся разрядов нулями ("логический сдвиг").</p>
    <p>Унарный оператор ~ поразрядно "обращает" целое т. е. превращает каждый единичный бит в нулевой и наоборот. Например</p>
    <p><code>x = x &amp; ~077</code></p>
    <p>обнуляет в x последние 6 разрядов. Заметим, что запись x &amp; ~077 не зависит от длины слова, и, следовательно, она лучше, чем x &amp; 0177700, поскольку последняя подразумевает, что x занимает 16 битов. Не зависимая от машины форма записи ~077 не потребует дополнительных затрат при счете, так как ~077 - константное выражение, которое будет вычислено во время компиляции.</p>
    <p>Для иллюстрации некоторых побитовых операций рассмотрим функцию getbits(x, p, n), которая формирует поле в n битов, вырезанных из x, начиная с позиции p, прижимая его к правому краю. Предполагается, что 0-й бит - крайний правый бит, а n и p - осмысленные положительные числа. Например, getbits(x,4,3) вернет в качестве результата 4, 3 и 2-й биты значения x, прижимая их к правому краю. Вот эта функция:</p>
    <p><code>/* getbits: получает n бит, начиная с p-й позиции */</code></p>
    <p><code>unsigned getbits(unsigned x, int p, int n)</code></p>
    <p><code>{</code></p>
    <p><code> return (x ›› (p+1-n)) &amp; ~(~0 ‹‹ n);</code></p>
    <p><code>}</code></p>
    <p>Выражение x ›› (р+1-n) сдвигает нужное нам поле к правому краю. Константа ~0 состоит из одних единиц, и ее сдвиг влево на n бит (~0 ‹‹ n) приведет к тому, что правый край этой константы займут n нулевых разрядов. Еще одна операция побитовой инверсии ~ позволяет получить справа n единиц.</p>
    <p><strong>Упражнение 2.6</strong>. Напишите функцию setbits(x, p, n, y), возвращающую значение x, в котором n битов, начиная с p-й позиции, заменены на n правых разрядов из y (остальные биты не изменяются).</p>
    <p><strong>Упражнение 2.7</strong>. Напишите функцию invert(x, p, n), возвращающую значение x с инвертированными n битами, начиная с позиции p (остальные биты не изменяются).</p>
    <p><strong>Упражнение 2.8</strong>. Напишите функцию rightrot (x, n), которая циклически сдвигает x вправо на n разрядов.</p>
   </section>
   <section>
    <title>
     <p>2.10 Операторы и выражения присваивания</p>
    </title>
    <p>Выражение</p>
    <p><code>i = i + 2;</code></p>
    <p>в котором стоящая слева переменная повторяется и справа, можно написать в сжатом виде:</p>
    <p><code>i += 2;</code></p>
    <p>Оператор <strong>+=</strong>, как и <strong>=</strong>, называется оператором присваивания.</p>
    <p>Большинству бинарных операторов (аналогичных + и имеющих левый и правый операнды) соответствуют операторы присваивания <strong>op=</strong>, где op - один из операторов</p>
    <p><code>+</code></p>
    <p><code>- </code></p>
    <p><code>*</code></p>
    <p><code>/</code></p>
    <p><code>%</code></p>
    <p><code>‹‹</code></p>
    <p><code>››</code></p>
    <p><code>&amp;</code></p>
    <p><code>^</code></p>
    <p><code>|</code></p>
    <p>Если <emphasis>выр<sub>1</sub></emphasis> и <emphasis>выр<sub>2</sub></emphasis> - выражения, то</p>
    <p><emphasis><code><emphasis>выр<sub>1</sub> op</emphasis>= <emphasis>выр<sub>2</sub></emphasis></code></emphasis></p>
    <p>Эквивалентно</p>
    <p><code>выр<sub>1</sub> = (выр<sub>1</sub>) op (выр<sub>2</sub>)</code></p>
    <p>с той лишь разницей, что выр<sub>1</sub> вычисляется только один раз. Обратите внимание на скобки вокруг выр<sub>2</sub>:</p>
    <p><code>x *= y + 1</code></p>
    <p>эквивалентно</p>
    <p><code>x = x * (y + 1)</code></p>
    <p>но не</p>
    <p><code>x=x*y+1</code></p>
    <p>В качестве примера приведем функцию bitcount, подсчитывающую число единичных битов в своем аргументе целочисленного типа.</p>
    <p><code>/* bitcount: подсчет единиц в х */</code></p>
    <p><code>int bitcount(unsigned х)</code></p>
    <p><code>{</code></p>
    <p><code> int b;</code></p>
    <p><code> for (b = 0; х != 0; x ››= 1)</code></p>
    <p><code>  if (x &amp; 01)</code></p>
    <p><code>   b++;</code></p>
    <p><code> return b;</code></p>
    <p><code>}</code></p>
    <p>Независимо от машины, на которой будет работать эта программа, объявление аргумента x как unsigned гарантирует, что при правом сдвиге освобождающиеся биты будут заполняться нулями, а не знаковым битом.</p>
    <p>Помимо краткости операторы присваивания обладают тем преимуществом, что они более соответствуют тому, как человек мыслит. Мы говорим "прибавить 2 к i" или "увеличить i на 2", а не "взять i, добавить 2 и затем вернуть результат в i", так что выражение i+=2 лучше, чем i=i+2. Кроме того, в сложных выражениях вроде</p>
    <p><code>yyval[yypv[p3+p4] + yypv[p1+p2]]+= 2</code></p>
    <p>благодаря оператору присваивания += запись становится более легкой для понимания, так как читателю при такой записи не потребуется старательно сравнивать два длинных выражения, совпадают ли они, или выяснять, почему они не совпадают. Следует иметь в виду и то, что подобные операторы присваивания могут помочь компилятору сгенерировать более эффективный код.</p>
    <p>Мы уже видели, что присваивание вырабатывает значение и может применяться внутри выражения: вот самый расхожий пример:</p>
    <p><code>while ((с = getchar()) != EOF)</code></p>
    <p>В выражениях встречаются и другие операторы присваивания (+=, -= и т. д.), хотя и реже. Типом и значением любого выражения присваивания являются тип и значение его левого операнда после завершения присваивания.</p>
    <p><strong>Упражнение 2.9</strong>. Применительно к числам, в представлении которых использован дополнительный код, выражение x &amp;= (x-1) уничтожает самую правую 1 в x. Объясните, почему. Используйте это наблюдение при написании более быстрого варианта функции bitcount.</p>
   </section>
   <section>
    <title>
     <p>2.11 Условные выражения</p>
    </title>
    <p>Инструкции</p>
    <p><code>if (a › b)</code></p>
    <p><code> z = a;</code></p>
    <p><code>else</code></p>
    <p><code> z = b;</code></p>
    <p>пересылают в z большее из двух значений a и b. Условное выражение, написанное с помощью тернарного (т. е. имеющего три операнда) оператора "?: ", представляет собой другой способ записи этой и подобных ей конструкций. В выражении</p>
    <p><code>выр<sub>1 </sub>? выр<sub>2 </sub>: выр<sub>3</sub></code></p>
    <p>первым вычисляется выражение выр<sub>1</sub>. Если его значение не нуль (истина), то вычисляется выражение выр<sub>2</sub>, и значение этого выражения становится значением всего условного выражения. В противном случае вычисляется выражение выр<sub>3</sub> и его значение становится значением условного выражения. Следует отметить, что из выражений выр<sub>2</sub> и выр<sub>3</sub> вычисляется только одно из них. Таким образом, чтобы установить в z большее из a и b, можно написать</p>
    <p><code>z = (a › b) ? a: b; /* z = max(a, b) */</code></p>
    <p>Следует заметить, что условное выражение и в самом деле является выражением, и его можно использовать в любом месте, где допускается выражение. Если выр<sub>2</sub> и выр<sub>3</sub> принадлежат разным типам, то тип результата определяется правилами преобразования, о которых шла речь в этой главе ранее. Например, если f имеет тип <strong>float</strong>, а n - тип <strong>int</strong>, то типом выражения</p>
    <p><code>(n › 0) ? f : n</code></p>
    <p>будет <strong>float</strong> вне зависимости от того, положительно значение n или нет.</p>
    <p>Заключать в скобки первое выражение в условном выражении не обязательно, так как приоритет <strong>?:</strong> очень низкий (более низкий приоритет имеет только присваивание), однако мы рекомендуем всегда это делать, поскольку благодаря обрамляющим скобкам условие в выражении лучше воспринимается.</p>
    <p>Условное выражение часто позволяет сократить программу. В качестве примера приведем цикл, обеспечивающий печать n элементов массива по 10 на каждой строке с одним пробелом между колонками; каждая строка цикла, включая последнюю, заканчивается символом новой строки:</p>
    <p><code>for (i = 0; i ‹ n; i++)</code></p>
    <p><code> printf("%6d %c", a[i], (i%10 == 9 || i == n-1) ? '\n' : ' ');</code></p>
    <p>Символ новой строки посылается после каждого десятого и после n-го элемента. За всеми другими элементами следует пробел. Эта программа выглядит довольно замысловато, зато она более компактна, чем эквивалентная программа с использованием if-else. Вот еще один хороший пример:</p>
    <p><code>printf("Вы имеете %d элемент%s: \n", n, (n%10 == 1 &amp;&amp; n%100 != 11)?</code></p>
    <p><code> " ": ((n%100 ‹ 10 || n%100 › 20) &amp;&amp; n%10 ›= 2 &amp;&amp; n%10 ‹= 4) ?</code></p>
    <p><code> "a": "ов");</code></p>
    <p><strong>Упражнение 2.10</strong>. Напишите функцию lower, которая переводит большие буквы в малые, используя условное выражение (а не конструкцию if-else).</p>
   </section>
   <section>
    <title>
     <p>2.12 Приоритет и очередность вычислений</p>
    </title>
    <p>В таблице 2.1 показаны приоритеты и очередность вычислений всех операторов, включая и те, которые мы еще не рассматривали. Операторы, перечисленные на одной строке, имеют одинаковый приоритет: строки упорядочены по убыванию приоритетов; так, например, *, / и % имеют одинаковый приоритет, который выше, чем приоритет бинарных + и -. "Оператор" () относится к вызову функции. Операторы -› и . (точка) обеспечивают доступ к элементам структур; о них пойдет речь в главе 6, там же будет рассмотрен и оператор sizeof (размер объекта). Операторы * (косвенное обращение по указателю) и &amp; (получение адреса объекта) обсуждаются в главе 5. Оператор "запятая" будет рассмотрен в главе 3.</p>
    <p><strong>Таблица 2.1. Приоритеты и очередность вычислений операторов</strong></p>
    <table>
     <tr align="left">
      <th align="left" valign="top">Операторы </th>
      <th align="left" valign="top">Выполняются </th>
     </tr>
     <tr align="left">
      <th align="left" valign="top">() [] -› . </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">! ~ ++ -- + - * &amp; (type) sizeof </th>
      <td align="left" valign="top">справа налево </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">* / % </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">+ - </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">‹‹ ›› </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">‹ ‹= › ›= </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">==  != </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">&amp; </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">^ </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">|</th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">&amp;&amp; </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">|| </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">?: </th>
      <td align="left" valign="top">справа налево </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">= += -= *= /= %= &amp;= ^= |= ‹‹= ››= </th>
      <td align="left" valign="top">справа налево </td>
     </tr>
     <tr align="left">
      <th align="left" valign="top">, </th>
      <td align="left" valign="top">слева направо </td>
     </tr>
    </table>
    <p>Примечание. Унарные операторы <strong>+</strong>, <strong>-</strong>, <strong>*</strong> и <strong>&amp;</strong> имеют более высокий приоритет, чем те же бинарные операторы.</p>
    <p>Заметим, что приоритеты побитовых операторов <strong>&amp;</strong>, <strong>^</strong> и <strong>|</strong> ниже, чем приоритет <strong>==</strong> и <strong>!=</strong>, из-за чего в побитовых проверках, таких как</p>
    <p><code>if ((x &amp; MASK) == 0)…</code></p>
    <p>чтобы получить правильный результат, приходится использовать скобки. Си подобно многим языкам не фиксирует очередность вычисления операндов оператора (за исключением <strong>&amp;&amp;</strong>, <strong>||</strong>, <strong>?:</strong> и <strong>,</strong>). Например, в инструкции вида</p>
    <p><code>x = f() + g();</code></p>
    <p>f может быть вычислена раньше g или наоборот. Из этого следует, что если одна из функций изменяет значение переменной, от которой зависит другая функция, то помещаемый в x результат может зависеть от очередности вычислений. Чтобы обеспечить нужную последовательность вычислений, промежуточные результаты можно запоминать во временных переменных.</p>
    <p>Очередность вычисления аргументов функции также не определена, поэтому на разных компиляторах</p>
    <p><code>printf("%d %d\n", ++n, power(2, n)); /* НЕВЕРНО*/</code></p>
    <p>может давать несовпадающие результаты. Результат вызова функции зависит от того, когда компилятор сгенерирует команды увеличения n - до или после обращения к power. Чтобы обезопасить себя от возможного побочного эффекта, достаточно написать</p>
    <p><code>++n;</code></p>
    <p><code>printf("%d %d\n", n, power(2, n));</code></p>
    <p>Обращения к функциям, вложенные присвоения, инкрементные и декрементные операторы дают "побочный эффект", проявляющийся в том, что при вычислении выражения значения некоторых переменных изменяются. В любом выражении с побочным эффектом может быть скрыта трудно просматриваемая зависимость результата выражения от очередности изменения значений переменных, входящих в выражение. В такой, например, типично неприятной ситуации</p>
    <p><code>a[i] = i++; /* I.B.: doubtful example */</code></p>
    <p>возникает вопрос: массив a индексируется старым или измененным значением i? Компиляторы могут по-разному генерировать программу, что проявится в интерпретации данной записи. Стандарт сознательно устроен так, что большинство подобных вопросов оставлено на усмотрение компиляторов, так как лучший порядок вычислений определяется архитектурой машины. Стандартом только гарантируется, что все побочные эффекты при вычислении аргументов проявятся перед входом в функцию. Правда, в примере с printf это нам не поможет.</p>
    <p>Мораль такова: писать программы, зависящие от очередности вычислений, - плохая практика, какой бы язык вы ни использовали. Естественно, надо знать, чего следует избегать, но если вы не знаете, как образуются побочные эффекты на разных машинах, то лучше и не рассчитывать выиграть на особенностях частной реализации.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Глава 3. Управление</p>
   </title>
   <section>
    <p>Порядок, в котором выполняются вычисления, определяется инструкциями управления. Мы уже встречались с наиболее распространенными управляющими конструкциями такого рода в предыдущих примерах; здесь мы завершим их список и более точно определим рассмотренные ранее.</p>
   </section>
   <section>
    <title>
     <p>3.1 Инструкции и блоки</p>
    </title>
    <p>Выражение, скажем <emphasis>x = 0</emphasis>, или <emphasis>i++</emphasis>, или <emphasis>printf(:)</emphasis>, становится <emphasis>инструкцией</emphasis>, если в конце его поставить точку с запятой, например:</p>
    <p><code>x = 0;</code></p>
    <p><code>i++;</code></p>
    <p><code>printf(…);</code></p>
    <p>В Си точка с запятой является заключающим символом инструкции, а не разделителем, как в языке Паскаль.</p>
    <p>Фигурные скобки <strong>{</strong> и <strong>}</strong> используются для объединения объявлений и инструкций в <emphasis>составную инструкцию</emphasis>, или <emphasis>блок</emphasis>, чтобы с точки зрения синтаксиса эта новая конструкция воспринималась как одна инструкция. Фигурные скобки, обрамляющие группу инструкций, образующих тело функции, - это один пример; второй пример - это скобки, объединяющие инструкции, помещенные после <strong>if</strong>, <strong>else</strong>, <strong>while</strong> или <strong>for</strong>. (Переменные могут быть объявлены внутри <emphasis>любого</emphasis> блока, об этом разговор пойдет в главе 4.) После правой закрывающей фигурной скобки в конце блока точка с запятой не ставится.</p>
   </section>
   <section>
    <title>
     <p>3.2 Конструкция if-else</p>
    </title>
    <p>Инструкция <strong>if-else</strong> используется для принятия решения. Формально ее синтаксисом является:</p>
    <p><code>if (<emphasis>выражение</emphasis>)</code></p>
    <p><code><emphasis> инструкция<sub>1</sub></emphasis></code></p>
    <p><code>else</code></p>
    <p><code><emphasis> инструкция<sub>2</sub></emphasis></code></p>
    <p>причем <strong>else</strong>-часть может и отсутствовать. Сначала вычисляется выражение, и, если оно истинно (т. е. отлично от нуля), выполняется <emphasis>инструкция<sub>1</sub></emphasis>. Если выражение ложно (т. е. его значение равно нулю) и существует <strong>else</strong>-часть, то выполняется <emphasis>инструкция<sub>2</sub></emphasis>.</p>
    <p>Так как <strong>if</strong> просто проверяет числовое значение выражения, условие иногда можно записывать в сокращенном виде. Так, запись</p>
    <p><code>if (<emphasis>выражение</emphasis>)</code></p>
    <p>короче, чем</p>
    <p><code>if (<emphasis>выражение != 0 </emphasis>)</code></p>
    <p>Иногда такие сокращения естественны и ясны, в других случаях, наоборот, затрудняют понимание программы.</p>
    <p>Отсутствие <strong>else</strong>-части в одной из вложенных друг в друга <strong>if</strong>-конструкций может привести к неоднозначному толкованию записи. Эту неоднозначность разрешают тем, что <strong>else</strong> связывают с ближайшим <strong>if</strong>, у которого нет своего <strong>else</strong>. Например, в</p>
    <p><code>if (n › 0)</code></p>
    <p><code> if (а › b)</code></p>
    <p><code>  z = a;</code></p>
    <p><code> else</code></p>
    <p><code>  z = b;</code></p>
    <p><strong>else</strong> относится к внутреннему <strong>if</strong>, что мы и показали с помощью отступов. Если нам требуется иная интерпретация, необходимо должным образом расставить фигурные скобки:</p>
    <p><code>if (n › 0) {</code></p>
    <p><code> if (а › b)</code></p>
    <p><code>  z = a;</code></p>
    <p><code>}</code></p>
    <p><code>else</code></p>
    <p><code> z = b;</code></p>
    <p>Ниже приводится пример ситуации, когда неоднозначность особенно опасна:</p>
    <p><code>if (n ›= 0)</code></p>
    <p><code> for (i=0; i ‹ n; i++)</code></p>
    <p><code>  if (s[i] › 0) {</code></p>
    <p><code>   printf(":");</code></p>
    <p><code>   return i;</code></p>
    <p><code>  }</code></p>
    <p><code>else /* НЕВЕРНО */</code></p>
    <p><code> printf("ошибка - отрицательное n\n");</code></p>
    <p>С помощью отступов мы недвусмысленно показали, что нам нужно, однако компилятор не воспримет эту информацию и отнесет <strong>else</strong> к внутреннему <strong>if</strong>. Искать такого рода ошибки особенно тяжело. Здесь уместен следующий совет: вложенные <strong>if</strong> обрамляйте фигурными скобками. Кстати, обратите внимание на точку с запятой после z = a в</p>
    <p><code>if (а › b)</code></p>
    <p><code> z = а;</code></p>
    <p><code>else</code></p>
    <p><code> z = b;</code></p>
    <p>Здесь она обязательна, поскольку по правилам грамматики за <strong>if</strong> должна следовать инструкция, а выражение-инструкция вроде z = a; всегда заканчивается точкой с запятой.</p>
   </section>
   <section>
    <title>
     <p>3.3 Конструкция else-if</p>
    </title>
    <p>Конструкция</p>
    <p><code>if (<emphasis>выражение</emphasis>)</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p><code>else if (<emphasis>выражение</emphasis>)</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p><code>else if (<emphasis>выражение</emphasis>)</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p><code>else if (<emphasis>выражение</emphasis>)</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p><code>else</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p>встречается так часто, что о ней стоит поговорить особо. Приведенная последовательность инструкций <strong>if</strong> - самый общий способ описания многоступенчатого принятия решения. Выражения вычисляются по порядку; как только встречается <emphasis>выражение</emphasis> со значением "истина", выполняется соответствующая ему <emphasis>инструкция</emphasis>, на этом последовательность проверок завершается. Здесь под словом <emphasis>инструкция</emphasis> имеется в виду либо одна инструкция, либо группа инструкций в фигурных скобках.</p>
    <p>Последняя <strong>else</strong>-часть срабатывает, если не выполняются все предыдущие условия. Иногда в последней части не требуется производить никаких действий, в этом случае фрагмент</p>
    <p><code>else</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p>можно опустить или использовать для фиксации ошибочной ("невозможной") ситуации.</p>
    <p>В качестве иллюстрации трехпутевого ветвления рассмотрим функцию бинарного поиска значения x в массиве v. Предполагается, что элементы v упорядочены по возрастанию. Функция выдает положение x в v (число в пределах от 0 до n-1), если x там встречается, и -1, если его нет.</p>
    <p>При бинарном поиске значение x сначала сравнивается с элементом, занимающим серединное положение в массиве v. Если x меньше, чем это значение, то областью поиска становится "верхняя" половина массива v, в противном случае - "нижняя". В любом случае следующий шаг - это сравнение с серединным элементом отобранной половины. Процесс "уполовинивания" диапазона продолжается до тех пор, пока либо не будет найдено значение, либо не станет пустым диапазон поиска. Запишем функцию бинарного поиска:</p>
    <p><code>/* binsearch: найти x в v[0] ‹= v[1] ‹=… ‹= v[n-1] */</code></p>
    <p><code>int binsearch(int х, int v[], int n)</code></p>
    <p><code>{</code></p>
    <p><code> int low, high, mid;</code></p>
    <empty-line/>
    <p><code> low = 0;</code></p>
    <p><code> high = n-1;</code></p>
    <p><code> while (low ‹=high) {</code></p>
    <p><code>  mid = (low + high) / 2;</code></p>
    <p><code>  if (х ‹ v[mid])</code></p>
    <p><code>   high = mid - 1;</code></p>
    <p><code>  else if (х › v[mid])</code></p>
    <p><code>   low = mid+1;</code></p>
    <p><code>  else /* совпадение найдено */</code></p>
    <p><code>   return mid;</code></p>
    <p><code> }</code></p>
    <p><code> return -1; /* совпадения нет */</code></p>
    <p><code>}</code></p>
    <p>Основное действие, выполняемое на каждой шаге поиска, - сравнение значения x (меньше, больше или равно) с элементом v[mid]; это сравнение естественно поручить конструкции <strong>else-if</strong>.</p>
    <p><strong>Упражнение 3.1</strong>. В нашей программе бинарного поиска внутри цикла осуществляются две проверки, хотя могла быть только одна (при увеличении числа проверок вне цикла). Напишите программу, предусмотрев в ней одну проверку внутри цикла. Оцените разницу во времени выполнения.</p>
   </section>
   <section>
    <title>
     <p>3.4 Переключатель switch</p>
    </title>
    <p>Инструкция <strong>switch</strong> используется для выбора одного из многих путей. Она проверяет, совпадает ли значение выражения с одним из значений, входящих в некоторое множество целых констант, и выполняет соответствующую этому значению ветвь программы:</p>
    <p><code>switch (<emphasis>выражение</emphasis>) {</code></p>
    <p><code>case <emphasis>конст-выр</emphasis>: <emphasis>инструкции</emphasis></code></p>
    <p><code>case <emphasis>конст-выр</emphasis>: <emphasis>инструкции</emphasis></code></p>
    <p><code>default: <emphasis>инструкции</emphasis></code></p>
    <p><code>}</code></p>
    <p>Каждая ветвь <strong>case</strong> помечена одной или несколькими целочисленными константами или же константными выражениями. Вычисления начинаются с той ветви <strong>case</strong>, в которой константа совпадает со значением выражения. Константы всех ветвей <strong>case</strong> должны отличаться друг от друга. Если выяснилось, что ни одна из констант не подходит, то выполняется ветвь, помеченная словом <strong>default</strong>, если таковая имеется, в противном случае ничего не делается. Ветви <strong>case</strong> и <strong>default</strong> можно располагать в любом порядке.</p>
    <p>В главе 1 мы написали программу, подсчитывающую число вхождений в текст каждой цифры, символов-разделителей (пробелов, табуляций и новых строк) и всех остальных символов. В ней мы использовали последовательность <emphasis>if…else if…else</emphasis>. Теперь приведем вариант этой программы с переключателем <strong>switch</strong>:</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>main() /* подсчет цифр, символов-разделителей и прочих символов */</code></p>
    <p><code>{</code></p>
    <p><code> int c, i, nwhite, nother, ndigit[10];</code></p>
    <p><code> nwhite = nother = 0;</code></p>
    <p><code> for (i = 0; i ‹ 10; i++)</code></p>
    <p><code>  ndigit[i] = 0;</code></p>
    <p><code> while ((с = getchar()) != EOF) {</code></p>
    <p><code>  switch (c) {</code></p>
    <p><code>  case '0': case '1': case '2': case '3': case '4':</code></p>
    <p><code>  case '5': case '6': case '7': case '8': case '9':</code></p>
    <p><code>   ndigit[c - '0']++;</code></p>
    <p><code>   break;</code></p>
    <p><code>  case ' ':</code></p>
    <p><code>  case '\n':</code></p>
    <p><code>  case '\t':</code></p>
    <p><code>   nwhite++;</code></p>
    <p><code>   break;</code></p>
    <p><code>  default:</code></p>
    <p><code>   nother++;</code></p>
    <p><code>   break;</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> printf("цифр =");</code></p>
    <p><code> for(i = 0; i ‹ 10; i++)</code></p>
    <p><code>  printf (" %d", ndigit[i]);</code></p>
    <p><code> printf(", символов-разделителей = %d, прочих = %d\n",</code></p>
    <p><code>  nwhite, nother);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Инструкция <strong>break</strong> вызывает немедленный выход из переключателя <strong>switch</strong>. Поскольку выбор ветви <strong>case</strong> реализуется как переход на метку, то после выполнения одной ветви <strong>case</strong>, если ничего не предпринять, программа провалится вниз на следующую ветвь. Инструкции <strong>break</strong> и <strong>return</strong> - наиболее распространенные средства выхода из переключателя. Инструкция <strong>break</strong> используется также для принудительного выхода из циклов <strong>while</strong>, <strong>for</strong> и <strong>do-while</strong> (мы еще поговорим об этом чуть позже).</p>
    <p>"Сквозное" выполнение ветвей <strong>case</strong> вызывает смешанные чувства. С одной стороны, это хорошо, поскольку позволяет несколько ветвей <strong>case</strong> объединить в одну, как мы и поступили с цифрами в нашем примере. Но с другой - это означает, что в конце почти каждой ветви придется ставить <strong>break</strong>, чтобы избежать перехода к следующей. Последовательный проход по ветвям - вещь ненадежная, это чревато ошибками, особенно при изменении программы. За исключением случая с несколькими метками для одного вычисления, старайтесь по возможности реже пользоваться сквозным проходом, но если уж вы его применяете, обязательно комментируйте эти особые места.</p>
    <p>Добрый вам совет: даже в конце последней ветви (после <strong>default</strong> в нашем примере) помещайте инструкцию <strong>break</strong>, хотя с точки зрения логики в ней нет никакой необходимости. Но эта маленькая предосторожность спасет вас, когда однажды вам потребуется добавить в конец еще одну ветвь <strong>case</strong>.</p>
    <p><strong>Упражнение 3.2</strong>. Напишите функцию escape (s,t), которая при копировании текста из t в s преобразует такие символы, как <emphasis>новая строка</emphasis> и <emphasis>табуляция</emphasis> в "видимые последовательности символов" (вроде \n и \t). Используйте инструкцию <strong>switch</strong>. Напишите функцию, выполняющую обратное преобразование эскейп- последовательностей в настоящие символы.</p>
   </section>
   <section>
    <title>
     <p>3.5 Циклы while и for</p>
    </title>
    <p>Мы уже встречались с циклами <strong>while</strong> и <strong>for</strong>. В цикле</p>
    <p><code>while (<emphasis>выражение</emphasis>)</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p>вычисляется <emphasis>выражение</emphasis>. Если его значение отлично от нуля, то выполняется <emphasis>инструкция</emphasis>, и вычисление выражения повторяется. Этот цикл продолжается до тех пор, пока выражение не станет равным нулю, после чего вычисления продолжатся с точки, расположенной сразу за <emphasis>инструкцией</emphasis>.</p>
    <p>Инструкция <strong>for</strong></p>
    <p><code>for (<emphasis>выр<sub>1</sub></emphasis>; <emphasis>выр<sub>2</sub></emphasis>; <emphasis>выр<sub>3</sub></emphasis>)</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p>эквивалентна конструкции</p>
    <p><code><emphasis>выр<sub>1</sub></emphasis>;</code></p>
    <p><code>while (<emphasis>выр<sub>2</sub></emphasis>) {</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p><code><emphasis> выр<sub>3</sub></emphasis>;</code></p>
    <p><code>}</code></p>
    <p>если не считать отличий в поведении инструкции <strong>continue</strong>, речь о которой пойдет в параграфе 3.7.</p>
    <p>С точки зрения грамматики три компоненты цикла <strong>for</strong> представляют собой произвольные выражения, но чаще <emphasis>выр<sub>1</sub></emphasis> и <emphasis>выр<sub>3</sub></emphasis> - это присваивания или вызовы функций, а <emphasis>выр<sub>2</sub></emphasis> - выражение отношения. Любое из этих трех выражений может отсутствовать, но точку с запятой опускать нельзя. При отсутствии <emphasis>выр<sub>1</sub></emphasis>, или <emphasis>выр<sub>3</sub></emphasis> считается, что их просто нет в конструкции цикла; при отсутствии <emphasis>выр<sub>2</sub></emphasis>, предполагается, что его значение как бы всегда истинно. Например,</p>
    <p><code>for (;;) {</code></p>
    <p><code> :</code></p>
    <p><code>}</code></p>
    <p>есть "бесконечный" цикл, выполнение которого, вероятно, прерывается каким-то другим способом, например с помощью инструкций <strong>break</strong> или return. Какой цикл выбрать: <strong>while</strong> или <strong>for</strong> - это дело вкуса. Так, в</p>
    <p><code>while ((c = getchar()) == ' ' || c == '\n' || c == '\t')</code></p>
    <p><code> ; /* обойти символы-разделители */</code></p>
    <p>нет ни инициализации, ни пересчета параметра, поэтому здесь больше подходит <strong>while</strong>.</p>
    <p>Там, где есть простая инициализация и пошаговое увеличение значения некоторой переменной, больше подходит цикл <strong>for</strong>, так как в этом цикле организующая его часть сосредоточена в начале записи. Например, начало цикла, обрабатывающего первые n элементов массива, имеет следующий вид:</p>
    <p><code>for (i = 0; i ‹ n; i++)</code></p>
    <p><code> …</code></p>
    <p>Это похоже на <strong>DO</strong>-циклы в Фортране и <strong>for</strong>-циклы в Паскале. Сходство, однако, не вполне точное, так как в Си индекс и его предельное значение могут изменяться внутри цикла, и значение индекса i после выхода из цикла всегда определено. Поскольку три компонента цикла могут быть произвольными выражениями, организация <strong>for</strong>-циклов не ограничивается только случаем арифметической прогрессии. Однако включать в заголовок цикла вычисления, не имеющие отношения к инициализации и инкрементированию, считается плохим стилем. Заголовок лучше оставить только для операций управления циклом.</p>
    <p>В качестве более внушительного примера приведем другую версию программы <emphasis>atoi</emphasis>, выполняющей преобразование строки в ее числовой эквивалент. Это более общая версия по сравнению с рассмотренной в главе 2, в том смысле, что она игнорирует левые символы-разделители (если они есть) и должным образом реагирует на знаки + и -, которые могут стоять перед цифрами. (В главе 4 будет рассмотрен вариант <emphasis>atof</emphasis>, который осуществляет подобное преобразование для чисел с плавающей точкой.)</p>
    <p>Структура программы отражает вид вводимой информации:</p>
    <p><code><emphasis>игнорировать символы-разделители, если они есть</emphasis></code></p>
    <p><code><emphasis>получить знак, если он есть</emphasis></code></p>
    <p><code><emphasis>взять целую часть и преобразовать ее</emphasis></code></p>
    <p>На каждом шаге выполняется определенная часть работы и четко фиксируется ее результат, который затем используется на следующем шаге. Обработка данных заканчивается на первом же символе, который не может быть частью числа.</p>
    <p><code>#include ‹ctype.h›</code></p>
    <p><code>/* atoi: преобразование s в целое число; версия 2 */</code></p>
    <p><code>int atoi(char s[])</code></p>
    <p><code>{</code></p>
    <p><code> int i, n, sign;</code></p>
    <p><code> /* игнорировать символы-разделители */</code></p>
    <p><code> for (i = 0; isspace(s[i]); i++)</code></p>
    <p><code>  ;</code></p>
    <p><code> sign = (s[i] == '-') ? -1 : 1;</code></p>
    <p><code> if (s[i] == '+' || s[i] == '-') /* пропуск знака */</code></p>
    <p><code>  i++;</code></p>
    <p><code> for (n = 0; isdigit(s[i]); i++)</code></p>
    <p><code> n = 10 * n + (s[i] - '0');</code></p>
    <p><code> return sign * n;</code></p>
    <p><code>}</code></p>
    <p>Заметим, что в стандартной библиотеке имеется более совершенная функция преобразования строки в длинное целое (long int) - функция <strong>strtol</strong> (см. параграф 5 приложения B).</p>
    <p>Преимущества, которые дает централизация управления циклом, становятся еще более очевидными, когда несколько циклов вложены друг в друга. Проиллюстрируем их на примере сортировки массива целых чисел методом Шелла, предложенным им в 1959 г. Основная идея этого алгоритма в том, что на ранних стадиях сравниваются далеко отстоящие друг от друга, а не соседние элементы, как в обычных перестановочных сортировках. Это приводит к быстрому устранению массовой неупорядоченности, благодаря чему на более поздней стадии остается меньше работы. Интервал между сравниваемыми элементами постепенно уменьшается до единицы, и в этот момент сортировка сводится к обычным перестановкам соседних элементов. Программа shellsort имеет следующий вид:</p>
    <p><code>/* shellsort: сортируются v[0]… v[n-1] в возрастающем порядке */</code></p>
    <p><code>void shellsort (int v[], int n)</code></p>
    <p><code>{</code></p>
    <p><code> int gap, i, j, temp;</code></p>
    <p><code> for (gap = n/2; gap › 0; gap /= 2)</code></p>
    <p><code>  for (i = gap; i ‹ n; i++)</code></p>
    <p><code>   for (j = i - gap; j ›= 0 &amp;&amp; v[j] › v[j+gap]; j -= gap) {</code></p>
    <p><code>    temp = v[j];</code></p>
    <p><code>    v[j] = v[j + gap];</code></p>
    <p><code>    v[j + gap] = temp;</code></p>
    <p><code>   }</code></p>
    <p><code>}</code></p>
    <p>Здесь использованы три вложенных друг в друга цикла. Внешний управляет интервалом gap между сравниваемыми элементами, сокращая его путем деления пополам от n/2 до нуля. Средний цикл перебирает элементы. Внутренний - сравнивает каждую пару элементов, отстоящих друг от друга на расстоянии gap, и переставляет элементы в неупорядоченных парах. Так как gap обязательно сведется к единице, все элементы в конечном счете будут упорядочены. Обратите внимание на то, что универсальность цикла <strong>for</strong> позволяет сделать внешний цикл по форме похожим на другие, хотя он и не является арифметической прогрессией.</p>
    <p>Последний оператор Си - это "<strong>,</strong>" (запятая), которую чаще всего используют в инструкции <strong>for</strong>. Пара выражений, разделенных запятой, вычисляется слева направо. Типом и значением результата являются тип и значение правого выражения, что позволяет в инструкции <strong>for</strong> в каждой из трех компонент иметь по несколько выражений, например вести два индекса параллельно. Продемонстрируем это на примере функции reverse(s), которая "переворачивает" строку s, оставляя результат в той же строке s:</p>
    <p><code>#include ‹string.h›</code></p>
    <p><code>/* reverse: переворачивает строку s (результат в s) */</code></p>
    <p><code>void reverse(char s[])</code></p>
    <p><code>{</code></p>
    <p><code> int с, i, j;</code></p>
    <p><code> for (i = 0, j = strlen(s)-1; i ‹ j; i++, j--) {</code></p>
    <p><code>  с = s[i];</code></p>
    <p><code>  s[i] = s[j];</code></p>
    <p><code>  s[j] = c;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>Запятые, разделяющие аргументы функции, переменные в объявлениях и пр. не являются операторами-запятыми и не обеспечивают вычислений слева направо.</p>
    <p>Запятыми как операторами следует пользоваться умеренно. Более всего они уместны в конструкциях, которые тесно связаны друг с другом (как в <strong>for</strong>-цикле программы reverse), а также в макросах, в которых многоступенчатые вычисления должны быть выражены одним выражением. Запятой-оператором в программе reverse можно было бы воспользоваться и при обмене символами в проверяемых парах элементов строки, мысля этот обмен как одну отдельную операцию:</p>
    <p><code>for (i = 0, j = strlen(s)-1; i ‹ j; i++, j--)</code></p>
    <p><code> с = s[i], s[i] = s[j], s[j] = c;</code></p>
    <p><strong>Упражнение 3.3</strong>. Напишите функцию expand(s1,s2), заменяющую сокращенную запись наподобие a-z в строке s1 эквивалентной полной записью аbс…хуz в s2. В s1 допускаются буквы (прописные и строчные) и цифры. Следует уметь справляться с такими случаями, как a-b-c, a-z0-9 и -a-b. Считайте знак - в начале или в конце s1 обычным символом минус.</p>
   </section>
   <section>
    <title>
     <p>3.6 Цикл do-while</p>
    </title>
    <p>Как мы говорили в главе 1, в циклах <strong>while</strong> и <strong>for</strong> проверка условия окончания цикла выполняется наверху. В Си имеется еще один вид цикла, <strong>do-while</strong>, в котором эта проверка в отличие от <strong>while</strong> и <strong>for</strong> делается внизу после каждого прохождения тела цикла, т. е. после того, как тело выполнится хотя бы один раз. Цикл <strong>do-while</strong> имеет следующий синтаксис:</p>
    <p><code>do</code></p>
    <p><code><emphasis> инструкция</emphasis></code></p>
    <p><code>while (<emphasis>выражение</emphasis>);</code></p>
    <p>Сначала выполняется <emphasis>инструкция</emphasis>, затем вычисляется <emphasis>выражение</emphasis>. Если оно истинно, то <emphasis>инструкция</emphasis> выполняется снова и т. д. Когда выражение становится ложным, цикл заканчивает работу. Цикл <strong>do-while</strong> эквивалентен циклу <strong>repeat-until</strong> в Паскале с той лишь разницей, что в первом случае указывается условие продолжения цикла, а во втором - условие его окончания.</p>
    <p>Опыт показывает, что цикл <strong>do-while</strong> используется гораздо реже, чем <strong>while</strong> и <strong>for</strong>. Тем не менее потребность в нем время от времени возникает, как, например, в функции <emphasis>itoa</emphasis> (обратной по отношению к <emphasis>atoi</emphasis>), преобразующей число в строку символов. Выполнить такое преобразование оказалось несколько более сложным делом, чем ожидалось, поскольку простые алгоритмы генерируют цифры в обратном порядке. Мы остановились на варианте, в котором сначала формируется обратная последовательность цифр, а затем она реверсируется.</p>
    <p><code>/* itoa: преобразование n в строку s */</code></p>
    <p><code>void itoa(int n, char s[])</code></p>
    <p><code>{</code></p>
    <p><code> int i, sign;</code></p>
    <p><code> if ((sign = n) ‹ 0) /* сохраняем знак */</code></p>
    <p><code>  n =-n; /* делаем n положительным */</code></p>
    <p><code> i = 0;</code></p>
    <p><code> do {/* генерируем цифры в обратном порядке */</code></p>
    <p><code>  s[i++] = n %10 + '0'; /* следующая цифра */</code></p>
    <p><code> } while ((n /= 10) › 0); /* исключить ее */</code></p>
    <p><code> if (sign ‹ 0)</code></p>
    <p><code>  s[i++] = '-';</code></p>
    <p><code> s[i] = '\0';</code></p>
    <p><code> reverse(s);</code></p>
    <p><code>}</code></p>
    <p>Конструкция <strong>do-while</strong> здесь необходима или по крайней мере удобна, поскольку в s посылается хотя бы один символ, даже если n равно нулю. В теле цикла одну инструкцию мы выделили фигурными скобками (хотя они и избыточны), чтобы неискушенный читатель не принял по ошибке слово <strong>while</strong> за начало цикла <strong>while</strong>.</p>
    <p><strong>Упражнение 3.4</strong>. При условии, что для представления чисел используется дополнительный код, наша версия <emphasis>itoa</emphasis> не справляется с самым большим по модулю отрицательным числом, значение которого равняется -(2<sup>n-1</sup>), где n - размер слова. Объясните, чем это вызвано. Модифицируйте программу таким образом, чтобы она давала правильное значение указанного числа независимо от машины, на которой выполняется.</p>
    <p><strong>Упражнение 3.5</strong>. Напишите функцию itob(n,s,b), которая переводит целое n в строку s, представляющую число по основанию b. В частности, itob(n, s, 16) помещает в s текст числа n в шестнадцатеричном виде.</p>
    <p><strong>Упражнение 3.6</strong>. Напишите версию itoa с дополнительным третьим аргументом, задающим минимальную ширину поля. При необходимости преобразованное число должно слева дополняться пробелами.</p>
   </section>
   <section>
    <title>
     <p>3.7 Инструкции break и continue</p>
    </title>
    <p>Иногда бывает удобно выйти из цикла не по результату проверки, осуществляемой в начале или в конце цикла, а каким-то другим способом. Такую возможность для циклов <strong>for</strong>, <strong>while</strong> и <strong>do-while</strong>, а также для переключателя <strong>switch</strong> предоставляет инструкция <strong>break</strong>. Эта инструкция вызывает немедленный выход из самого внутреннего из объемлющих ее циклов или переключателей.</p>
    <p>Следующая функция, <emphasis>trim</emphasis>, удаляет из строки завершающие пробелы, табуляции, символы новой строки; <strong>break</strong> используется в ней для выхода из цикла по первому обнаруженному справа символу, отличному от названных.</p>
    <p><code>/* trim: удаляет завершающие пробелы, табуляции и новые строки */</code></p>
    <p><code>int trim(char s[])</code></p>
    <p><code>{</code></p>
    <p><code> int n;</code></p>
    <p><code> for (n = strlen(s)-1; n ›= 0, n--)</code></p>
    <p><code>  if (s[n]!= ' '&amp;&amp; s[n]!= '\t'&amp;&amp; s[n]!= '\n')</code></p>
    <p><code>   break;</code></p>
    <p><code> s[n+1] = '\0';</code></p>
    <p><code> return n;</code></p>
    <p><code>}</code></p>
    <p>С помощью функции <emphasis>strlen</emphasis> можно получить длину строки. Цикл <strong>for</strong> просматривает его в обратном порядке, начиная с конца, до тех пор, пока не встретится символ, отличный от пробела, табуляции и новой строки. Цикл прерывается, как только такой символ обнаружится или n станет отрицательным (т. е. вся строка будет просмотрена). Убедитесь, что функция ведет себя правильно и в случаях, когда строка пуста или состоит только из символов-разделителей.</p>
    <p>Инструкция <strong>continue</strong> в чем-то похожа на <strong>break</strong>, но применяется гораздо реже. Она вынуждает ближайший объемлющий ее цикл (<strong>for</strong>, <strong>while</strong> или <strong>do-while</strong>) начать следующий шаг итерации. Для <strong>while</strong> и <strong>do-while</strong> это означает немедленный переход к проверке условия, а для <strong>for</strong> - к приращению шага. Инструкцию <strong>continue</strong> можно применять только к циклам, но не к <strong>switch</strong>. Внутри переключателя <strong>switch</strong>, расположенного в цикле, она вызовет переход к следующей итерации этого цикла.</p>
    <p>Вот фрагмент программы, обрабатывающий только неотрицательные элементы массива a (отрицательные пропускаются).</p>
    <p><code>for (i = 0; i ‹ n; i++) {</code></p>
    <p><code> if (a[i] ‹ 0) /* пропуск отрицательных элементов */</code></p>
    <p><code>  continue;</code></p>
    <p><code> … /* обработка положительных элементов */</code></p>
    <p><code>}</code></p>
    <p>К инструкции <strong>continue</strong> часто прибегают тогда, когда оставшаяся часть цикла сложна, а замена условия в нем на противоположное и введение еще одного уровня приводят к слишком большому числу уровней вложенности.</p>
   </section>
   <section>
    <title>
     <p>3.8 Инструкция goto и метки</p>
    </title>
    <p>В Си имеются порицаемая многими инструкция <strong>goto</strong> и метки для перехода на них. Строго говоря, в этой инструкции нет никакой необходимости, и на практике почти всегда легко без нее обойтись. До сих пор в нашей книге мы не использовали <strong>goto</strong>.</p>
    <p>Однако существуют случаи, в которых <strong>goto</strong> может пригодиться. Наиболее типична ситуация, когда нужно прервать обработку в некоторой глубоко вложенной структуре и выйти сразу из двух или большего числа вложенных циклов. Инструкция <strong>break</strong> здесь не поможет, так как она обеспечит выход только из самого внутреннего цикла. В качестве примера рассмотрим следующую конструкцию:</p>
    <p><code>for (…)</code></p>
    <p><code> for (…) {</code></p>
    <p><code>  …</code></p>
    <p><code> if (disaster) /* если бедствие */</code></p>
    <p><code>  goto error; /* уйти на ошибку */</code></p>
    <p><code>error: /* обработка ошибки */</code></p>
    <p><code> ликвидировать беспорядок</code></p>
    <p>Такая организация программы удобна, если подпрограмма обработки ошибочной ситуации не тривиальна и ошибка может встретиться в нескольких местах.</p>
    <p>Метка имеет вид обычного имени переменной, за которым следует двоеточие. На метку можно перейти с помощью <strong>goto</strong> из любого места данной функции, т. е. метка видима на протяжении всей функции.</p>
    <p>В качестве еще одного примера рассмотрим такую задачу: определить, есть ли в массивах a и b совпадающие элементы. Один из возможных вариантов ее реализации имеет следующий вид:</p>
    <p><code>for (i = 0; i ‹ n; i++)</code></p>
    <p><code> for (j = 0; j ‹ m; j++)</code></p>
    <p><code>  if (a[i] == b[i])</code></p>
    <p><code>   goto found;</code></p>
    <p><code>/* нет одинаковых элементов */</code></p>
    <p><code> …</code></p>
    <p><code>found:</code></p>
    <p><code>/* обнаружено совпадение: a[i] - b[i] */</code></p>
    <p>Программу нахождения совпадающих элементов можно написать и без <strong>goto</strong>, правда, заплатив за это дополнительными проверками и еще одной переменной:</p>
    <p><code>found = 0;</code></p>
    <p><code>for (i = 0; i ‹ n &amp;&amp; !found; i++)</code></p>
    <p><code> for (j = 0; j ‹ m &amp;&amp; !found; j++)</code></p>
    <p><code>  if (a[i] == b[j])</code></p>
    <p><code>   found = 1;</code></p>
    <p><code>if (found) /* обнаружено совпадение: a[i-1] - b[j-1] */</code></p>
    <p><code> …</code></p>
    <p><code>else</code></p>
    <p><code> /* нет одинаковых элементов */</code></p>
    <p><code> …</code></p>
    <p>За исключением редких случаев, подобных только что приведенным, программы с применением <strong>goto</strong>, как правило, труднее для понимания и сопровождения, чем программы, решающие те же задачи без <strong>goto</strong>. Хотя мы и не догматики в данном вопросе, все же думается, что к <strong>goto</strong> следует прибегать крайне редко, если использовать эту инструкцию вообще.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Глава 4. Функции и структура программы</p>
   </title>
   <section>
    <p>Функции разбивают большие вычислительные задачи на более мелкие и позволяют воспользоваться тем, что уже сделано другими разработчиками, а не начинать создание программы каждый раз "с нуля". В выбранных должным образом функциях "упрятаны" несущественные для других частей программы детали их функционирования, что делает программу в целом более ясной и облегчает внесение в нее изменений.</p>
    <p>Язык проектировался так, чтобы функции были эффективными и простыми в использовании. Обычно программы на Си состоят из большого числа небольших функций, а не из немногих больших. Программу можно располагать в одном или нескольких исходных файлах. Эти файлы можно компилировать отдельно, а загружать вместе, в том числе и с ранее откомпилированными библиотечными функциями. Процесс загрузки здесь не рассматривается, поскольку он различен в разных системах.</p>
    <p>Объявление и определение функции - это та область, где стандартом ANSI в язык внесены самые существенные изменения. Как мы видели в главе 1, в описании функции теперь разрешено задавать типы аргументов. Синтаксис определения функции также изменен, так что теперь объявления и определения функций соответствуют друг другу. Это позволяет компилятору обнаруживать намного больше ошибок, чем раньше. Кроме того. если типы аргументов соответствующим образом объявлены, то необходимые преобразования аргументов выполняются автоматически.</p>
    <p>Стандарт вносит ясность в правила, определяющие области видимости имен; в частности, он требует, чтобы для каждого внешнего объекта было только одно определение. В нем обобщены средства инициализации: теперь можно инициализировать автоматические массивы и структуры. Улучшен также препроцессор Си. Он включает более широкий набор директив условной компиляции, предоставляет возможность из макроаргументов генерировать строки в кавычках, а кроме того. содержит более совершенный механизм управления процессом макрорасширения.</p>
   </section>
   <section>
    <title>
     <p>4.1 Основные сведения о функциях</p>
    </title>
    <p>Начнем с того, что сконструируем программу, печатающую те строки вводимого текста, в которых содержится некоторый "образец", заданный в виде строки символов. (Эта программа представляет собой частный случай функции grep системы UNIX.) Рассмотрим пример: в результате поиска образца "ould" в строках текста</p>
    <p><code>Ah Love! could you and I with Fate conspire</code></p>
    <p><code>To grasp this sorry Scheme of Things entire,</code></p>
    <p><code>Would not we shatter it to bits - and then</code></p>
    <p><code>Re-mould it nearer to The Heart's Desire!</code></p>
    <p>мы получим</p>
    <p><code>Ah Love! could you and I with Fate conspire</code></p>
    <p><code>Would not we shatter it to bits - and then</code></p>
    <p><code>Re-mould it nearer to the Heart's Desire!</code></p>
    <p>Работа по поиску образца четко распадается на три этапа:</p>
    <p><code>while (<emphasis>существует еще строка</emphasis>)</code></p>
    <p><code>if (<emphasis>строка содержит образец</emphasis>)</code></p>
    <p><code><emphasis>напечатать ее</emphasis></code></p>
    <p>Хотя все три составляющие процесса поиска можно поместить в функцию <emphasis>main</emphasis>, все же лучше сохранить приведенную структуру и каждую ее часть реализовать в виде отдельной функции. Легче иметь дело с тремя небольшими частями, чем с одной большой, поскольку, если несущественные особенности реализации скрыты в функциях, вероятность их нежелательного воздействия друг на друга минимальна. Кроме того, оформленные в виде функций соответствующие части могут оказаться полезными и в других программах.</p>
    <p>Конструкция "while (<emphasis>существует еще строка</emphasis>)" реализована в <emphasis>getline</emphasis> (см. главу 1), а фразу "<emphasis>напечатать ее</emphasis>" можно записать с помощью готовой функции <emphasis>printf</emphasis>. Таким образом, нам остается перевести на Си только то, что определяет, входит ли заданный образец в строку.</p>
    <p>Чтобы решить эту задачу, мы напишем функцию <emphasis>strindex(s,t)</emphasis>, которая указывает место (индекс) в строке <emphasis>s</emphasis>, где начинается строка <emphasis>t</emphasis>, или -1, если <emphasis>s</emphasis> не содержит <emphasis>t</emphasis>. Так как в Си нумерация элементов в массивах начинается с нуля, отрицательное число -1 подходит в качестве признака неудачного поиска. Если далее нам потребуется более сложное отождествление по образцу, мы просто заменим <emphasis>strindex</emphasis> на другую функцию, оставив при этом остальную часть программы без изменений. (Библиотечная функция <strong>strstr</strong> аналогична функции <emphasis>strindex</emphasis> и отличается от последней только тем, что возвращает не индекс, а указатель.)</p>
    <p>После такого проектирования программы ее "деталировка" оказывается очевидной. Мы имеем представление о программе в целом и знаем, как взаимодействуют ее части. В нашей программе образец для поиска задается строкой-литералом, что снижает ее универсальность. В главе 5 мы еще вернемся к проблеме инициализации символьных массивов и покажем, как образец сделать параметром, устанавливаемым при запуске программы. Здесь приведена несколько измененная версия функции <emphasis>getline</emphasis>, и было бы поучительно сравнить ее с версией, рассмотренной в главе 1.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#define MAXLINE 1000 /* максимальный размер вводимой строки */</code></p>
    <empty-line/>
    <p><code>int getline(char line[], int max);</code></p>
    <p><code>int strindex(char source[], char searchfor[]);</code></p>
    <empty-line/>
    <p><code>char pattern[] ="ould"; /* образец для поиска */</code></p>
    <empty-line/>
    <p><code>/* найти все строки, содержащие образец */</code></p>
    <empty-line/>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> char line[MAXLINE];</code></p>
    <p><code> int found = 0;</code></p>
    <p><code> while (getline(line, MAXLINE) › 0)</code></p>
    <p><code>  if (strindex(line, pattern) ›= 0) {</code></p>
    <p><code>   printf ("%s", line);</code></p>
    <p><code>   found++;</code></p>
    <p><code>  }</code></p>
    <p><code> return found;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* getline: читает строку в s, возвращает длину */</code></p>
    <p><code>int getline(char s[], int lim)</code></p>
    <p><code>{</code></p>
    <p><code> int c, i;</code></p>
    <p><code> i = 0;</code></p>
    <p><code> while (--lim › 0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; с != '\n') /* I.B.: misprint was here -lim instead of --lim */</code></p>
    <p><code>  s[i++] = c;</code></p>
    <p><code> if (c == '\n')</code></p>
    <p><code>  s[i++] = c;</code></p>
    <p><code> s[i] = '\0';</code></p>
    <p><code> return i;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* strindex: вычисляет место t в s или выдает -1, если t нет в s */</code></p>
    <p><code>int strindex (char s[], char t[])</code></p>
    <p><code>{</code></p>
    <p><code> int i, j, k;</code></p>
    <p><code> for (i = 0; s[i] != '\0'; i++) {</code></p>
    <p><code>  for (j = i, k = 0; t[k] !=  '\0' &amp;&amp; s[j] == t[k]; j++, k++)</code></p>
    <p><code>   ;</code></p>
    <p><code>  if (k › 0 &amp;&amp; t[k] == '\0')</code></p>
    <p><code>   return i;</code></p>
    <p><code> }</code></p>
    <p><code> return -1;</code></p>
    <p><code><code>}</code></code></p>
    <p>Определение любой функции имеет следующий вид:</p>
    <p><code><emphasis>тип-результата имя-функции</emphasis> (<emphasis>объявления аргументов</emphasis>)</code></p>
    <p><code>{</code></p>
    <p><code><emphasis> объявления и инструкции</emphasis></code></p>
    <p><code>}</code></p>
    <p>Отдельные части определения могут отсутствовать, как, например, в определении "минимальной" функции</p>
    <p><code>dummy() {}</code></p>
    <p>которая ничего не вычисляет и ничего не возвращает. Такая ничего не делающая функция в процессе разработки программы бывает полезна в качестве "хранителя места". Если тип результата опущен, то предполагается, что функция возвращает значение типа <emphasis>int</emphasis>.</p>
    <p>Любая программа - это просто совокупность определений переменных и функций. Связи между функциями осуществляются через аргументы, возвращаемые значения и внешние переменные. В исходном файле функции могут располагаться в любом порядке; исходную программу можно разбивать на любое число файлов, но так, чтобы ни одна из функций не оказалась разрезанной.</p>
    <p>Инструкция <strong>return</strong> реализует механизм возврата результата от вызываемой функции к вызывающей. За словом <emphasis>return</emphasis> может следовать любое выражение:</p>
    <p><code>return <emphasis>выражение</emphasis>;</code></p>
    <p>Если потребуется, <emphasis>выражение</emphasis> будет приведено к возвращаемому типу функции. Часто выражение заключают в скобки, но они не обязательны.</p>
    <p>Вызывающая функция вправе проигнорировать возвращаемое значение. Более того, <emphasis>выражение</emphasis> в <strong>return</strong> может отсутствовать, и тогда вообще никакое значение не будет возвращено в вызывающую функцию. Управление возвращается в вызывающую функцию без результирующего значения также и в том случае, когда вычисления достигли "конца" (т. е. последней закрывающей фигурной скобки функции). Не запрещена (но должна вызывать настороженность) ситуация, когда в одной и той же функции одни <strong>return</strong> имеют при себе выражения, а другие - не имеют. Во всех случаях, когда функция "забыла" передать результат в <strong>return</strong>, она обязательно выдаст "мусор".</p>
    <p>Функция <emphasis>main</emphasis> в программе поиска по образцу возвращает в качестве результата количество найденных строк. Это число доступно той среде, из которой данная программа была вызвана.</p>
    <p>Механизмы компиляции и загрузки Си-программ, расположенных в нескольких исходных файлах, в разных системах могут различаться. В системе UNIX, например, эти работы выполняет упомянутая в главе 1 команда <emphasis>cc</emphasis>. Предположим, что три функции нашего последнего примера расположены в трех разных файлах: <emphasis>main.с</emphasis>, <emphasis>getline.c</emphasis> и <emphasis>strindex.c</emphasis>. Тогда команда</p>
    <p><code>cc main.с getline.c strindex.c</code></p>
    <p>скомпилирует указанные файлы, поместив результат компиляции в файлы объектных модулей <emphasis>main.o</emphasis>, <emphasis>getline.o</emphasis> и <emphasis>strindex.o</emphasis>, и затем загрузит их в исполняемый файл <emphasis>a.out</emphasis>. Если обнаружилась ошибка, например в файле <emphasis>main.с</emphasis>, то его можно скомпилировать снова и результат загрузить ранее полученными объектными файлами, выполнив следующую команду:</p>
    <p><code>cc main.с getline.o strindex.o</code></p>
    <p>Команда <emphasis>cc</emphasis> использует стандартные расширения файлов ".с" и ".о", чтобы отличать исходные файлы от объектных.</p>
    <p><strong>Упражнение 4.1</strong>. Напишите функцию strindex(s, t), которая выдает позицию самого правого вхождения t в s или -1, если вхождения не обнаружено.</p>
   </section>
   <section>
    <title>
     <p>4.2 Функции, возвращающие нецелые значения</p>
    </title>
    <p>В предыдущих примерах функции либо вообще не возвращали результирующих значений (<strong>void</strong>), либо возвращали значения типа <strong>int</strong>. А как быть, когда результат функции должен иметь другой тип? Многие вычислительные функции, как, например, sqrt, sin и cos, возвращают значения типа double; другие специальные функции могут выдавать значения еще каких-то типов. Чтобы проиллюстрировать, каким образом функция может возвратить нецелое значение, напишем функцию <emphasis>atof(s)</emphasis>, которая переводит строку s в соответствующее число с плавающей точкой двойной точности. Функция <emphasis>atof</emphasis> представляет собой расширение функции <emphasis>atoi</emphasis>, две версии которой были рассмотрены в главах 2 и 3. Она имеет дело со знаком (которого может и не быть), с десятичной точкой, а также с целой и дробной частями, одна из которых может отсутствовать. Наша версия не является высококачественной программой преобразования вводимых чисел; такая программа потребовала бы заметно больше памяти. Функция <emphasis>atof</emphasis> входит в стандартную библиотеку программ: ее описание содержится в заголовочном файле <strong>‹stdlib.h›</strong>.</p>
    <p>Прежде всего отметим, что объявлять тип возвращаемого значения должна сама <emphasis>atof</emphasis>, так как этот тип не есть <emphasis>int</emphasis>. Указатель типа задается перед именем функции.</p>
    <p><code>#include ‹ctype.h›</code></p>
    <p><code>/*atof: преобразование строки s в double */</code></p>
    <p><code>double atof (char s[])</code></p>
    <p><code>{</code></p>
    <p><code> double val, power;</code></p>
    <p><code> int i, sign;</code></p>
    <empty-line/>
    <p><code> for (i = 0; isspace(s[i]); i++)</code></p>
    <p><code>  ; /* игнорирование левых символов-разделителей */</code></p>
    <p><code> sign = (s[i] == '-') ? -1 : 1;</code></p>
    <p><code> if (s[i] == '+' || s[i] == '-')</code></p>
    <p><code>  i++;</code></p>
    <p><code> for (val = 0.0; isdigit(s[i]); i++)</code></p>
    <p><code>  val = 10.0 * val + (s[i] - '0');</code></p>
    <p><code> if (s[i] == '.')</code></p>
    <p><code>  i++;</code></p>
    <p><code> for (power = 1.0; isdigit(s[i]); i++) {</code></p>
    <p><code>  val = 10.0 * val + (s.[i] - '0');</code></p>
    <p><code>  power *= 10.0;</code></p>
    <p><code> }</code></p>
    <p><code> return sign * val / power;</code></p>
    <p><code>}</code></p>
    <p>Кроме того, важно, чтобы вызывающая программа знала, что <emphasis>atof</emphasis> возвращает нецелое значение. Один из способов обеспечить это - явно описать <emphasis>atof</emphasis> в вызывающей программе. Подобное описание демонстрируется ниже в программе простенького калькулятора (достаточного для проверки баланса чековой книжки), который каждую вводимую строку воспринимает как число, прибавляет его к текущей сумме и печатает ее новое значение.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#define MAXLINE 100</code></p>
    <p><code>/* примитивный калькулятор */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> double sum, atof (char[]);</code></p>
    <p><code> char line[MAXLINE];</code></p>
    <p><code> int getline (char line[], int max);</code></p>
    <empty-line/>
    <p><code> sum = 0;</code></p>
    <p><code> while (getline(line, MAXLINE) › 0)</code></p>
    <p><code>  printf ("\t%g\n", sum += atof(line));</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>В объявлении</p>
    <p><code>double sum, atof (char[]);</code></p>
    <p>говорится, что <emphasis>sum</emphasis> - переменная типа <emphasis>double</emphasis>, a <emphasis>atof</emphasis> - функция, которая принимает один аргумент типа <emphasis>char[]</emphasis> и возвращает результат типа <emphasis>double</emphasis>.</p>
    <p>Объявление и определение функции <emphasis>atof</emphasis> должны соответствовать друг другу. Если в одном исходном файле сама функция <emphasis>atof</emphasis> и обращение к ней в <emphasis>main</emphasis> имеют разные типы, то это несоответствие будет зафиксировано компилятором как ошибка. Но если функция <emphasis>atof</emphasis> была скомпилирована отдельно (что более вероятно), то несоответствие типов не будет обнаружено, и <emphasis>atof</emphasis> возвратит значение типа <emphasis>double</emphasis>, которое функция <emphasis>main</emphasis> воспримет как <emphasis>int</emphasis>, что приведет к бессмысленному результату.</p>
    <p>Это последнее утверждение, вероятно, вызовет у вас удивление, поскольку ранее говорилось о необходимости соответствия объявлений и определений. Причина несоответствия, возможно, будет следствием того, что вообще отсутствует прототип функции, и функция неявно объявляется при первом своем появлении в выражении, как, например, в</p>
    <p><code>sum += atof(line);</code></p>
    <p>Если в выражении встретилось имя, нигде ранее не объявленное, за которым следует открывающая скобка, то такое имя по контексту считается именем функции, возвращающей результат типа <emphasis>int</emphasis>; при этом относительно ее аргументов ничего не предполагается. Если в объявлении функции аргументы не указаны, как в</p>
    <p><code>double atof();</code></p>
    <p>то и в этом случае считается, что ничего об аргументах <emphasis>atof</emphasis> не известно, и все проверки на соответствие ее параметров будут выключены. Предполагается, что такая специальная интерпретация пустого списка позволит новым компиляторам транслировать старые Си-программы. Но в новых программах пользоваться этим - не очень хорошая идея. Если у функции есть аргументы, опишите их, если их нет, используйте слово <emphasis>void</emphasis>.</p>
    <p>Располагая соответствующим образом описанной функцией <emphasis>atof</emphasis>, мы можем написать функцию <emphasis>atoi</emphasis>, преобразующую строку символов в целое значение, следующим образом:</p>
    <p><code>/* atoi: преобразование строки s в int с помощью atof */</code></p>
    <p><code>int atoi (char s[])</code></p>
    <p><code>{</code></p>
    <p><code> double atof (char s[]);</code></p>
    <p><code> return (int) atof (s);</code></p>
    <p><code>}</code></p>
    <p>Обратите внимание на вид объявления и инструкции <emphasis>return</emphasis>. Значение выражения в</p>
    <p><code>return <emphasis>выражение</emphasis>;</code></p>
    <p>перед тем, как оно будет возвращено в качестве результата, приводится к типу функции. Следовательно, поскольку функция <emphasis>atoi</emphasis> возвращает значение <emphasis>int</emphasis>, результат вычисления <emphasis>atof</emphasis> типа <emphasis>double</emphasis> в инструкции <emphasis>return</emphasis> автоматически преобразуется в тип <emphasis>int</emphasis>. При преобразовании возможна потеря информации, и некоторые компиляторы предупреждают об этом. Оператор приведения явно указывает на необходимость преобразования типа и подавляет любое предупреждающее сообщение.</p>
    <p><strong>Упражнение 4.2</strong>. Дополните функцию <emphasis>atof</emphasis> таким образом, чтобы она справлялась с числами вида</p>
    <p><code>123.45e-6</code></p>
    <p>в которых после мантиссы может стоять e (или E) с последующим порядком (быть может, со знаком).</p>
   </section>
   <section>
    <title>
     <p>4.3 Внешние переменные</p>
    </title>
    <p>Программа на Си обычно оперирует с множеством внешних объектов: переменных и функций. Прилагательное "внешний" (<strong>external</strong>) противоположно прилагательному "внутренний", которое относится к аргументам и переменным, определяемым внутри функций. Внешние переменные определяются вне функций и потенциально доступны для многих функций. Сами функции всегда являются внешними объектами, поскольку в Си запрещено определять функции внутри других функций. По умолчанию одинаковые внешние имена, используемые в разных файлах, относятся к одному и тому же внешнему объекту (функции). (В стандарте это называется <emphasis>редактированием внешних связей (линкованием)</emphasis> (<emphasis>external linkage</emphasis>).) В этом смысле внешние переменные похожи на области <emphasis>COMMON</emphasis> в Фортране и на переменные самого внешнего блока в Паскале. Позже мы покажем, как внешние функции и переменные сделать видимыми только внутри одного исходного файла.</p>
    <p>Поскольку внешние переменные доступны всюду, их можно использовать в качестве связующих данных между функциями как альтернативу связей через аргументы и возвращаемые значения. Для любой функции внешняя переменная доступна по ее имени, если это имя было должным образом объявлено.</p>
    <p>Если число переменных, совместно используемых функциями, велико, связи между последними через внешние переменные могут оказаться более удобными и эффективными, чем длинные списки аргументов. Но, как отмечалось в главе 1, к этому заявлению следует относиться критически, поскольку такая практика ухудшает структуру программы и приводит к слишком большому числу связей между функциями по данным.</p>
    <p>Внешние переменные полезны, так как они имеют большую область действия и время жизни. Автоматические переменные существуют только внутри функции, они возникают в момент входа в функцию и исчезают при выходе из нее. Внешние переменные, напротив, существуют постоянно, так что их значения сохраняются и между обращениями к функциям. Таким образом, если двум функциям приходится пользоваться одними и теми же данными и ни одна из них не вызывает другую, то часто бывает удобно оформить эти общие данные в виде внешних переменных, а не передавать их в функцию и обратно через аргументы.</p>
    <p>В связи с приведенными рассуждениями разберем пример. Поставим себе задачу написать программу-калькулятор, понимающую операторы +, -, * и /. Такой калькулятор легче будет написать, если ориентироваться на польскую, а не инфиксную запись выражений. (Обратная польская запись применяется в некоторых карманных калькуляторах и в таких языках, как Forth и Postscript.) В обратной польской записи каждый оператор следует за своими операндами. Выражение в инфиксной записи, скажем</p>
    <p><code>(1 - 2) * (4 + 5)</code></p>
    <p>в польской записи представляется как</p>
    <p><code>1 2 - 4 5 + *</code></p>
    <p>Скобки не нужны, неоднозначности в вычислениях не бывает, поскольку известно, сколько операндов требуется для каждого оператора.</p>
    <p>Реализовать нашу программу весьма просто. Каждый операнд посылается в стек; если встречается оператор, то из стека берется соответствующее число операндов (в случае бинарных операторов два) и выполняется операция, после чего результат посылается в стек. В нашем примере числа 1 и 2 посылаются в стек, затем замещаются на их разность -1. Далее в стек посылаются числа 4 и 5, которые затем заменяются их суммой (9). Числа -1 и 9 заменяются в стеке их произведением (т. е. -9). Встретив символ новой строки, программа извлекает значение из стека и печатает его.</p>
    <p>Таким образом, программа состоит из цикла, обрабатывающего на каждом своем шаге очередной встречаемый оператор или операнд:</p>
    <p>while (<emphasis>следующий элемент не конец-файла</emphasis>)</p>
    <p> if (<emphasis>число</emphasis>)</p>
    <p><emphasis>  послать его в стек</emphasis></p>
    <p> else if (<emphasis>оператор</emphasis>)</p>
    <p><emphasis>  взять из стека операнды</emphasis></p>
    <p><emphasis>  выполнить операцию </emphasis></p>
    <p><emphasis>  результат послать в стек</emphasis></p>
    <p> else if (<emphasis>новая-строка</emphasis>)</p>
    <p><emphasis>  взять с вершины стека число и напечатать</emphasis></p>
    <p> else</p>
    <p><emphasis>  ошибка</emphasis></p>
    <p>Операции "послать в стек" и "взять из стека" сами по себе тривиальны, однако по мере добавления к ним механизмов обнаружения и нейтрализации ошибок становятся достаточно длинными. Поэтому их лучше оформить в виде отдельных функций, чем повторять соответствующий код по всей программе. И конечно необходимо иметь отдельную функцию для получения очередного оператора или операнда.</p>
    <p>Главный вопрос, который мы еще не рассмотрели, - это вопрос о том, где расположить стек и каким функциям разрешить к нему прямой доступ. Стек можно расположить в функции <emphasis>main</emphasis> и передавать сам стек и текущую позицию в нем в качестве аргументов функциям <emphasis>push</emphasis> ("послать в стек") и <emphasis>pop</emphasis> ("взять из стека"). Но функции <emphasis>main</emphasis> нет дела до переменных, относящихся к стеку, - ей нужны только операции по помещению чисел в стек и извлечению их оттуда. Поэтому мы решили стек и связанную с ним информацию хранить во внешних переменных, доступных для функций <emphasis>push</emphasis> и <emphasis>pop</emphasis>, но не доступных для <emphasis>main</emphasis>.</p>
    <p>Переход от эскиза к программе достаточно легок. Если теперь программу представить как текст, расположенный в одном исходном файле, она будет иметь следующий вид:</p>
    <p><code>#include /* могут быть в любом количестве */</code></p>
    <p><code>#define /* могут быть в любом количестве */</code></p>
    <empty-line/>
    <p><code><emphasis>объявления функций для main </emphasis></code></p>
    <empty-line/>
    <p><code>main() {…}</code></p>
    <p><code><emphasis>внешние переменные для push и pop</emphasis></code></p>
    <empty-line/>
    <p><code>void push (double f) {…}</code></p>
    <p><code>double pop (void) {…}</code></p>
    <empty-line/>
    <p><code>int getop(char s[]) {…}</code></p>
    <empty-line/>
    <p><code><emphasis>подпрограммы, вызываемые функцией getop</emphasis></code></p>
    <p>Позже мы обсудим, как текст этой программы можно разбить на два или большее число файлов.</p>
    <p>Функция <emphasis>main</emphasis> - это цикл, содержащий большой переключатель <emphasis>switch</emphasis>, передающий управление на ту или иную ветвь в зависимости от типа оператора или операнда. Здесь представлен более типичный случай применения переключателя <emphasis>switch</emphasis> по сравнению с рассмотренным в параграфе 3.4.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include ‹stdlib.h› /* для atof() */</code></p>
    <empty-line/>
    <p><code>#define MAXOP 100 /* макс. размер операнда или оператора */</code></p>
    <p><code>#define NUMBER '0' /* признак числа */</code></p>
    <empty-line/>
    <p><code>int getop (char []);</code></p>
    <p><code>void push (double);</code></p>
    <p><code>double pop (void);</code></p>
    <empty-line/>
    <p><code>/* калькулятор с обратной польской записью */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int type;</code></p>
    <p><code> double op2;</code></p>
    <p><code> char s[MAXOP];</code></p>
    <empty-line/>
    <p><code> while ((type = getop (s)) != EOF) {</code></p>
    <p><code>  switch (type) {</code></p>
    <p><code>  case NUMBER:</code></p>
    <p><code>   push (atof(s));</code></p>
    <p><code>   break;</code></p>
    <p><code>  case '+':</code></p>
    <p><code>   push(pop() + pop());</code></p>
    <p><code>   break;</code></p>
    <p><code>  case '*':</code></p>
    <p><code>   push(pop() * pop());</code></p>
    <p><code>   break;</code></p>
    <p><code>  case '-':</code></p>
    <p><code>   op2 = pop();</code></p>
    <p><code>   push(pop() - op2);</code></p>
    <p><code>   break;</code></p>
    <p><code>  case '/':</code></p>
    <p><code>   pop2 = pop();</code></p>
    <p><code>   if (op2 != 0.0)</code></p>
    <p><code>    push(pop() / op2);</code></p>
    <p><code>   else</code></p>
    <p><code>    printf("ошибка: деление на нуль\n");</code></p>
    <p><code>   break;</code></p>
    <p><code>  case '\n':</code></p>
    <p><code>   printf("\t%.8g\n", pop());</code></p>
    <p><code>   break;</code></p>
    <p><code>  default:</code></p>
    <p><code>   printf("ошибка: неизвестная операция %s\n", s);</code></p>
    <p><code>   break;</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Так как операторы + и * коммутативны, порядок, в котором операнды берутся из стека, не важен, однако в случае операторов - и /, левый и правый операнды должны различаться. Так, в</p>
    <p><code>push(pop() - pop()); /* НЕПРАВИЛЬНО */</code></p>
    <p>очередность обращения к <emphasis>pop</emphasis> не определена. Чтобы гарантировать правильную очередность, необходимо первое значение из стека присвоить временной переменной, как это и сделано в main.</p>
    <p><code>#define MAXVAL 100 /* максимальная глубина стека */</code></p>
    <empty-line/>
    <p><code>int sp = 0; /* следующая свободная позиция в стеке */</code></p>
    <p><code>double val[MAXVAL]; /* стек */</code></p>
    <empty-line/>
    <p><code>/* push: положить значение f в стек */</code></p>
    <p><code>void push(double f)</code></p>
    <p><code>{</code></p>
    <p><code> if (sp ‹ MAXVAL)</code></p>
    <p><code>  val[sp++] = f;</code></p>
    <p><code> else</code></p>
    <p><code> printf("ошибка: стек полон, %g не помещается\n", f);</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* pop: взять с вершины стека и выдать в качестве результата */</code></p>
    <p><code>double pop(void)</code></p>
    <p><code>{</code></p>
    <p><code> if (sp › 0)</code></p>
    <p><code>  return val[--sp];</code></p>
    <p><code> else {</code></p>
    <p><code>  printf ("ошибка: стек пуст\n");</code></p>
    <p><code>  return 0.0;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>Переменная считается внешней, если она определена вне функции. Таким образом, стек и индекс стека, которые должны быть доступны и для <emphasis>push</emphasis>, и для <emphasis>pop</emphasis>, определяются вне этих функций. Но <emphasis>main</emphasis> не использует ни стек, ни позицию в стеке, и поэтому их представление может быть скрыто от <emphasis>main</emphasis>.</p>
    <p>Займемся реализацией <emphasis>getop</emphasis> - функции, получающей следующий оператор или операнд. Нам предстоит решить довольно простую задачу. Более точно: требуется пропустить пробелы и табуляции; если следующий символ - не цифра и не десятичная точка, то нужно выдать его; в противном случае надо накопить строку цифр с десятичной точкой, если она есть, и выдать число NUMBER в качестве результата.</p>
    <p><code>#include ‹ctype.h›</code></p>
    <empty-line/>
    <p><code>int getch(void);</code></p>
    <p><code>void ungetch(int);</code></p>
    <empty-line/>
    <p><code>/* getop: получает следующий оператор или операнд */</code></p>
    <p><code>int getop(char s[])</code></p>
    <p><code>{</code></p>
    <p><code> int i, с;</code></p>
    <p><code> while ((s[0] = с = getch()) == ' ' || с == '\t')</code></p>
    <p><code>  ;</code></p>
    <p><code> s[1] = '\0;</code></p>
    <p><code> if (!isdigit(c) &amp;&amp; с!= '.')</code></p>
    <p><code>  return c; /* не число */</code></p>
    <p><code> i = 0;</code></p>
    <p><code> if (isdigit(c)) /* накапливаем целую часть */</code></p>
    <p><code>  while (isdigit(s[++i] - с = getch()))</code></p>
    <p><code>   ;</code></p>
    <p><code> if (с == '.') /* накапливаем дробную часть */</code></p>
    <p><code>  while (isdigit(s[++i] = с = getch()))</code></p>
    <p><code>   ;</code></p>
    <p><code> s[i] = '\0';</code></p>
    <p><code> if (c != EOF)</code></p>
    <p><code>  ungetch(c);</code></p>
    <p><code> return NUMBER;</code></p>
    <p><code>}</code></p>
    <p>Как работают функции <emphasis>getch</emphasis> и <emphasis>ungetch</emphasis>? Во многих случаях программа не может "сообразить", прочла ли она все, что требуется, пока не прочтет лишнего. Так, накопление числа производится до тех пор, пока не встретится символ, отличный от цифры. Но это означает, что программа прочла на один символ больше, чем нужно, и последний символ нельзя включать в число.</p>
    <p>Эту проблему можно было бы решить при наличии обратной чтению операции "положить-назад", с помощью которой можно было бы вернуть ненужный символ. Тогда каждый раз, когда программа считает на один символ больше, чем требуется, эта операция возвращала бы его вводу, и остальная часть программы могла бы вести себя так, будто этот символ вовсе и не читался. К счастью, описанный механизм обратной посылки символа легко моделируется с помощью пары согласованных друг с другом функций, из которых <emphasis>getch</emphasis> поставляет очередной символ из ввода, a <emphasis>ungetch</emphasis> отправляет символ назад во входной поток, так что при следующем обращении к <emphasis>getch</emphasis> мы вновь его получим.</p>
    <p>Нетрудно догадаться, как они работают вместе. Функция <emphasis>ungetch</emphasis> запоминает посылаемый назад символ в некотором буфере, представляющем собой массив символов, доступный для обеих этих функций; <emphasis>getch</emphasis> читает из буфера, если там что-то есть, или обращается к <emphasis>getchar</emphasis>, если буфер пустой. Следует предусмотреть индекс, указывающий на положение текущего символа в буфере.</p>
    <p>Так как функции <emphasis>getch</emphasis> и <emphasis>ungetch</emphasis> совместно используют буфер и индекс, значения последних должны между вызовами сохраняться. Поэтому буфер и индекс должны быть внешними по отношению к этим программам, и мы можем записать <emphasis>getch</emphasis>, <emphasis>ungetch</emphasis> и общие для них переменные в следующем виде:</p>
    <p><code>#define BUFSIZE 100</code></p>
    <empty-line/>
    <p><code>char buf[BUFSIZE]; /* буфер для ungetch */</code></p>
    <p><code>int bufp = 0; /* след. свободная позиция в буфере */</code></p>
    <empty-line/>
    <p><code>int getch(void) /* взять (возможно возвращенный) символ */</code></p>
    <p><code>{</code></p>
    <p><code> return (bufp › 0) ? buf[--bufp]: getchar();</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>void ungetch(int c) /* вернуть символ на ввод */</code></p>
    <p><code>{</code></p>
    <p><code> if (bufp ›= BUFSIZE)</code></p>
    <p><code>  printf("ungetch: слишком много символов\n");</code></p>
    <p><code> else</code></p>
    <p><code>  buf[bufp++] = с;</code></p>
    <p><code>}</code></p>
    <p>Стандартная библиотека включает функцию <strong>ungetc</strong>, обеспечивающую возврат одного символа (см. главу 7). Мы же, чтобы проиллюстрировать более общий подход, для запоминания возвращаемых символов использовали массив.</p>
    <p><strong>Упражнение 4.3</strong>. Исходя из предложенной нами схемы, дополните программу- калькулятор таким образом, чтобы она "понимала" оператор получения остатка от деления (%) и отрицательные числа.</p>
    <p><strong>Упражнение 4.4</strong>. Добавьте команды, с помощью которых можно было бы печатать верхний элемент стека (с сохранением его в стеке), дублировать его в стеке, менять местами два верхних элемента стека. Введите команду очистки стека.</p>
    <p><strong>Упражнение 4.5</strong>. Предусмотрите возможность использования в программе библиотечных функций sin, ехр и pow. См. библиотеку ‹math.h› в приложении B (параграф 4).</p>
    <p><strong>Упражнение 4.6</strong>. Введите команды для работы с переменными (легко обеспечить до 26 переменных, каждая из которых имеет имя, представленное одной буквой латинского алфавита). Добавьте переменную, предназначенную для хранения самого последнего из напечатанных значений.</p>
    <p><strong>Упражнение 4.7</strong>. Напишите программу ungets(s), возвращающую строку s во входной поток. Должна ли ungets "знать" что-либо о переменных buf и bufp, или ей достаточно пользоваться только функцией ungetch?</p>
    <p><strong>Упражнение 4.8</strong>. Предположим, что число символов, возвращаемых назад, не превышает 1. Модифицируйте с учетом этого факта функции getch и ungetch.</p>
    <p><strong>Упражнение 4.9</strong>. В наших функциях не предусмотрена возможность возврата EOF. Подумайте, что надо сделать, чтобы можно было возвращать EOF, и скорректируйте соответственно программу.</p>
    <p><strong>Упражнение 4.10</strong>. В основу программы калькулятора можно положить применение функции getline, которая читает целиком строку; при этом отпадает необходимость в getch и ungetch. Напишите программу, реализующую этот подход.</p>
   </section>
   <section>
    <title>
     <p>4.4 Области видимости</p>
    </title>
    <p>Функции и внешние переменные, из которых состоит Си-программа, каждый раз компилировать все вместе нет никакой необходимости. Исходный текст можно хранить в нескольких файлах. Ранее скомпилированные программы можно загружать из библиотек. В связи с этим возникают следующие вопросы:</p>
    <p>• Как писать объявления, чтобы на протяжении компиляции используемые переменные были должным образом объявлены?</p>
    <p>• В каком порядке располагать объявления, чтобы во время загрузки все части программы оказались связаны нужным образом?</p>
    <p>• Как организовать объявления, чтобы они имели лишь одну копию?</p>
    <p>• Как инициализировать внешние переменные?</p>
    <p>Начнем с того, что разобьем программу-калькулятор на несколько файлов. Конечно, эта программа слишком мала, чтобы ее стоило разбивать на файлы, однако разбиение нашей программы позволит продемонстрировать проблемы, возникающие в больших программах.</p>
    <p><emphasis>Областью видимости</emphasis> имени считается часть программы, в которой это имя можно использовать. Для автоматических переменных, объявленных в начале функции, областью видимости является функция, в которой они объявлены. Локальные переменные разных функций, имеющие, однако, одинаковые имена, никак не связаны друг с другом. То же утверждение справедливо и в отношении параметров функции, которые фактически являются локальными переменными.</p>
    <p>Область действия внешней переменной или функции простирается от точки программы, где она объявлена, до конца файла, подлежащего компиляции. Например, если <emphasis>main</emphasis>, <emphasis>sp</emphasis>, <emphasis>val</emphasis>, <emphasis>push</emphasis> и <emphasis>pop</emphasis> определены в одном файле в указанном порядке, т. е.</p>
    <p><code>main() {…}</code></p>
    <empty-line/>
    <p><code>int sp = 0;</code></p>
    <p><code>double val[MAXVAL];</code></p>
    <empty-line/>
    <p><code>void push(double f) {…}</code></p>
    <p><code>double pop(void) {…}</code></p>
    <p>то к переменным <emphasis>sp</emphasis> и <emphasis>val</emphasis> можно адресоваться из <emphasis>push</emphasis> и <emphasis>pop</emphasis> просто по их именам; никаких дополнительных объявлений для этого не требуется. Заметим, что в <emphasis>main</emphasis> эти имена не видимы так же, как и сами <emphasis>push</emphasis> и <emphasis>pop</emphasis>.</p>
    <p>Однако, если на внешнюю переменную нужно сослаться до того, как она определена, или если она определена в другом файле, то ее объявление должно быть помечено словом <strong>extern</strong>.</p>
    <p>Важно отличать <emphasis>объявление</emphasis> внешней переменной от ее <emphasis>определения</emphasis>. Объявление объявляет свойства переменной (прежде всего ее тип), а определение, кроме того, приводит к выделению для нее памяти. Если строки</p>
    <p><code>int sp;</code></p>
    <p><code>double val[MAXVAL];</code></p>
    <p>расположены вне всех функций, то они <emphasis>определяют</emphasis> внешние переменные <emphasis>sp</emphasis> и <emphasis>val</emphasis>, т. e. отводят для них память, и, кроме того, служат объявлениями для остальной части исходного файла. А вот строки</p>
    <p>extern int sp;</p>
    <p><code>extern double val[];</code></p>
    <p><emphasis>объявляют</emphasis> для оставшейся части файла, что <emphasis>sp</emphasis> - переменная типа <emphasis>int</emphasis>, а <emphasis>val</emphasis> - массив типа <emphasis>double</emphasis> (размер которого определен где-то в другом месте); при этом ни переменная, ни массив не создаются, и память им не отводится.</p>
    <p>На всю совокупность файлов, из которых состоит исходная программа, для каждой внешней переменной должно быть одно-единственное <emphasis>определение</emphasis>; другие файлы, чтобы получить доступ к внешней переменной, должны иметь в себе объявление <emphasis>extern</emphasis>. (Впрочем, объявление <emphasis>extern</emphasis> можно поместить и в файл, в котором содержится определение.) В определениях массивов необходимо указывать их размеры, что в объявлениях <emphasis>extern</emphasis> не обязательно. Инициализировать внешнюю переменную можно только в определении. Хотя вряд ли стоит организовывать нашу программу таким образом, но мы определим push и pop в одном файле, а val и sp - в другом, где их и инициализируем. При этом для установления связей понадобятся такие определения и объявления:</p>
    <p><code><emphasis>В файле 1</emphasis>:</code></p>
    <empty-line/>
    <p><code>extern int sp;</code></p>
    <p><code>extern double val[];</code></p>
    <empty-line/>
    <p><code>void push(double f) {…}</code></p>
    <p><code>double pop(void) {…}</code></p>
    <empty-line/>
    <p><code><emphasis>В файле2</emphasis>:</code></p>
    <empty-line/>
    <p><code>int sp = 0;</code></p>
    <p><code>double val[MAXVAL];</code></p>
    <p>Поскольку объявления <emphasis>extern</emphasis> находятся в начале <emphasis>файла1</emphasis> и вне определений функций, их действие распространяется на все функции, причем одного набора объявлений достаточно для всего <emphasis>файла1</emphasis>. Та же организация <emphasis>extern</emphasis>-объявлений необходима и в случае, когда программа состоит из одного файла, но определения sp и val расположены после их использования.</p>
   </section>
   <section>
    <title>
     <p>4.5 Заголовочные файлы</p>
    </title>
    <p>Теперь представим себе, что компоненты программы-калькулятора имеют существенно большие размеры, и зададимся вопросом, как в этом случае распределить их по нескольким файлам. Программу <emphasis>main</emphasis> поместим в файл, который мы назовем <emphasis>main.с</emphasis>; <emphasis>push</emphasis>, <emphasis>pop</emphasis> и их переменные расположим во втором файле, <emphasis>stack.с</emphasis>; a <emphasis>getop</emphasis> - в третьем, <emphasis>getop.c</emphasis>. Наконец, <emphasis>getch</emphasis> и <emphasis>ungetch</emphasis> разместим в четвертом файле <emphasis>getch.с</emphasis>; мы отделили их от остальных функций, поскольку в реальной программе они будут получены из заранее скомпилированной библиотеки.</p>
    <p>Существует еще один момент, о котором следует предупредить читателя, - определения и объявления совместно используются несколькими файлами. Мы бы хотели, насколько это возможно, централизовать эти объявления и определения так, чтобы для них существовала только одна копия. Тогда программу в процессе ее развития будет легче и исправлять, и поддерживать в нужном состоянии. Для этого общую информацию расположим в заголовочном файле <emphasis>calc.h</emphasis>, который будем по мере необходимости включать в другие файлы. (Строка #include описывается в параграфе 4.11) В результате получим программу, файловая структура которой показана ниже:</p>
    <p><code><emphasis>main.с:</emphasis></code></p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include ‹stdlib.h›</code></p>
    <p><code>#include "calc.h"</code></p>
    <p><code>#define MAXOP 100</code></p>
    <p><code>main() {</code></p>
    <p><code> …</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code><emphasis>calc.h:</emphasis></code></p>
    <p><code>#define NUMBER '0'</code></p>
    <p><code>void push(double);</code></p>
    <p><code>double pop(void);</code></p>
    <p><code>int getop(char[]);</code></p>
    <p><code>int getch(void);</code></p>
    <p><code>void ungetch(int);</code></p>
    <empty-line/>
    <p><code><emphasis>getop.c:</emphasis></code></p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include ‹ctype.h›</code></p>
    <p><code>#include "calc.h"</code></p>
    <p><code>getop (){</code></p>
    <p><code> …</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code><emphasis>getch.c:</emphasis></code></p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#define BUFSIZE 100</code></p>
    <p><code>char buf[BUFSIZE];</code></p>
    <p><code>intbufp = 0;</code></p>
    <p><code>int getch(void) {</code></p>
    <p><code> …</code></p>
    <p><code>}</code></p>
    <p><code>void ungetch(int) {</code></p>
    <p><code> …</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code><emphasis>stack.с:</emphasis></code></p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include "calc.h"</code></p>
    <p><code>#define MAXVAL 100</code></p>
    <p><code>int sp = 0;</code></p>
    <p><code>double val[MAXVAL];</code></p>
    <p><code>void push(double) {</code></p>
    <p><code> …</code></p>
    <p><code>}</code></p>
    <p><code>double pop(void) {</code></p>
    <p><code> …</code></p>
    <p><code>}</code></p>
    <p>Неизбежен компромисс между стремлением, чтобы каждый файл владел только той информацией, которая ему необходима для работы, и тем, что на практике иметь дело с большим количеством заголовочных файлов довольно трудно. Для программ, не превышающих некоторого среднего размера, вероятно, лучше всего иметь один заголовочный файл, в котором собраны вместе все объекты, каждый из которых используется в двух различных файлах; так мы здесь и поступили. Для программ больших размеров потребуется более сложная организация с большим числом заголовочных файлов.</p>
   </section>
   <section>
    <title>
     <p>4.6 Статические переменные</p>
    </title>
    <p>Переменные <emphasis>sp</emphasis> и <emphasis>val</emphasis> в файле <emphasis>stack.с</emphasis>, а также <emphasis>buf</emphasis> и <emphasis>bufp</emphasis> в <emphasis>getch.с</emphasis> находятся в личном пользовании функций этих файлов, и нет смысла открывать к ним доступ кому-либо еще. Указание <strong>static</strong>, примененное к внешней переменной или функции, ограничивает область видимости соответствующего объекта концом файла. Это способ скрыть имена. Так, переменные <emphasis>buf</emphasis> и <emphasis>bufp</emphasis> должны быть внешними, поскольку их совместно используют функции <emphasis>getch</emphasis> и <emphasis>ungetch</emphasis>, но их следует сделать невидимыми для "пользователей" функций <emphasis>getch</emphasis> и <emphasis>ungetch</emphasis>.</p>
    <p>Статическая память специфицируется словом <strong>static</strong>, которое помещается перед обычным объявлением. Если рассматриваемые нами две функции и две переменные компилируются в одном файле, как в показанном ниже примере:</p>
    <p><code>static char buf[BUFSIZE]; /* буфер для ungetch */</code></p>
    <p><code>static int bufp = 0; /* след. свободная позиция в buf */</code></p>
    <empty-line/>
    <p><code>int getch(void) {…}</code></p>
    <empty-line/>
    <p><code>void ungetch(int с) {…}</code></p>
    <p>то никакая другая программа не будет иметь доступ ни к <emphasis>buf</emphasis>, ни к <emphasis>bufp</emphasis>, и этими именами можно свободно пользоваться в других файлах для совсем иных целей. Точно так же, помещая указание <strong>static</strong> перед объявлениями переменных <emphasis>sp</emphasis> и <emphasis>val</emphasis>, с которыми работают только <emphasis>push</emphasis> и <emphasis>pop</emphasis>, мы можем скрыть их от остальных функций.</p>
    <p>Указание <strong>static</strong> чаще всего используется для переменных, но с равным успехом его можно применять и к функциям. Обычно имена функций глобальны и видимы из любого места программы. Если же функция помечена словом <strong>static</strong>, то ее имя становится невидимым вне файла, в котором она определена.</p>
    <p>Объявление <strong>static</strong> можно использовать и для внутренних переменных. Как и автоматические переменные, внутренние статические переменные локальны в функциях, но в отличие от автоматических, они не возникают только на период работы функции, а существуют постоянно. Это значит, что внутренние статические переменные обеспечивают постоянное сохранение данных внутри функции.</p>
    <p><strong>Упражнение 4.11</strong>. Модифицируйте функцию <emphasis>getop</emphasis> так, чтобы отпала необходимость в функции <emphasis>ungetch</emphasis>. Подсказка: используйте внутреннюю статическую переменную.</p>
   </section>
   <section>
    <title>
     <p>4.7 Регистровые переменные</p>
    </title>
    <p>Объявление <strong>register</strong> сообщает компилятору, что данная переменная будет интенсивно использоваться. Идея состоит в том, чтобы переменные, объявленные <strong>register</strong>, разместить на регистрах машины, благодаря чему программа, возможно, станет более короткой и быстрой. Однако компилятор имеет право проигнорировать это указание. Объявление <strong>register</strong> выглядит следующим образом:</p>
    <p><code>register int х;</code></p>
    <p><code>register char с;</code></p>
    <p>и т. д. Объявление <strong>register</strong> может применяться только к автоматическим переменным и к формальным параметрам функции. Для последних это выглядит так:</p>
    <p><code>f(register unsigned m, register long n)</code></p>
    <p><code>{</code></p>
    <p><code> register int i;</code></p>
    <p><code> …</code></p>
    <p><code>}</code></p>
    <p>На практике существуют ограничения на регистровые переменные, что связано с возможностями аппаратуры. Располагаться в регистрах может лишь небольшое число переменных каждой функции, причем только определенных типов. Избыточные объявления <strong>register</strong> ни на что не влияют, так как игнорируются в отношении переменных, которым не хватило регистров или которые нельзя разместить на регистре. Кроме того, применительно к регистровой переменной независимо от того, выделен на самом деле для нее регистр или нет, не определено понятие адреса (см. главу 5). Конкретные ограничения на количество и типы регистровых переменных зависят от машины.</p>
   </section>
   <section>
    <title>
     <p>4.8 Блочная структура</p>
    </title>
    <p>Поскольку функции в Си нельзя определять внутри других функций, он не является языком, допускающим блочную структуру программы в том смысле, как это допускается в Паскале и подобных ему языках. Но переменные внутри функций можно определять в блочно-структурной манере. Объявления переменных (вместе с инициализацией) разрешено помещать не только в начале функции, но и после любой левой фигурной скобки, открывающей составную инструкцию. Переменная, описанная таким способом, "затеняет" переменные с тем же именем, расположенные в объемлющих блоках, и существует вплоть до соответствующей правой фигурной скобки. Например, в</p>
    <p><code>if (n › 0) {</code></p>
    <p><code> int i; /* описание новой переменной i */</code></p>
    <p><code> for (i = 0; i ‹ n; i++)</code></p>
    <p><code>  …</code></p>
    <p><code>}</code></p>
    <p>областью видимости переменной <emphasis>i</emphasis> является ветвь <emphasis>if</emphasis>, выполняемая при n›0; и эта переменная никакого отношения к любым <emphasis>i</emphasis>, расположенным вне данного блока, не имеет. Автоматические переменные, объявленные и инициализируемые в блоке, инициализируются каждый раз при входе в блок. Переменные <emphasis>static</emphasis> инициализируются только один раз при первом входе в блок.</p>
    <p>Автоматические переменные и формальные параметры также "затеняют" внешние переменные и функции с теми же именами. Например, в</p>
    <p><code>int x;</code></p>
    <p><code>int y;</code></p>
    <p><code>f(double х)</code></p>
    <p><code>{</code></p>
    <p><code> double y;</code></p>
    <p><code>}</code></p>
    <p><emphasis>x</emphasis> внутри функции <emphasis>f</emphasis> рассматривается как параметр типа <emphasis>double</emphasis>, в то время как вне <emphasis>f</emphasis> это внешняя переменная типа <emphasis>int</emphasis>. То же самое можно сказать и о переменной <emphasis>y</emphasis>.</p>
    <p>С точки зрения стиля программирования, лучше не пользоваться одними и теми же именами для разных переменных, поскольку слишком велика возможность путаницы и появления ошибок.</p>
   </section>
   <section>
    <title>
     <p>4.9 Инициализация</p>
    </title>
    <p>Мы уже много раз упоминали об инициализации, но всегда лишь по случаю, в ходе обсуждения других вопросов. В этом параграфе мы суммируем все правила, определяющие инициализацию памяти различных классов.</p>
    <p>При отсутствии явной инициализации для внешних и статических переменных гарантируется их обнуление; автоматические и регистровые переменные имеют неопределенные начальные значения ("мусор").</p>
    <p>Скалярные переменные можно инициализировать в их определениях, помещая после имени знак = и соответствующее выражение:</p>
    <p><code>int х = 1;</code></p>
    <p><code>char squote = '\'';</code></p>
    <p><code>long day = 1000L * 60L * 60L * 24L; /* день в миллисекундах */</code></p>
    <p>Для внешних и статических переменных инициализирующие выражения должны быть константными, при этом инициализация осуществляется только один раз до начала выполнения программы. Инициализация автоматических и регистровых переменных выполняется каждый раз при входе в функцию или блок. Для таких переменных инициализирующее выражение - не обязательно константное. Это может быть любое выражение, использующее ранее определенные значения, включая даже и вызовы функции. Например, в программе бинарного поиска, описанной в параграфе 3.3, инициализацию можно записать так:</p>
    <p><code>int binsearch(int х, int v[], int n)</code></p>
    <p><code>{</code></p>
    <p><code> int low = 0;</code></p>
    <p><code> int high = n-1;</code></p>
    <p><code> int mid;</code></p>
    <p><code>}</code></p>
    <p>а не так:</p>
    <p><code>int low, high, mid;</code></p>
    <empty-line/>
    <p><code>low = 0;</code></p>
    <p><code>high = n - 1;</code></p>
    <p>В сущности, инициализация автоматической переменной - это более короткая запись инструкции присваивания. Какая запись предпочтительнее - в большой степени дело вкуса. До сих пор мы пользовались главным образом явными присваиваниями, поскольку инициализация в объявлениях менее заметна и дальше отстоит от места использования переменной.</p>
    <p>Массив можно инициализировать в его определении с помощью заключенного в фигурные скобки списка инициализаторов, разделенных запятыми. Например, чтобы инициализировать массив <emphasis>days</emphasis>, элементы которого суть количества дней в каждом месяце, можно написать:</p>
    <p><code>int days[] = {31, 28, 31, 30, 31, 30, 31. 31, 30, 31, 30, 31};</code></p>
    <p>Если размер массива не указан, то длину массива компилятор вычисляет по числу заданных инициализаторов; в нашем случае их количество равно 12.</p>
    <p>Если количество инициализаторов меньше числа, указанного в определении длины массива, то для внешних, статических и автоматических переменных оставшиеся элементы будут нулевыми. Задание слишком большого числа инициализаторов считается ошибкой. В языке нет возможности ни задавать повторения инициализатора, ни инициализировать средние элементы массива без задания всех предшествующих значений. Инициализация символьных массивов - особый случай: вместо конструкции с фигурными скобками и запятыми можно использовать строку символов. Например, возможна такая запись:</p>
    <p><code>char pattern[] = "ould";</code></p>
    <p>представляющая собой более короткий эквивалент записи</p>
    <p><code>char pattern[] = {'о', 'u', 'l', 'd', '\0'};</code></p>
    <p>В данном случае размер массива равен пяти (четыре обычных символа и завершающий символ '\0').</p>
   </section>
   <section>
    <title>
     <p>4.10 Рекурсия</p>
    </title>
    <p>В Си допускается рекурсивное обращение к функциям, т. е. функция может обращаться сама к себе, прямо или косвенно. Рассмотрим печать числа в виде строки символов. Как мы упоминали ранее, цифры генерируются в обратном порядке - младшие цифры получаются раньше старших, а печататься они должны в правильной последовательности.</p>
    <p>Проблему можно решить двумя способами. Первый - запомнить цифры в некотором массиве в том порядке, как они получались, а затем напечатать их в обратном порядке; так это и было сделано в функции <emphasis>itoa</emphasis>, рассмотренной в параграфе 3.6. Второй способ - воспользоваться рекурсией, при которой <emphasis>printd</emphasis> сначала вызывает себя, чтобы напечатать все старшие цифры, и затем печатает последнюю младшую цифру. Эта программа, как и предыдущий ее вариант, при использовании самого большого по модулю отрицательного числа работает неправильно.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <empty-line/>
    <p><code>/* printd: печатает n как целое десятичное число */</code></p>
    <p><code>void printd(int n)</code></p>
    <p><code>{</code></p>
    <p><code> if (n ‹ 0) {</code></p>
    <p><code>  putchar('-');</code></p>
    <p><code>  n = -n;</code></p>
    <p><code> }</code></p>
    <p><code> if (n / 10)</code></p>
    <p><code>  printd(n / 10);</code></p>
    <p><code> putchar(n % 10 + '0');</code></p>
    <p><code>}</code></p>
    <p>Когда функция рекурсивно обращается сама к себе, каждое следующее обращение сопровождается получением ею нового полного набора автоматических переменных, независимых от предыдущих наборов. Так, в обращении <emphasis>printd(123)</emphasis> при первом вызове аргумент <emphasis>n = 123</emphasis>, при втором - <emphasis>printd</emphasis> получает аргумент 12, при третьем вызове - значение 1. Функция <emphasis>printd</emphasis> на третьем уровне вызова печатает 1 и возвращается на второй уровень, после чего печатает цифру 2 и возвращается на первый уровень. Здесь она печатает 3 и заканчивает работу.</p>
    <p>Следующий хороший пример рекурсии - это быстрая сортировка, предложенная Ч.А.Р. Хоаром в 1962 г. Для заданного массива выбирается один элемент, который разбивает остальные элементы на два подмножества - те, что меньше, и те, что не меньше него. Та же процедура рекурсивно применяется и к двум полученным подмножествам. Если в подмножестве менее двух элементов, то сортировать нечего, и рекурсия завершается.</p>
    <p>Наша версия быстрой сортировки, разумеется, не самая быстрая среди всех возможных, но зато одна из самых простых. В качестве делящего элемента мы используем серединный элемент.</p>
    <p><code>/* qsort: сортирует v[left]…v[right] по возрастанию */</code></p>
    <p><code>void qsort(int v[], int left, int right)</code></p>
    <p><code>{</code></p>
    <p><code> int i, last;</code></p>
    <p><code> void swap(int v[], int i, int j);</code></p>
    <empty-line/>
    <p><code> if (left ›= right) /* ничего не делается, если */</code></p>
    <p><code>  return; /* в массиве менее двух элементов */</code></p>
    <p><code> swap(v, left, (left + right)/2); /* делящий элемент */</code></p>
    <p><code> last = left; /* переносится в v[0] */</code></p>
    <p><code> for(i = left+1; i ‹= right; i++) /* деление на части */</code></p>
    <p><code>  if (v[i] ‹ v[left])</code></p>
    <p><code>   swap(v, ++last, i);</code></p>
    <p><code> swap(v, left, last); /* перезапоминаем делящий элемент */</code></p>
    <p><code> qsort(v, left, last-1);</code></p>
    <p><code> qsort(v, last+1, right);</code></p>
    <p><code>}</code></p>
    <p>В нашей программе операция перестановки оформлена в виде отдельной функции (<emphasis>swap</emphasis>), поскольку встречается в <emphasis>qsort</emphasis> трижды.</p>
    <p><code>/* swap: поменять местами v[i] и v[j] */</code></p>
    <p><code>void swap(int v[], int i, int j)</code></p>
    <p><code>{</code></p>
    <p><code> int temp;</code></p>
    <p><code> temp = v[i];</code></p>
    <p><code> v[i] = v[j];</code></p>
    <p><code> v[j] = temp;</code></p>
    <p><code>}</code></p>
    <p>Стандартная библиотека имеет функцию <strong>qsort</strong>, позволяющую сортировать объекты любого типа.</p>
    <p>Рекурсивная программа не обеспечивает ни экономии памяти, поскольку требуется где-то поддерживать стек значений, подлежащих обработке, ни быстродействия; но по сравнению со своим нерекурсивным эквивалентом она часто короче, а часто намного легче для написания и понимания. Такого рода программы особенно удобны для обработки рекурсивно определяемых структур данных вроде деревьев; с хорошим примером на эту тему вы познакомитесь в параграфе 6.5.</p>
    <p><strong>Упражнение 4.12</strong>. Примените идеи, которые мы использовали в <emphasis>printd</emphasis>, для написания рекурсивной версии функции <emphasis>itoa</emphasis>; иначе говоря, преобразуйте целое число в строку цифр с помощью рекурсивной программы.</p>
    <p><strong>Упражнение 4.13</strong>. Напишите рекурсивную версию функции <emphasis>reverse(s)</emphasis>, переставляющую элементы строки в ту же строку в обратном порядке.</p>
   </section>
   <section>
    <title>
     <p>4.11 Препроцессор языка Си</p>
    </title>
    <section>
     <p>Некоторые возможности языка Си обеспечиваются препроцессором, который работает на первом шаге компиляции. Наиболее часто используются две возможности: <strong>#include</strong>, вставляющая содержимое некоторого файла во время компиляции, и <strong>#define</strong>, заменяющая одни текстовые последовательности на другие. В этом параграфе обсуждаются условная компиляция и макроподстановка с аргументами.</p>
    </section>
    <section>
     <title>
      <p>4.11.1 Включение файла</p>
     </title>
     <p>Средство <emphasis>#include</emphasis> позволяет, в частности, легко манипулировать наборами <emphasis>#define</emphasis> и объявлений. Любая строка вида</p>
     <p><code>#include "<emphasis>имя-файла</emphasis>"</code></p>
     <p>или</p>
     <p><code>#include ‹<emphasis>имя-файла</emphasis>›</code></p>
     <p>заменяется содержимым файла с именем <emphasis>имя-файла</emphasis>. Если <emphasis>имя-файла</emphasis> заключено в двойные кавычки, то, как правило, файл ищется среди исходных файлов программы; если такового не оказалось или имя-файла заключено в угловые скобки ‹ и ›, то поиск осуществляется по определенным в реализации правилам. Включаемый файл сам может содержать в себе строки <emphasis>#include</emphasis>.</p>
     <p>Часто исходные файлы начинаются с нескольких строк <emphasis>#include</emphasis>, ссылающихся на общие инструкции <emphasis>#define</emphasis> и объявления <emphasis>extern</emphasis> или прототипы нужных библиотечных функций из заголовочных файлов вроде <emphasis>‹stdio.h›</emphasis>. (Строго говоря, эти включения не обязательно являются файлами; технические детали того, как осуществляется доступ к заголовкам, зависят от конкретной реализации.)</p>
     <p>Средство <emphasis>#include</emphasis> - хороший способ собрать вместе объявления большой программы. Он гарантирует, что все исходные файлы будут пользоваться одними и теми же определениями и объявлениями переменных, благодаря чему предотвращаются особенно неприятные ошибки. Естественно, при внесении изменений во включаемый файл все зависимые от него файлы должны перекомпилироваться.</p>
    </section>
    <section>
     <title>
      <p>4.11.2 Макроподстановка</p>
     </title>
     <p>Определение макроподстановки имеет вид:</p>
     <p><code>#define <emphasis>имя замещающий-текст</emphasis></code></p>
     <p>Макроподстановка используется для простейшей замены: во всех местах, где встречается лексема <emphasis>имя</emphasis>, вместо нее будет помещен <emphasis>замещающий-текст</emphasis>. Имена в <emphasis>#define</emphasis> задаются по тем же правилам, что и имена обычных переменных. Замещающий текст может быть произвольным. Обычно замещающий текст завершает строку, в которой расположено слово <emphasis>#define</emphasis>, но в длинных определениях его можно продолжить на следующих строках, поставив в конце каждой продолжаемой строки обратную наклонную черту \. Область видимости имени, определенного в <emphasis>#define</emphasis>, простирается от данного определения до конца файла. В определении макроподстановки могут фигурировать более ранние <emphasis>#define</emphasis>-определения. Подстановка осуществляется только для тех имен, которые расположены вне текстов, заключенных в кавычки. Например, если YES определено с помощью <emphasis>#define</emphasis>, то никакой подстановки в printf("YES") или в YESMAN выполнено не будет.</p>
     <p>Любое имя можно определить с произвольным замещающим текстом. Например:</p>
     <p><code>#define forever for(;;) /* бесконечный цикл */</code></p>
     <p>определяет новое слово <emphasis>forever</emphasis> для бесконечного цикла.</p>
     <p>Макроподстановку можно определить с аргументами, вследствие чего замещающий текст будет варьироваться в зависимости от задаваемых параметров. Например, определим <emphasis>max</emphasis> следующим образом:</p>
     <p><code>#define max(A, B) ((A) › (B) ? (A) : (B))</code></p>
     <p>Хотя обращения к <emphasis>max</emphasis> выглядят как обычные обращения к функции, они будут вызывать только текстовую замену. Каждый формальный параметр (в данном случае A и B) будет заменяться соответствующим ему аргументом. Так, строка</p>
     <p><code>x = max(p+q, r+s);</code></p>
     <p>будет заменена на строку</p>
     <p><code>x = ((p+q) › (r+s) ? (p+q) : (r+s));</code></p>
     <p>Поскольку аргументы допускают любой вид замены, указанное определение <emphasis>max</emphasis> подходит для данных любого типа, так что не нужно писать разные <emphasis>max</emphasis> для данных разных типов, как это было бы в случае задания с помощью функций.</p>
     <p>Если вы внимательно проанализируете работу <emphasis>max</emphasis>, то обнаружите некоторые подводные камни. Выражения вычисляются дважды, и если они вызывают побочный эффект (из-за инкрементных операций или функций ввода-вывода), это может привести к нежелательным последствиям. Например,</p>
     <p><code>max(i++, j++) /* НЕВЕРНО */</code></p>
     <p>вызовет увеличение <emphasis>i</emphasis> и <emphasis>j</emphasis> дважды. Кроме того, следует позаботиться о скобках, чтобы обеспечить нужный порядок вычислений. Задумайтесь, что случится, если при определении</p>
     <p><code>#define square(x) x*x /* НЕВЕРНО */</code></p>
     <p>вызвать <emphasis>square (z+1)</emphasis>.</p>
     <p>Тем не менее макросредства имеют свои достоинства. Практическим примером их использования является частое применение <emphasis>getchar</emphasis> и <emphasis>putchar</emphasis> из ‹stdio.h›, реализованных с помощью макросов, чтобы из6ежать расходов времени от вызова функции на каждый обрабатываемый символ. Функции в ‹ctype.h› обычно также реализуются с помощью макросов. Действие <emphasis>#define</emphasis> можно отменить с помощью <strong>#undef</strong>:</p>
     <p><code>#undef getchar</code></p>
     <p><code>int getchar(void) {…}</code></p>
     <p>Как правило, это делается, чтобы заменить макроопределение настоящей функцией с тем же именем.</p>
     <p>Имена формальных параметров не заменяются, если встречаются в заключенных в кавычки строках. Однако, если в замещающем тексте перед формальным параметром стоит знак <strong>#</strong>, этот параметр будет заменен на аргумент, заключенный в кавычки. Это может сочетаться с конкатенацией (склеиванием) строк, например, чтобы создать макрос отладочного вывода:</p>
     <p><code>#define dprint(expr) printf(#expr " = %g\n", expr)</code></p>
     <p>Обращение к</p>
     <p><code>dprint(x/y);</code></p>
     <p>развернется в</p>
     <p><code>printf("x/y" " = %g\n", x/y);</code></p>
     <p>а в результате конкатенации двух соседних строк получим</p>
     <p><code>printf("x/y=%g\n", x/y);</code></p>
     <p>Внутри фактического аргумента каждый знак " заменяется на \", а каждая \ на \\, так что результат подстановки приводит к правильной символьной константе.</p>
     <p>Оператор <strong>##</strong> позволяет в макрорасширениях конкатенировать аргументы. Если в замещающем тексте параметр соседствует с ##, то он заменяется соответствующим ему аргументом, а оператор ## и окружающие его символы-разделители выбрасываются. Например, в макроопределении <emphasis>paste</emphasis> конкатенируются два аргумента</p>
     <p><code>#define paste(front, back) front ## back</code></p>
     <p>так что <emphasis>paste(name, 1)</emphasis> сгенерирует имя <emphasis>name1</emphasis>.</p>
     <p>Правила вложенных использований оператора ## не определены; другие подробности, относящиеся к ##, можно найти в приложении A.</p>
     <p><strong>Упражнение 4.14</strong>. Определите swap(t,x,y) в виде макроса, который осуществляет обмен значениями указанного типа t между аргументами x и y. (Примените блочную структуру.)</p>
    </section>
    <section>
     <title>
      <p>4.11.3 Условная компиляция</p>
     </title>
     <p>Самим ходом препроцессирования можно управлять с помощью условных инструкций. Они представляют собой средство для выборочного включения того или иного текста программы в зависимости от значения условия, вычисляемого вовремя компиляции.</p>
     <p>Вычисляется константное целое выражение, заданное в строке <strong>#if</strong>. Это выражение не должно содержать ни одного оператора <strong>sizeof</strong> или приведения к типу и ни одной <strong>enum</strong>-константы. Если оно имеет ненулевое значение, то будут включены все последующие строки вплоть до <strong>#endif</strong>, или <strong>#elif</strong>, или <strong>#else</strong>. (Инструкция препроцессора <strong>#elif</strong> похожа на else if.) Выражение <strong>defined</strong>(<emphasis>имя</emphasis>) в <strong>#if</strong> есть 1, если <emphasis>имя</emphasis> было определено, и 0 в противном случае.</p>
     <p>Например, чтобы застраховаться от повторного включения заголовочного файла <emphasis>hdr.h</emphasis>, его можно оформить следующим образом:</p>
     <p><code>#if !defined(HDR)</code></p>
     <p><code>#define HDR</code></p>
     <empty-line/>
     <p><code>/* здесь содержимое hdr.h */</code></p>
     <empty-line/>
     <p><code>#endif</code></p>
     <p>При первом включении файла <emphasis>hdr.h</emphasis> будет определено имя <emphasis>HDR</emphasis>, а при последующих включениях препроцессор обнаружит, что имя <emphasis>HDR</emphasis> уже определено, и перескочит сразу на <emphasis>#endif</emphasis>. Этот прием может оказаться полезным, когда нужно избежать многократного включения одного и того же файла. Если им пользоваться систематически, то в результате каждый заголовочный файл будет сам включать заголовочные файлы, от которых он зависит, освободив от этого занятия пользователя.</p>
     <p>Вот пример цепочки проверок имени <emphasis>SYSTEM</emphasis>, позволяющей выбрать нужный файл для включения:</p>
     <p><code>#if SYSTEM == SYSV</code></p>
     <p><code> #define HDR "sysv.h"</code></p>
     <p><code>#elif SYSTEM == BSD</code></p>
     <p><code> #define HDR "bsd.h"</code></p>
     <p><code>#elif SYSTEM == MSDOS</code></p>
     <p><code> #define HDR "msdos.h"</code></p>
     <p><code>#else</code></p>
     <p><code> #define HDR "default.h"</code></p>
     <p><code>#endif</code></p>
     <p><code>#include HDR</code></p>
     <p>Инструкции <strong>#ifdef</strong> и <strong>#ifndef</strong> специально предназначены для проверки того, определено или нет заданное в них имя. И следовательно, первый пример, приведенный выше для иллюстрации <strong>#if</strong>, можно записать и в таком виде:</p>
     <p><code>#ifndef HDR</code></p>
     <p><code>#define HDR</code></p>
     <empty-line/>
     <p><code>/* здесь содержимое hdr.h */</code></p>
     <empty-line/>
     <p><code>#endif</code></p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>Глава 5. Указатели и массивы</p>
   </title>
   <section>
    <p><strong>Указатель</strong> - это переменная, содержащая адрес переменной. Указатели широко применяются в Си - отчасти потому, что в некоторых случаях без них просто не обойтись, а отчасти потому, что программы с ними обычно короче и эффективнее. Указатели и <strong>массивы</strong> тесно связаны друг с другом: в данной главе мы рассмотрим эту зависимость и покажем, как ею пользоваться. Наряду с <emphasis>goto</emphasis> указатели когда-то были объявлены лучшим средством для написания малопонятных программ. Так оно и есть, если ими пользоваться бездумно. Ведь очень легко получить указатель, указывающий на что-нибудь совсем нежелательное. При соблюдении же определенной дисциплины с помощью указателей можно достичь ясности и простоты. Мы попытаемся убедить вас в этом.</p>
    <p>Изменения, внесенные стандартом ANSI, связаны в основном с формулированием точных правил, как работать с указателями. Стандарт узаконил накопленный положительный опыт программистов и удачные нововведения разработчиков компиляторов. Кроме того, взамен <emphasis>char*</emphasis> в качестве типа обобщенного указателя предлагается тип <emphasis>void*</emphasis> (указатель на void).</p>
   </section>
   <section>
    <title>
     <p>5.1 Указатели и адреса</p>
    </title>
    <p>Начнем с того, что рассмотрим упрощенную схему организации памяти. Память типичной машины подставляет собой массив последовательно пронумерованных или проадресованных ячеек, с которыми можно работать по отдельности или связными кусками. Применительно к любой машине верны следующие утверждения: один байт может хранить значение типа <emphasis>char</emphasis>, двухбайтовые ячейки могут рассматриваться как целое типа <emphasis>short</emphasis>, а четырехбайтовые - как целые типа <emphasis>long</emphasis>. Указатель - это группа ячеек (как правило, две или четыре), в которых может храниться адрес. Так, если c имеет тип <emphasis>char</emphasis>, а <emphasis>p</emphasis> - указатель на <emphasis>c</emphasis>, то ситуация выглядит следующим образом:</p>
    <image l:href="#pic_1.png"/>
    <p>Унарный оператор <strong>&amp;</strong> выдает адрес объекта, так что инструкция</p>
    <p><code>p =&amp;c;</code></p>
    <p>присваивает переменной <emphasis>p</emphasis> адрес ячейки <emphasis>c</emphasis> (говорят, что <emphasis>p</emphasis> указывает на <emphasis>c</emphasis>). Оператор <strong>&amp;</strong> применяется только к объектам, расположенным в памяти: к переменным и элементам массивов. Его операндом не может быть ни выражение, ни константа, ни регистровая переменная.</p>
    <p>Унарный оператор <strong>*</strong> есть оператор <emphasis>косвенного доступа</emphasis>. Примененный к указателю он выдает объект, на который данный указатель указывает. Предположим, что <emphasis>x</emphasis> и <emphasis>y</emphasis> имеют тип <emphasis>int</emphasis>, а <emphasis>ip</emphasis> - укаэатель на <emphasis>int</emphasis>. Следующие несколько строк придуманы специально для того, чтобы показать, каким образом объявляются указатели и как используются операторы <strong>&amp;</strong> и <strong>*</strong>.</p>
    <p><code>int х = 1, у = 2, z[10];</code></p>
    <p><code>int *ip; /* ip - указатель на int */</code></p>
    <empty-line/>
    <p><code>ip = &amp;x; /* теперь ip указывает на x */</code></p>
    <p><code>y = *ip; /* y теперь равен 1 */</code></p>
    <p><code>*ip = 0; /* x теперь равен 0 */</code></p>
    <p><code>ip = &amp;z[0]; /* ip теперь указывает на z[0] */</code></p>
    <p>Объявления <emphasis>x</emphasis>, <emphasis>y</emphasis> и <emphasis>z</emphasis> нам уже знакомы. Объявление указателя <emphasis>ip</emphasis></p>
    <p><code>int *ip;</code></p>
    <p>мы стремились сделать мнемоничным - оно гласит: "выражение <emphasis>*ip</emphasis> имеет тип <emphasis>int</emphasis>". Синтаксис объявления переменной "подстраивается" под синтаксис выражений, в которых эта переменная может встретиться. Указанный принцип применим и в объявлениях функций. Например, запись</p>
    <p><code>double *dp, atof (char *);</code></p>
    <p>означает, что выражения <emphasis>*dp</emphasis> и <emphasis>atof(s)</emphasis> имеют тип <emphasis>double</emphasis>, а аргумент функции <emphasis>atof</emphasis> есть указатель на <emphasis>char</emphasis>.</p>
    <p>Вы, наверное, заметили, что указателю разрешено указывать только на объекты определенного типа. (Существует одно исключение: "указатель на <emphasis>void</emphasis>" может указывать на объекты любого типа, но к такому указателю нельзя применять оператор косвенного доступа. Мы вернемся к этому в параграфе 5.11.)</p>
    <p>Если <emphasis>ip</emphasis> указывает на <emphasis>x</emphasis> целочисленного типа, то <emphasis>*ip</emphasis> можно использовать в любом месте, где допустимо применение <emphasis>x</emphasis>; например,</p>
    <p><code>*ip = *ip + 10;</code></p>
    <p>увеличивает <emphasis>*ip</emphasis> на 10.</p>
    <p>Унарные операторы <strong>*</strong> и <strong>&amp;</strong> имеют более высокий приоритет, чем арифметические операторы, так что присваивание</p>
    <p><code>y = *ip + 1;</code></p>
    <p>берет то, на что указывает <emphasis>ip</emphasis>, и добавляет к нему 1, а результат присваивает переменной <emphasis>y</emphasis>. Аналогично</p>
    <p><code>*ip += 1;</code></p>
    <p>увеличивает на единицу то, на что указывает <emphasis>ip</emphasis>; те же действия выполняют</p>
    <p><code>++*ip;</code></p>
    <p>и</p>
    <p><code>(*iр)++;</code></p>
    <p>В последней записи скобки необходимы, поскольку если их не будет, увеличится значение самого указателя, а не то, на что он указывает. Это обусловлено тем, что унарные операторы <strong>*</strong> и <strong>++</strong> имеют одинаковый приоритет и порядок выполнения - справа налево.</p>
    <p>И наконец, так как указатели сами являются переменными, в тексте они могут встречаться и без оператора косвенного доступа. Например, если <emphasis>iq</emphasis> есть другой указатель на <emphasis>int</emphasis>, то</p>
    <p><code>iq = ip;</code></p>
    <p>копирует содержимое <emphasis>ip</emphasis> в <emphasis>iq</emphasis>, чтобы <emphasis>ip</emphasis> и <emphasis>iq</emphasis> указывали на один и тот же объект.</p>
   </section>
   <section>
    <title>
     <p>5.2 Указатели и аргументы функций</p>
    </title>
    <p>Поскольку в Си функции в качестве своих аргументов получают значения параметров, нет прямой возможности, находясь в вызванной функции, изменить переменную вызывающей функции. В программе сортировки нам понадобилась функция <emphasis>swap</emphasis>, меняющая местами два неупорядоченных элемента. Однако недостаточно написать</p>
    <p><code>swap(a, b);</code></p>
    <p>где функция <emphasis>swap</emphasis> определена следующим образом:</p>
    <p><code>void swap(int х, int у) /* НЕВЕРНО */</code></p>
    <p><code>{</code></p>
    <p><code> int temp;</code></p>
    <p><code> temp = х;</code></p>
    <p><code> x = y;</code></p>
    <p><code> у = temp;</code></p>
    <p><code>}</code></p>
    <p>Поскольку <emphasis>swap</emphasis> получает лишь копии переменных <emphasis>a</emphasis> и <emphasis>b</emphasis>, она не может повлиять на переменные <emphasis>a</emphasis> и <emphasis>b</emphasis> той программы, которая к ней обратилась. Чтобы получить желаемый эффект, вызывающей программе надо передать указатели на те значения, которые должны быть изменены:</p>
    <p><code>swap(&amp;a, &amp;b);</code></p>
    <p>Так как оператор <strong>&amp;</strong> получает адрес переменной, <emphasis>&amp;a</emphasis> есть указатель на <emphasis>a</emphasis>. В самой же функции <emphasis>swap</emphasis> параметры должны быть объявлены как указатели, при этом доступ к значениям параметров будет осуществляться косвенно.</p>
    <p><code>void swap(int *px, int *py) /* перестановка *px и *py */</code></p>
    <p><code>{</code></p>
    <p><code> int temp;</code></p>
    <p><code> temp = *рх;</code></p>
    <p><code> *рх = *py;</code></p>
    <p><code> *ру = temp;</code></p>
    <p><code>}</code></p>
    <p>Графически это выглядит следующим образом: в вызывающей программе:</p>
    <image l:href="#fig5_2.jpg"/>
    <p>Аргументы-указатели позволяют функции осуществлять доступ к объектам вызвавшей ее программы и дают возможность изменить эти объекты. Рассмотрим, например, функцию <emphasis>getint</emphasis>, которая осуществляет ввод в свободном формате одного целого числа и его перевод из текстового представления в значение типа <emphasis>int</emphasis>. Функция <emphasis>getint</emphasis> должна возвращать значение полученного числа или сигнализировать значением EOF о конце файла, если входной поток исчерпан. Эти значения должны возвращаться по разным каналам, так как нельзя рассчитывать на то, что полученное в результате перевода число никогда не совпадет с EOF.</p>
    <p>Одно из решений состоит в том, чтобы <emphasis>getint</emphasis> выдавала характеристику состояния файла (исчерпан или не исчерпан) в качестве результата, а значение самого числа помещала согласно указателю, переданному ей в виде аргумента. Похожая схема действует и в программе <emphasis>scanf</emphasis>, которую мы рассмотрим в параграфе 7.4. Показанный ниже цикл заполняет некоторый массив целыми числами, полученными с помощью <emphasis>getint</emphasis>.</p>
    <p><code>int n, array[SIZE], getint (int *);</code></p>
    <empty-line/>
    <p><code>for (n = 0; n ‹ SIZE &amp;&amp; getint (&amp;array[n]) != EOF; n++)</code></p>
    <p><code> ;</code></p>
    <p>Результат каждого очередного обращения к <emphasis>getint</emphasis> посылается в <emphasis>array[n]</emphasis>, и <emphasis>n</emphasis> увеличивается на единицу. Заметим, и это существенно, что функции <emphasis>getint</emphasis> передается адрес элемента <emphasis>array[n]</emphasis>. Если этого не сделать, у <emphasis>getint</emphasis> не будет способа вернуть в вызывающую программу переведенное целое число.</p>
    <p>В предлагаемом нами варианте функция <emphasis>getint</emphasis> возвращает EOF по концу файла; нуль, если следующие вводимые символы не представляют собою числа; и положительное значение, если введенные символы представляют собой число.</p>
    <p><code>#include ‹ctype.h›</code></p>
    <empty-line/>
    <p><code>int getch (void);</code></p>
    <p><code>void ungetch (int);</code></p>
    <empty-line/>
    <p><code>/* getint: читает следующее целое из ввода в *pn */</code></p>
    <p><code>int getint(int *pn)</code></p>
    <p><code>{</code></p>
    <p><code>int c, sign;</code></p>
    <empty-line/>
    <p><code>while (isspace(c = getch()))</code></p>
    <p><code> ; /* пропуск символов-разделителей */</code></p>
    <empty-line/>
    <p><code> if (!isdigit(c) &amp;&amp; c != EOF &amp;&amp; c != '+ '&amp;&amp; c != '-') {</code></p>
    <p><code>  ungetch (c); /* не число */</code></p>
    <p><code>  return 0;</code></p>
    <p><code> }</code></p>
    <p><code> sign = (c == '-') ? -1 : 1;</code></p>
    <p><code> if (с == '+' || с == '-')</code></p>
    <p><code>  с = getch();</code></p>
    <p><code> for (*pn = 0; isdigit(c); c = getch())</code></p>
    <p><code>  *pn = 10 * *pn + (c -'0');</code></p>
    <p><code> *pn *= sign;</code></p>
    <p><code> if (c != EOF)</code></p>
    <p><code>  ungetch(c);</code></p>
    <p><code> return c;</code></p>
    <p><code>}</code></p>
    <p>Везде в <emphasis>getint</emphasis> под <emphasis>*pn</emphasis> подразумевается обычная переменная типа <emphasis>int</emphasis>. Функция <emphasis>ungetch</emphasis> вместе с <emphasis>getch</emphasis> (параграф 4.3) включена в программу, чтобы обеспечить возможность отослать назад лишний прочитанный символ.</p>
    <p><strong>Упражнение 5.1</strong>. Функция <emphasis>getint</emphasis> написана так, что знаки - или +, за которыми не следует цифра, она понимает как "правильное" представление нуля. Скорректируйте программу таким образом, чтобы в подобных случаях она возвращала прочитанный знак назад во ввод.</p>
    <p><strong>Упражнение 5.2</strong>. Напишите функцию <emphasis>getfloat</emphasis> - аналог <emphasis>getint</emphasis> для чисел с плавающей точкой. Какой тип будет иметь результирующее значение, задаваемое функцией <emphasis>getfloat</emphasis>?</p>
   </section>
   <section>
    <title>
     <p>5.3 Указатели и массивы</p>
    </title>
    <p>В Си существует связь между указателями и массивами, и связь эта настолько тесная, что эти средства лучше рассматривать вместе. Любой доступ к элементу массива, осуществляемый операцией индексирования, может быть выполнен с помощью указателя. Вариант с указателями в общем случае работает быстрее, но разобраться в нем, особенно непосвященному, довольно трудно.</p>
    <p>Объявление</p>
    <p><code>int a[10];</code></p>
    <p>Определяет массив <emphasis>a</emphasis> размера 10, т. е. блок из 10 последовательных объектов с именами a[0], a[1],…, a[9].</p>
    <image l:href="#pic_3.jpg"/>
    <p>Запись <emphasis>a[i]</emphasis> отсылает нас к <emphasis>i</emphasis>-му элементу массива. Если <emphasis>pa</emphasis> есть указатель на <emphasis>int</emphasis>, т. е. объявлен как</p>
    <p><code>int *pa;</code></p>
    <p>то в результате присваивания</p>
    <p><code>pa =&amp;a[0];</code></p>
    <p><emphasis>pa</emphasis> будет указывать на нулевой элемент <emphasis>a</emphasis>, иначе говоря, <emphasis>pa</emphasis> будет содержать адрес элемента <emphasis>a[0]</emphasis>.</p>
    <p>Теперь присваивание</p>
    <p><code>x = *pa;</code></p>
    <p>будет копировать содержимое <emphasis>a[0]</emphasis> в <emphasis>x</emphasis>.</p>
    <p>Если <emphasis>pa</emphasis> указывает на некоторый элемент массива, то <emphasis>pa+1</emphasis> по определению указывает на следующий элемент, <emphasis>pa+i</emphasis> - на <emphasis>i</emphasis>-й элемент после <emphasis>pa</emphasis>, a <emphasis>pa-i</emphasis> - на <emphasis>i</emphasis>-й элемент перед <emphasis>pa</emphasis>. Таким образом, если <emphasis>pa</emphasis> указывает на <emphasis>a[0]</emphasis>, то</p>
    <p><code>*(pa+1)</code></p>
    <p>есть содержимое <emphasis>a[1]</emphasis>, <emphasis>a+i</emphasis> - адрес <emphasis>a[i]</emphasis>, a <emphasis>*(pa+i)</emphasis> - содержимое <emphasis>a[i]</emphasis>.</p>
    <image l:href="#pic_4.jpg"/>
    <p>Сделанные замечания верны безотносительно к типу и размеру элементов массива <emphasis>a</emphasis>. Смысл слов "добавить 1 к указателю", как и смысл любой арифметики с указателями, состоит в том, чтобы <emphasis>pa+1</emphasis> указывал на следующий объект, a <emphasis>pa+i</emphasis> - на <emphasis>i</emphasis>-й после <emphasis>pa</emphasis>.</p>
    <p>Между индексированием и арифметикой с указателями существует очень тесная связь. По определению значение переменной или выражения типа массив есть адрес нулевого элемента массива. После присваивания</p>
    <p><code>pa =&amp;a[0];</code></p>
    <p><emphasis>ра</emphasis> и <emphasis>a</emphasis> имеют одно и то же значение. Поскольку имя массива является синонимом расположения его начального элемента, присваивание <emphasis>pa=&amp;a[0]</emphasis> можно также записать в следующем виде:</p>
    <p><code>pa = a;</code></p>
    <p>Еще более удивительно (по крайней мере на первый взгляд) то, что <emphasis>a[i]</emphasis> можно записать как <emphasis>*(a+i)</emphasis>. Вычисляя <emphasis>a[i]</emphasis>, Си сразу преобразует его в <emphasis>*(a+i)</emphasis>; указанные две формы записи эквивалентны. Из этого следует, что полученные в результате применения оператора <emphasis>&amp;</emphasis> записи <emphasis>&amp;a[i]</emphasis> и <emphasis>a+i</emphasis> также будут эквивалентными, т. е. и в том и в другом случае это адрес <emphasis>i</emphasis>-го элемента после <emphasis>a</emphasis>. С другой стороны, если <emphasis>pa</emphasis> - указатель, то его можно использовать с индексом, т. е. запись <emphasis>pa[i]</emphasis> эквивалентна записи <emphasis>*(pa+i)</emphasis>. Короче говоря, элемент массива можно изображать как в виде указателя со смещением, так и в виде имени массива с индексом.</p>
    <p>Между именем массива и указателем, выступающим в роли имени массива, существует одно различие. <emphasis>Указатель - это переменная</emphasis>, поэтому можно написать <emphasis>pa=a</emphasis> или <emphasis>pa++</emphasis>. Но <emphasis>имя массива не является переменной</emphasis>, и записи вроде <emphasis>a=pa</emphasis> или <emphasis>a++</emphasis> не допускаются.</p>
    <p>Если имя массива передается функции, то последняя получает в качестве аргумента адрес его начального элемента. Внутри вызываемой функции этот аргумент является локальной переменной, содержащей адрес. Мы можем воспользоваться отмеченным фактом и написать еще одну версию функции <emphasis>strlen</emphasis>, вычисляющей длину строки.</p>
    <p><code>/* strlen: возвращает длину строки */</code></p>
    <p><code>int strlen(char *s)</code></p>
    <p><code>{</code></p>
    <p><code> int n;</code></p>
    <p><code> for (n = 0; *s!= '\0'; s++)</code></p>
    <p><code>  n++;</code></p>
    <p><code> return n;</code></p>
    <p><code>}</code></p>
    <p>Так как переменная <emphasis>s</emphasis> - указатель, к ней применима операция ++; <emphasis>s++</emphasis> не оказывает никакого влияния на строку символов функции, которая обратилась к <emphasis>strlen</emphasis>. Просто увеличивается на 1 некоторая копия указателя, находящаяся в личном пользовании функции <emphasis>strlen</emphasis>. Это значит, что все вызовы, такие как:</p>
    <p><code>strlen("3дравствуй, мир"); /* строковая константа */</code></p>
    <p><code>strlen(array); /* char array[100]; */</code></p>
    <p><code>strlen(ptr); /* char *ptr; */</code></p>
    <p>правомерны.</p>
    <p>Формальные параметры</p>
    <p><code>char s[];</code></p>
    <p>и</p>
    <p><code>char *s;</code></p>
    <p>в определении функции эквивалентны. Мы отдаем предпочтение последнему варианту, поскольку он более явно сообщает, что <emphasis>s</emphasis> есть указатель. Если функции в качестве аргумента передается имя массива, то она может рассматривать его так, как ей удобно - либо как имя массива, либо как указатель, и поступать с ним соответственно. Она может даже использовать оба вида записи, если это покажется уместным и понятным.</p>
    <p>Функции можно передать часть массива, для этого аргумент должен указывать на начало подмассива. Например, если <emphasis>a</emphasis> - массив, то в записях</p>
    <p><code>f(&amp;a[2])</code></p>
    <p>или</p>
    <p><code>f(a+2)</code></p>
    <p>функции <emphasis>f</emphasis> передается адрес подмассива, начинающегося с элемента <emphasis>a[2]</emphasis>. Внутри функции <emphasis>f</emphasis> описание параметров может выглядеть как</p>
    <p><code>f(int arr[]) {…}</code></p>
    <p>или</p>
    <p><code>f(int *arr) {…}</code></p>
    <p>Следовательно, для <emphasis>f</emphasis> тот факт, что параметр указывает на часть массива, а не на весь массив, не имеет значения.</p>
    <p>Если есть уверенность, что элементы массива существуют, то возможно индексирование и в "обратную" сторону по отношению к нулевому элементу; выражения <emphasis>p[-1]</emphasis>, <emphasis>p[-2]</emphasis> и т.д. не противоречат синтаксису языка и обращаются к элементам, стоящим непосредственно перед <emphasis>p[0]</emphasis>. Разумеется, нельзя "выходить" за границы массива и тем самым обращаться к несуществующим объектам.</p>
   </section>
   <section>
    <title>
     <p>5.4 Адресная арифметика</p>
    </title>
    <p>Если <emphasis>p</emphasis> есть указатель на некоторый элемент массива, то <emphasis>p++</emphasis> увеличивает <emphasis>p</emphasis> так, чтобы он указывал на следующий элемент, а <emphasis>p+=i</emphasis> увеличивает его, чтобы он указывал на <emphasis>i</emphasis>-й элемент после того, на который указывал ранее. Эти и подобные конструкции - самые простые примеры арифметики над указателями, называемой также адресной арифметикой.</p>
    <p>Си последователен и единообразен в своем подходе к адресной арифметике. Это соединение в одном языке указателей, массивов и адресной арифметики - одна из сильных его сторон. Проиллюстрируем сказанное построением простого распределителя памяти, состоящего из двух программ. Первая, <emphasis>alloc(n)</emphasis>, возвращает указатель <emphasis>p</emphasis> на <emphasis>n</emphasis> последовательно расположенных ячеек типа <emphasis>char</emphasis>; программой, обращающейся к <emphasis>alloc</emphasis>, эти ячейки могут быть использованы для запоминания символов. Вторая, <emphasis>afree(p)</emphasis>, освобождает память для, возможно, повторной ее утилизации. Простота алгоритма обусловлена предположением, что обращения к <emphasis>afree</emphasis> делаются в обратном порядке по отношению к соответствующим обращениям к <emphasis>alloc</emphasis>. Таким образом, память, с которой работают <emphasis>alloc</emphasis> и <emphasis>afree</emphasis>, является стеком (списком, в основе которого лежит принцип "последним вошел, первым ушел"). В стандартной библиотеке имеются функции <strong>malloc</strong> и <strong>free</strong>, которые делают то же самое, только без упомянутых ограничений: в параграфе 8.7 мы покажем, как они выглядят.</p>
    <p>Функцию <emphasis>alloc</emphasis> легче всего реализовать, если условиться, что она будет выдавать куски некоторого большого массива типа <emphasis>char</emphasis>, который мы назовем <emphasis>allocbuf</emphasis>. Этот массив отдадим в личное пользование функциям <emphasis>alloc</emphasis> и <emphasis>afree</emphasis>. Так как они имеют дело с указателями, а не с индексами массива, то другим программам знать его имя не нужно. Кроме того, этот массив можно определить в том же исходном файле, что и <emphasis>alloc</emphasis> и <emphasis>afree</emphasis>, объявив его <emphasis>static</emphasis>, благодаря чему он станет невидимым вне этого файла. На практике такой массив может и вовсе не иметь имени, поскольку его можно запросить с помощью <emphasis>malloc</emphasis> у операционной системы и получить указатель на некоторый безымянный блок памяти.</p>
    <p>Естественно, нам нужно знать, сколько элементов массива <emphasis>allocbuf</emphasis> уже занято. Мы введем указатель <emphasis>allocp</emphasis>, который будет указывать на первый свободный элемент. Если запрашивается память для <emphasis>n</emphasis> символов, то <emphasis>alloc</emphasis> возвращает текущее значение <emphasis>allocp</emphasis> (т. е. адрес начала свободного блока) и затем увеличивает его на <emphasis>n</emphasis>, чтобы указатель <emphasis>allocp</emphasis> указывал на следующую свободную область. Если же пространства нет, то <emphasis>alloc</emphasis> выдает нуль. Функция <emphasis>afree(p)</emphasis> просто устанавливает <emphasis>allocp</emphasis> в значение <emphasis>p</emphasis>, если оно не выходит за пределы массива <emphasis>allocbuf</emphasis>.</p>
    <p>Перед вызовом <emphasis>allос</emphasis>:</p>
    <image l:href="#pic_5.jpg"/>
    <p>После вызова <emphasis>alloc</emphasis>:</p>
    <image l:href="#pic_6.jpg"/>
    <p><code>#define ALLOCSIZE 10000 /* размер доступного пространства */</code></p>
    <empty-line/>
    <p><code>static char allocbuf[ALLOCSIZE]; /* память для alloc */</code></p>
    <p><code>static char *allocp = allocbuf; /* указатель на своб. место */</code></p>
    <empty-line/>
    <p><code>char *alloc(int n) /* возвращает указатель на n символов */</code></p>
    <p><code>{</code></p>
    <p><code> if (allocbuf + ALLOCSIZE - allocp ›= n) {</code></p>
    <p><code> allocp += n; /* пространство есть */</code></p>
    <p><code> return allocp - n; /* старое p */</code></p>
    <p><code>} else /* пространства нет */</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>void afree(char *p) /* освобождает память, на которую указывает p */</code></p>
    <p><code>{</code></p>
    <p><code> if (р ›= allocbuf &amp;&amp; p ‹ allocbuf + ALLOCSIZE)</code></p>
    <p><code> allocp = p;</code></p>
    <p><code>}</code></p>
    <p>В общем случае указатель, как и любую другую переменную, можно инициализировать, но только такими осмысленными для него значениями, как нуль или выражение, приводящее к адресу ранее определенных данных соответствующего типа. Объявление</p>
    <p><code>static char *allocp = allocbuf;</code></p>
    <p>определяет <emphasis>allocp</emphasis> как указатель на <emphasis>char</emphasis> и инициализирует его адресом массива <emphasis>allocbuf</emphasis>, поскольку перед началом работы программы массив <emphasis>allocbuf</emphasis> пуст. Указанное объявление могло бы иметь и такой вид:</p>
    <p><code>static char *allocp = &amp;allocbuf[0];</code></p>
    <p>поскольку имя массива и есть адрес его нулевого элемента. Проверка</p>
    <p><code>if (allocbuf + ALLOCSIZE - allocp ›= n) {/* годится */</code></p>
    <p>контролирует, достаточно ли пространства, чтобы удовлетворить запрос на <emphasis>n</emphasis> символов. Если памяти достаточно, то новое значение для <emphasis>allocp</emphasis> должно указывать не далее чем на следующую позицию за последним элементом <emphasis>allocbuf</emphasis>. При выполнении этого требования <emphasis>alloc</emphasis> выдает указатель на начало выделенного блока символов (обратите внимание на объявление типа самой функции). Если требование не выполняется, функция <emphasis>alloc</emphasis> должна выдать какой-то сигнал о том, что памяти не хватает. Си гарантирует, что нуль никогда не будет правильным адресом для данных, поэтому мы будем использовать его в качестве признака аварийного события, в нашем случае нехватки памяти.</p>
    <p>Указатели и целые не являются взаимозаменяемыми объектами. Константа нуль - единственное исключение из этого правила: ее можно присвоить указателю, и указатель можно сравнить с нулевой константой. Чтобы показать, что нуль - это специальное значение для указателя, вместо цифры нуль, как правило, записывают <strong>NULL</strong> - константу, определенную в файле ‹stdio.h› (I.B.: вообще-то эта константа определена в ‹stddef.h› или ‹string.h›). С этого момента и мы будем ею пользоваться. Проверки</p>
    <p><code>if (allocbuf + ALLOCSIZE - allocp ›= n) {/* годится */</code></p>
    <p>и</p>
    <p><code>if (p ›= allocbuf &amp;&amp; p ‹ allocbuf + ALLOCSIZE)</code></p>
    <p>демонстрируют несколько важных свойств арифметики с указателями. Во- первых, при соблюдении некоторых правил указатели можно сравнивать.</p>
    <p>Если <emphasis>p</emphasis> и <emphasis>q</emphasis> указывают на элементы одного массива, то к ним можно применять операторы отношения <strong>==</strong>, <strong>!=</strong>, <strong>‹</strong>, <strong>›=</strong> и т. д. Например, отношение вида</p>
    <p><code>p ‹ q</code></p>
    <p>истинно, если <emphasis>p</emphasis> указывает на более ранний элемент массива, чем <emphasis>q</emphasis>. Любой указатель всегда можно сравнить на равенство и неравенство с нулем. А вот для указателей, не указывающих на элементы одного массива, результат арифметических операций или сравнений не определен. (Существует одно исключение: в арифметике с указателями можно использовать адрес несуществующего "следующего за массивом" элемента, т. е. адрес того "элемента", который станет последним, если в массив добавить еще один элемент.)</p>
    <p>Во-вторых, как вы уже, наверное, заметили, указатели и целые можно складывать и вычитать. Конструкция</p>
    <p><code>p + n</code></p>
    <p>означает адрес объекта, занимающего <emphasis>n</emphasis>-е место после объекта, на который указывает <emphasis>p</emphasis>. Это справедливо безотносительно к типу объекта, на который указывает <emphasis>p</emphasis>; <emphasis>n</emphasis> автоматически домножается на коэффициент, соответствующий размеру объекта. Информация о размере неявно присутствует в объявлении <emphasis>p</emphasis>. Если, к примеру, <emphasis>int</emphasis> занимает четыре байта, то коэффициент умножения будет равен четырем.</p>
    <p>Допускается также вычитание указателей. Например, если <emphasis>p</emphasis> и <emphasis>q</emphasis> указывают на элементы одного массива и <emphasis>p‹q</emphasis>, то <emphasis>q-p+1</emphasis> есть число элементов от <emphasis>p</emphasis> до <emphasis>q</emphasis> включительно. Этим фактом можно воспользоваться при написании еще одной версии <emphasis>strlen</emphasis>:</p>
    <p><code>/* strlen: возвращает длину строки s */</code></p>
    <p><code>int strlen(char *s)</code></p>
    <p><code>{</code></p>
    <p><code> char *p = s;</code></p>
    <p><code> while (*p != '\0')</code></p>
    <p><code>  p++;</code></p>
    <p><code> return p - s;</code></p>
    <p><code>}</code></p>
    <p>В своем объявлении <emphasis>p</emphasis> инициализируется значением <emphasis>s</emphasis>, т. е. вначале <emphasis>p</emphasis> указывает на первый символ строки. На каждом шаге цикла <emphasis>while</emphasis> проверяется очередной символ; цикл продолжается до тех пор, пока не встретится '\0'. Каждое продвижение указателя <emphasis>p</emphasis> на следующий символ выполняется инструкцией <emphasis>p++</emphasis>, и разность <emphasis>p-s</emphasis> дает число пройденных символов, т. е. длину строки. (Число символов в строке может быть слишком большим, чтобы хранить его в переменной типа <emphasis>int</emphasis>. Тип <strong>ptrdiff_t</strong>, достаточный для хранения разности (со знаком) двух указателей, определен в заголовочном файле <strong>‹stddef.h›</strong>. Однако, если быть очень осторожными, нам следовало бы для возвращаемого результата использовать тип <emphasis>size_t</emphasis>, в этом случае наша программа соответствовала бы стандартной библиотечной версии. Тип <strong>size_t</strong> есть тип беззнакового целого, возвращаемого оператором <strong>sizeof</strong>.</p>
    <p>Арифметика с указателями учитывает тип: если она имеет дело со значениями <emphasis>float</emphasis>, занимающими больше памяти, чем <emphasis>char</emphasis>, и <emphasis>p</emphasis> - указатель на <emphasis>float</emphasis>, то <emphasis>p++</emphasis> продвинет <emphasis>p</emphasis> на следующее значение <emphasis>float</emphasis>. Это значит, что другую версию <emphasis>alloc</emphasis>, которая имеет дело с элементами типа <emphasis>float</emphasis>, а не <emphasis>char</emphasis>, можно получить простой заменой в <emphasis>alloc</emphasis> и <emphasis>afree</emphasis> всех <emphasis>char</emphasis> на <emphasis>float</emphasis>. Все операции с указателями будут автоматически откорректированы в соответствии с размером объектов, на которые указывают указатели.</p>
    <p>Можно производить следующие операции с указателями: присваивание значения указателя другому указателю того же типа, сложение и вычитание указателя и целого, вычитание и сравнение двух указателей, указывающих на элементы одного и того же массива, а также присваивание указателю нуля и сравнение указателя с нулем. Других операций с указателями производить не допускается. Нельзя складывать два указателя, перемножать их, делить, сдвигать, выделять разряды; указатель нельзя складывать со значением типа <emphasis>float</emphasis> или <emphasis>double</emphasis>; указателю одного типа нельзя даже присвоить указатель другого типа, не выполнив предварительно операции приведения (исключение составляют лишь указатели типа void*).</p>
   </section>
   <section>
    <title>
     <p>5.5 Символьные указатели функции</p>
    </title>
    <p><emphasis>Строковая константа</emphasis>, написанная в виде</p>
    <p><code>"Я строка"</code></p>
    <p>есть массив символов. Во внутреннем представлении этот массив заканчивается нулевым символом '\0', по которому программа может найти конец строки. Число занятых ячеек памяти на одну больше, чем количество символов, помещенных между двойными кавычками.</p>
    <p>Чаще всего строковые константы используются в качестве аргументов функций, как, например, в</p>
    <p><code>printf("здравствуй, мир\n");</code></p>
    <p>Когда такая символьная строка появляется в программе, доступ к ней осуществляется через символьный указатель; <emphasis>printf</emphasis> получает указатель на начало массива символов. Точнее, доступ к строковой константе осуществляется через указатель на ее первый элемент.</p>
    <p>Строковые константы нужны не только в качестве аргументов функций. Если, например, переменную <emphasis>pmessage</emphasis> объявить как</p>
    <p><code>char *pmessage;</code></p>
    <p>то присваивание</p>
    <p><code>pmessage = "now is the time";</code></p>
    <p>поместит в нее указатель на символьный массив, при этом сама строка не копируется, копируется лишь указатель на нее. Операции для работы со строкой как с единым целым в Си не предусмотрены.</p>
    <p>Существует важное различие между следующими определениями:</p>
    <p>char amessage[] = "now is the time"; /* массив */</p>
    <p><code>char *pmessage = "now is the time"; /* указатель */</code></p>
    <p><emphasis>amessage</emphasis> - это массив, имеющий такой объем, что в нем как раз помещается указанная последовательность символов и '\0'. Отдельные символы внутри массива могут изменяться, но <emphasis>amessage</emphasis> всегда указывает на одно и то же место памяти. В противоположность ему <emphasis>pmessage</emphasis> есть указатель, инициализированный так, чтобы указывать на строковую константу. А значение указателя можно изменить, и тогда последний будет указывать на что-либо другое. Кроме того, результат будет неопределен, если вы попытаетесь изменить содержимое константы.</p>
    <image l:href="#pic_7.jpg"/>
    <p>Дополнительные моменты, связанные с указателями и массивами, проиллюстрируем на несколько видоизмененных вариантах двух полезных программ, взятых нами из стандартной библиотеки. Первая из них, функция <emphasis>strcpy (s, t)</emphasis>, копирует строку <emphasis>t</emphasis> в строку <emphasis>s</emphasis>. Хотелось бы написать прямо <emphasis>s = t</emphasis>, но такой оператор копирует указатель, а не символы. Чтобы копировать символы, нам нужно организовать цикл. Первый вариант <emphasis>strcpy</emphasis>, с использованием массива, имеет следующий вид:</p>
    <p><code>/* strcpy: копирует t в s; вариант с индексируемым массивом*/</code></p>
    <p><code>void strcpy(char *s, char *t)</code></p>
    <p><code>{</code></p>
    <p><code> int i;</code></p>
    <p><code> i = 0;</code></p>
    <p><code> while ((s[i] = t[i]) != '\0')</code></p>
    <p><code>  i++;</code></p>
    <p><code>}</code></p>
    <p>Для сравнения приведем версию <emphasis>strcpy</emphasis> с указателями:</p>
    <p><code>/* strcpy: копирует t в s: версия 1 (с указателями) */</code></p>
    <p><code>void strcpy(char *s, char *t)</code></p>
    <p><code>{</code></p>
    <p><code> while ((*s = *t) != '\0') {</code></p>
    <p><code>  s++;</code></p>
    <p><code>  t++;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>Поскольку передаются лишь копии значений аргументов, <emphasis>strcpy</emphasis> может свободно пользоваться параметрами <emphasis>s</emphasis> и <emphasis>t</emphasis> как своими локальными переменными. Они должным образом инициализированы указателями, которые продвигаются каждый раз на следующий символ в каждом из массивов до тех пор, пока в копируемой строке <emphasis>t</emphasis> не встретится '\0'.</p>
    <p>На практике <emphasis>strcpy</emphasis> так не пишут. Опытный программист предпочтет более короткую запись:</p>
    <p><code>/* strcpy: копирует t в s; версия 2 (с указателями) */</code></p>
    <p><code>void strcpy(char *s, char *t)</code></p>
    <p><code>{</code></p>
    <p><code> while ((*s++ = *t++) != '\0')</code></p>
    <p><code>  ;</code></p>
    <p><code>}</code></p>
    <p>Приращение <emphasis>s</emphasis> и <emphasis>t</emphasis> здесь осуществляется в управляющей части цикла. Значением <emphasis>*t++</emphasis> является символ, на который указывает переменная <emphasis>t</emphasis> перед тем, как ее значение будет увеличено; постфиксный оператор ++ не изменяет указатель <emphasis>t</emphasis>, пока не будет взят символ, на который он указывает. То же в отношении <emphasis>s</emphasis>: сначала символ запомнится в позиции, на которую указывает старое значение <emphasis>s</emphasis>, и лишь после этого значение переменной <emphasis>s</emphasis> увеличится. Пересылаемый символ является одновременно и значением, которое сравнивается с '\0'. В итоге копируются все символы, включая и заключительный символ '\0'.</p>
    <p>Заметив, что сравнение с '\0' здесь лишнее (поскольку в Си ненулевое значение выражения в условии трактуется и как его истинность), мы можем сделать еще одно и последнее сокращение текста программы:</p>
    <p><code>/* strcpy: копирует t в s; версия 3 (с указателями) */</code></p>
    <p><code>void strcpy(char *s, char *t)</code></p>
    <p><code>{</code></p>
    <p><code> while (*s++ = *t++)</code></p>
    <p><code>  ;</code></p>
    <p><code>}</code></p>
    <p>Хотя на первый взгляд то, что мы получили, выглядит загадочно, все же такая запись значительно удобнее, и следует освоить ее, поскольку в Си-программах вы будете с ней часто встречаться.</p>
    <p>Что касается функции <strong>strcpy</strong> из стандартной библиотеки <strong>‹string.h›</strong> то она возвращает в качестве своего результата еще и указатель на новую копию строки.</p>
    <p>Вторая программа, которую мы здесь рассмотрим, это <emphasis>strcmp(s,t)</emphasis>. Она сравнивает символы строк <emphasis>s</emphasis> и <emphasis>t</emphasis> и возвращает отрицательное, нулевое или положительное значение, если строка <emphasis>s</emphasis> соответственно лексикографически меньше, равна или больше, чем строка <emphasis>t</emphasis>. Результат получается вычитанием первых несовпадающих символов из <emphasis>s</emphasis> и <emphasis>t</emphasis>.</p>
    <p><code>/* strcmp: выдает ‹ 0 при s ‹ t, 0 при s - t, › 0 при s › t */</code></p>
    <p><code>int strcmp(char *s, char *t)</code></p>
    <p><code>{</code></p>
    <p><code> int i;</code></p>
    <p><code> for (i = 0; s[i] == t[i]; i++)</code></p>
    <p><code>  if (s[i] == '\0')</code></p>
    <p><code>   return 0;</code></p>
    <p><code> return s[i] - t[i];</code></p>
    <p><code>}</code></p>
    <p>Та же программа с использованием указателей выглядит так:</p>
    <p><code>/* strcmp: выдает ‹ 0 при s ‹ t, 0 при s - t, › 0 при s › t */</code></p>
    <p><code>int strcmp(char *s, char *t)</code></p>
    <p><code>{</code></p>
    <p><code> for (; *s == *t; s++, t++)</code></p>
    <p><code>  if (*s == '\0')</code></p>
    <p><code>   return 0;</code></p>
    <p><code> return *s - *t;</code></p>
    <p><code>}</code></p>
    <p>Поскольку операторы <emphasis>++</emphasis> и <emphasis>-</emphasis> могут быть или префиксными, или постфиксными, встречаются (хотя и не так часто) другие их сочетания с оператором <emphasis>*</emphasis>. Например.</p>
    <p><code>*--p;</code></p>
    <p>уменьшит <emphasis>p</emphasis> прежде, чем по этому указателю будет получен символ. Например, следующие два выражения:</p>
    <p><code>*p++ = val; /* поместить val в стек */</code></p>
    <p><code>val = *--p; /* взять из стека значение и поместить в val */</code></p>
    <p>являются стандартными для посылки в стек и взятия из стека (см. параграф 4.3.).</p>
    <p>Объявления функций, упомянутых в этом параграфе, а также ряда других стандартных функций, работающих со строками, содержатся в заголовочном файле <strong>‹string.h›</strong>.</p>
    <p><strong>Упражнение 5.3</strong>. Используя указатели, напишите функцию <emphasis>strcat</emphasis>, которую мы рассматривали в главе 2 (функция <emphasis>strcat(s,t)</emphasis> копирует строку <emphasis>t</emphasis> в конец строки <emphasis>s</emphasis>).</p>
    <p><strong>Упражнение 5.4</strong>. Напишите функцию <emphasis>strend(s,t)</emphasis>, которая выдает 1, если строка <emphasis>t</emphasis> расположена в конце строки <emphasis>s</emphasis>, и нуль в противном случае.</p>
    <p><strong>Упражнение 5.5</strong>. Напишите варианты библиотечных функций <emphasis>strncpy</emphasis>, <emphasis>strncat</emphasis> и <emphasis>strncmp</emphasis>, которые оперируют с первыми символами своих аргументов, число которых не превышает <emphasis>n</emphasis>. Например, <emphasis>strncpy(t,s,n)</emphasis> копирует не более <emphasis>n</emphasis> символов <emphasis>t</emphasis> в <emphasis>s</emphasis>. Полные описания этих функций содержатся в приложении B.</p>
    <p><strong>Упражнение 5.6</strong>. Отберите подходящие программы из предыдущих глав и упражнений и перепишите их, используя вместо индексирования указатели. Подойдут, в частности, программы <emphasis>getline</emphasis> (главы 1 и 4), <emphasis>atoi</emphasis>, <emphasis>itoa</emphasis> и их варианты (главы 2, 3 и 4), <emphasis>reverse</emphasis> (глава 3), а также <emphasis>strindex</emphasis> и <emphasis>getop</emphasis> (глава 4).</p>
   </section>
   <section>
    <title>
     <p>5.6 Массивы указателей, указатели на указатели</p>
    </title>
    <p>Как и любые другие переменные, указатели можно группировать в массивы. Для иллюстрации этого напишем программу, сортирующую в алфавитном порядке текстовые строки; это будет упрощенный вариант программы <emphasis>sort</emphasis> системы UNIX.</p>
    <p>В главе 3 мы привели функцию сортировки по Шеллу, которая упорядочивает массив целых, а в главе 4 улучшили ее, повысив быстродействие. Те же алгоритмы используются и здесь, однако, теперь они будут обрабатывать текстовые строки, которые могут иметь разную длину и сравнение или перемещение которых невозможно выполнить за одну операцию. Нам необходимо выбрать некоторое представление данных, которое бы позволило удобно и эффективно работать с текстовыми строками произвольной длины.</p>
    <p>Для этого воспользуемся массивом указателей на начала строк. Поскольку строки в памяти расположены вплотную друг к другу, к каждой отдельной строке доступ просто осуществлять через указатель на ее первый символ. Сами указатели можно организовать в виде массива. Одна из возможностей сравнить две строки - передать указатели на них функции <emphasis>strcmp</emphasis>. Чтобы поменять местами строки, достаточно будет поменять местами в массиве их указатели (а не сами строки).</p>
    <image l:href="#pic_8.jpg"/>
    <p>Здесь снимаются сразу две проблемы: одна - связанная со сложностью управления памятью, а вторая - с большими накладными расходами при перестановках самих строк. Процесс сортировки распадается на три этапа:</p>
    <p><code><emphasis>чтение всех строк из ввода</emphasis></code></p>
    <p><code><emphasis>сортировка введенных строк</emphasis></code></p>
    <p><code><emphasis>печать их по порядку</emphasis></code></p>
    <p>Как обычно, выделим функции, соответствующие естественному делению задачи, и напишем главную программу <emphasis>main</emphasis>, управляющую этими функциями. Отложим на время реализацию этапа сортировки и сосредоточимся на структуре данных и вводе-выводе.</p>
    <p>Программа ввода должна прочитать и запомнить символы всех строк, а также построить массив указателей на строки. Она, кроме того, должна подсчитать число введенных строк - эта информация понадобится для сортировки и печати. Так как функция ввода может работать только с конечным числом строк, то, если их введено слишком много, она будет выдавать некоторое значение, которое никогда не совпадет с количеством строк, например -1.</p>
    <p>Программа вывода занимается только тем, что печатает строки, причем в том порядке, в котором расположены указатели на них в массиве.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>#define MAXLINES 5000 /* максимальное число строк */</code></p>
    <empty-line/>
    <p><code>char *lineptr[MAXLINES]; /* указатели на строки */</code></p>
    <empty-line/>
    <p><code>int readlines(char *lineptr[], int nlines);</code></p>
    <p><code>void writelines(char *lineptr[], int nlines);</code></p>
    <p><code>void qsort(char *lineptr[], int left, int right);</code></p>
    <empty-line/>
    <p><code>/* сортировка строк */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int nlines; /* количество прочитанных строк */</code></p>
    <empty-line/>
    <p><code> if ((nlines = readlines(lineptr, MAXLINES)) ›= 0) {</code></p>
    <p><code>  qsort(lineptr, 0, nlines-1);</code></p>
    <p><code>  writelines(lineptr, nlines);</code></p>
    <p><code>  return 0;</code></p>
    <p><code> } else {</code></p>
    <p><code>  printf("ошибка: слишком много строк\n");</code></p>
    <p><code>  return 1;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>#define MAXLEN 1000 /* максимальная длина строки */</code></p>
    <p><code>int getline(char *, int);</code></p>
    <p><code>char *alloc(int);</code></p>
    <empty-line/>
    <p><code>/* readlines: чтение строк */</code></p>
    <p><code>int readlines(char *lineptr[], int maxlines)</code></p>
    <p><code>{</code></p>
    <p><code> int len, nlines;</code></p>
    <p><code> char *p, line[MAXLEN];</code></p>
    <empty-line/>
    <p><code> nlines = 0;</code></p>
    <p><code> while ((len = getline(line, MAXLEN)) › 0)</code></p>
    <p><code>  if (nlines ›= maxlines || (p = alloc(len)) == NULL)</code></p>
    <p><code>   return -1;</code></p>
    <p><code>  else {</code></p>
    <p><code>   line[len-1] = '\0'; /* убираем символ \n */</code></p>
    <p><code>   strcpy(p, line);</code></p>
    <p><code>   lineptr[nlines++] = p;</code></p>
    <p><code>  }</code></p>
    <p><code> return nlines;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* writelines: печать строк */</code></p>
    <p><code>void writelines(char *lineptr[], int nlines)</code></p>
    <p><code>{</code></p>
    <p><code> int i;</code></p>
    <p><code> for (i = 0; i ‹ nlines; i++)</code></p>
    <p><code>  printf("%s\n", lineptr[i]);</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>getline</emphasis> взята из параграфа 1.9. Основное новшество здесь - объявление <emphasis>lineptr</emphasis>:</p>
    <p><code>char *lineptr[MAXLINES];</code></p>
    <p>в котором сообщается, что <emphasis>lineptr</emphasis> есть массив из MAXLINES элементов, каждый из которых представляет собой указатель на <emphasis>char</emphasis>. Иначе говоря, <emphasis>lineptr[i]</emphasis> - указатель на символ, а <emphasis>*lineptr[i]</emphasis> - символ, на который он указывает (первый символ <emphasis>i</emphasis>-й строки текста).</p>
    <p>Так как <emphasis>lineptr</emphasis> - имя массива, его можно трактовать как указатель, т. е. так же, как мы это делали в предыдущих примерах, и <emphasis>writelines</emphasis> переписать следующим образом:</p>
    <p><code>/* writelines: печать строк */</code></p>
    <p><code>void writelines(char *lineptr[], int nlines)</code></p>
    <p><code>{</code></p>
    <p><code> while (nlines-- › 0)</code></p>
    <p><code>  printf("%s\n", *lineptr++);</code></p>
    <p><code>}</code></p>
    <p>Вначале <emphasis>*lineptr</emphasis> указывает на первую строку: каждое приращение указателя приводит к тому, что <emphasis>*lineptr</emphasis> указывает на следующую строку, и делается это до тех пор, пока <emphasis>nlines</emphasis> не станет нулем.</p>
    <p>Теперь, когда мы разобрались с вводом и выводом, можно приступить к сортировке. Быструю сортировку, описанную в главе 4, надо несколько модифицировать: нужно изменить объявления, а операцию сравнения заменить обращением к <emphasis>strcmp</emphasis>. Алгоритм остался тем же, и это дает нам определенную уверенность в его правильности.</p>
    <p><code>/* qsort: сортирует v[left]…v[right] по возрастанию */</code></p>
    <p><code>void qsort(char *v[], int left, int right)</code></p>
    <p><code>{</code></p>
    <p><code> int i, last;</code></p>
    <p><code> void swap(char *v[], int i, int j);</code></p>
    <empty-line/>
    <p><code> if (left ›= right) /* ничего не делается, если в массиве */</code></p>
    <p><code>  return; /* менее двух элементов */</code></p>
    <empty-line/>
    <p><code> swap(v, left, (left+right)/2);</code></p>
    <p><code> last = left;</code></p>
    <p><code> for(i = left+1; i ‹= right; i++)</code></p>
    <p><code>  if (strcmp(v[i], v[left]) ‹ 0)</code></p>
    <p><code>   swap(v, ++last, i);</code></p>
    <p><code> swap(v, left, last);</code></p>
    <p><code> qsort(v, left, last-1);</code></p>
    <p><code> qsort(v, last+1, right);</code></p>
    <p><code>}</code></p>
    <p>Небольшие поправки требуются и в программе перестановки.</p>
    <p><code>/* swap: поменять местами v[i] и v[j] */</code></p>
    <p><code>void swap(char *v[], int i, int j)</code></p>
    <p><code>{</code></p>
    <p><code> char *temp;</code></p>
    <p><code> temp = v[i];</code></p>
    <p><code> v[i] = v[j];</code></p>
    <p><code> v[j] = temp;</code></p>
    <p><code>}</code></p>
    <p>Так как каждый элемент массива <emphasis>v</emphasis> (т. е. <emphasis>lineptr</emphasis>) является указателем на символ, <emphasis>temp</emphasis> должен иметь тот же тип, что и <emphasis>v</emphasis> - тогда можно будет осуществлять пересылки между <emphasis>temp</emphasis> и элементами <emphasis>v</emphasis>.</p>
    <p><strong>Упражнение 5.7</strong>. Напишите новую версию <emphasis>readlines</emphasis>, которая запоминала бы строки в массиве, определенном в <emphasis>main</emphasis>, а не запрашивала память посредством программы <emphasis>alloc</emphasis>. Насколько быстрее эта программа?</p>
   </section>
   <section>
    <title>
     <p>5.7 Многомерные массивы</p>
    </title>
    <p>В Си имеется возможность задавать прямоугольные многомерные массивы, правда, на практике по сравнению с массивами указателей они используются значительно реже. В этом параграфе мы продемонстрируем некоторые их свойства.</p>
    <p>Рассмотрим задачу перевода даты "день-месяц" в "день года" и обратно. Например, 1 марта - это 60-й день невисокосного или 61-й день високосного года. Определим две функции для этих преобразований: функция <emphasis>day_of_year</emphasis> будет преобразовывать месяц и день в день года, a <emphasis>month_day</emphasis> - день года в месяц и день. Поскольку последняя функция вычисляет два значения, аргументы месяц и день будут указателями. Так вызов</p>
    <p><code>month_day(1988, 60, &amp;m, &amp;d)</code></p>
    <p>присваивает переменной <emphasis>m</emphasis> значение 2, а <emphasis>d</emphasis> - 29 (29 февраля).</p>
    <p>Нашим функциям нужна одна и та же информация, а именно таблица, содержащая числа дней каждого месяца. Так как для високосного и невисокосного годов эти таблицы будут различаться, проще иметь две отдельные строки в двумерном массиве, чем во время вычислений отслеживать особый случай с февралем. Массив и функции, выполняющие преобразования, имеют следующий вид:</p>
    <p><code>static char daytab[2][13] = {</code></p>
    <p><code> {0, 31, 28, 31. 30, 31, 30, 31, 31, 30, 31, 30, 31},</code></p>
    <p><code> {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* day_of_year: определяет день года по месяцу и дню */</code></p>
    <p><code>int day_of_year(int year, int month, int day)</code></p>
    <p><code>{</code></p>
    <p><code> int i, leap;</code></p>
    <p><code> leap = year % 4 == 0 &amp;&amp; year % 100 !=0 || year % 400 == 0;</code></p>
    <p><code> for (i = 1; i ‹ month; i++)</code></p>
    <p><code> day += daytab[leap][i];</code></p>
    <p><code> return day;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* month_day: определяет месяц и день по дню года */</code></p>
    <p><code>void month_day(int year, int yearday, int *pmonth, int *pday)</code></p>
    <p><code>{</code></p>
    <p><code> int i, leap;</code></p>
    <p><code> leap = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0;</code></p>
    <p><code> for (i = 1; yearday › daytab[leap][i]; i++)</code></p>
    <p><code> yearday -= daytab[leap][i];</code></p>
    <p><code> *pmonth = i;</code></p>
    <p><code> *pday = yearday;</code></p>
    <p><code>}</code></p>
    <p>Напоминаем, что арифметическое значение логического выражения (например выражения, с помощью которого вычислялось <emphasis>leap</emphasis>) равно либо нулю (ложь), либо единице (истина), так что мы можем использовать его как индекс в массиве <emphasis>daytab</emphasis>.</p>
    <p>Массив <emphasis>daytab</emphasis> должен быть внешним по отношению к обеим функциям <emphasis>day_of_year</emphasis> и <emphasis>month_day</emphasis>, так как он нужен и той и другой. Мы сделали его типа <emphasis>char</emphasis>, чтобы проиллюстрировать законность применения типа <emphasis>char</emphasis> для малых целых без знака.</p>
    <p>Массив <emphasis>daytab</emphasis> - это первый массив из числа двумерных, с которыми мы еще не имели дела. Строго говоря, в Си двумерный массив рассматривается как одномерный массив, каждый элемент которого - также массив. Поэтому индексирование изображается так:</p>
    <p><code>daytab[i][j] /* [строка] [столбец] */</code></p>
    <p>а не так:</p>
    <p><code>daytab[i,j] /* НЕВЕРНО */</code></p>
    <p>Особенность двумерного массива в Си заключается лишь в форме записи, в остальном его можно трактовать почти так же, как в других языках. Элементы запоминаются строками, следовательно, при переборе их в том порядке, как они расположены в памяти, чаще будет изменяться самый правый индекс.</p>
    <p>Массив инициализируется списком начальных значений, заключенным в фигурные скобки; каждая строка двумерного массива инициализируется соответствующим подсписком. Нулевой столбец добавлен в начало <emphasis>daytab</emphasis> лишь для того, чтобы индексы, которыми мы будем пользоваться, совпадали с естественными номерами месяцев от 1 до 12. Экономить пару ячеек памяти здесь нет никакого смысла, а программа, в которой уже не надо корректировать индекс, выглядит более ясной.</p>
    <p>Если двумерный массив передается функции в качестве аргумента, то объявление соответствующего ему параметра должно содержать количество столбцов; количество строк в данном случае несущественно, поскольку, как и прежде, функции будет передан указатель на массив строк, каждая из которых есть массив из 13 значений типа <emphasis>int</emphasis>. B нашем частном случае мы имеем указатель на объекты, являющиеся массивами из 13 значений типа <emphasis>int</emphasis>. Таким образом, если массив <emphasis>daytab</emphasis> передается некоторой функции <emphasis>f</emphasis>, то эту функцию можно было бы определить следующим образом:</p>
    <p><code>f(int daytab[2][13]) {…}</code></p>
    <p>Вместо этого можно записать</p>
    <p><code>f(int daytab[][13]) {…}</code></p>
    <p>поскольку число строк здесь не имеет значения, или</p>
    <p><code>f(int (*daytab)[13]) {…}</code></p>
    <p>Последняя запись объявляет, что параметр есть указатель на массив из 13 значений типа <emphasis>int</emphasis>. Скобки здесь необходимы, так как квадратные скобки <strong>[]</strong> имеют более высокий приоритет, чем <strong>*</strong>. Без скобок объявление</p>
    <p><code>int *daytab[13]</code></p>
    <p>определяет массив из 13 указателей на <emphasis>char</emphasis>. В более общем случае только первое измерение (соответствующее первому индексу) можно не задавать, все другие специфицировать необходимо. В параграфе 5.12 мы продолжим рассмотрение сложных объявлений.</p>
    <p><strong>Упражнение 5.8</strong>. В функциях <emphasis>day_of_year</emphasis> и <emphasis>month_day</emphasis> нет никаких проверок правильности вводимых дат. Устраните этот недостаток.</p>
   </section>
   <section>
    <title>
     <p>5.8 Инициализация массивов указателей</p>
    </title>
    <p>Напишем функцию <emphasis>month_name(n)</emphasis>, которая возвращает указатель на строку символов, содержащий название <emphasis>n</emphasis>-го месяца. Эта функция идеальна для демонстрации использования статического массива. Функция <emphasis>month_name</emphasis> имеет в своем личном распоряжении массив строк, на одну из которых она и возвращает указатель. Ниже покажем, как инициализируется этот массив имен.</p>
    <p>Синтаксис задания начальных значений аналогичен синтаксису предыдущих инициализаций:</p>
    <p><code>/* month_name: возвращает имя n-го месяца */</code></p>
    <p><code>char *month_name(int n)</code></p>
    <p><code>{</code></p>
    <p><code> static char *name[] = {</code></p>
    <p><code>  "Неверный месяц",</code></p>
    <p><code>  "Январь","Февраль","Март","Апрель","Май","Июнь",</code></p>
    <p><code>  "Июль","Август","Сентябрь","Октябрь","Ноябрь","Декабрь"</code></p>
    <p><code> };</code></p>
    <p><code> return (n ‹ 1 || n › 12) ? name[0] : name[n];</code></p>
    <p><code>}</code></p>
    <p>Объявление <emphasis>name</emphasis> массивом указателей на символы такое же, как и объявление <emphasis>lineptr</emphasis> в программе сортировки. Инициализатором служит список строк, каждой из которых соответствует определенное место в массиве. Символы <emphasis>i</emphasis>-й строки где-то размещены, и указатель на них запоминается в <emphasis>name[i]</emphasis>. Так как размер массива <emphasis>name</emphasis> не специфицирован, компилятор вычислит его по количеству заданных начальных значений.</p>
   </section>
   <section>
    <title>
     <p>5.9 Указатели против многомерных массивов</p>
    </title>
    <p>Начинающие программировать на Си иногда не понимают, в чем разница между двумерным массивом и массивом указателей вроде <emphasis>name</emphasis> из приведенного примера. Для двух следующих определений:</p>
    <p><code>int a[10][20];</code></p>
    <p><code>int *b[10];</code></p>
    <p>записи <emphasis>a[3][4]</emphasis> и <emphasis>b[3][4]</emphasis> будут синтаксически правильным обращением к некоторому значению типа <emphasis>int</emphasis>. Однако только <emphasis>a</emphasis> является истинно двумерным массивом: для двухсот элементов типа <emphasis>int</emphasis> будет выделена память, а вычисление смещения элемента <emphasis>a[строка][столбец]</emphasis> от начала массива будет вестись по формуле <emphasis>20 * строка + столбец</emphasis>, учитывающей его прямоугольную природу. Для <emphasis>b</emphasis> же определено только 10 указателей, причем без инициализации. Инициализация должна задаваться явно -либо статически, либо в программе. Предположим, что каждый элемент <emphasis>b</emphasis> указывает на двадцатиэлементный массив, в результате где-то будут выделены пространство, в котором разместятся 200 значений типа <emphasis>int</emphasis>, и еще 10 ячеек для указателей. Важное преимущество массива указателей в том, что строки такого массива могут иметь разные длины. Таким образом, каждый элемент массива <emphasis>b</emphasis> не обязательно указывает на двадцатиэлементный вектор; один может указывать на два элемента, другой - на пятьдесят, а некоторые и вовсе могут ни на что не указывать.</p>
    <p>Наши рассуждения здесь касались целых значений, однако чаще массивы указателей используются для работы со строками символов, различающимися по длине, как это было в функции <emphasis>month_name</emphasis>. Сравните определение массива указателей и соответствующий ему рисунок:</p>
    <p><code>char *name[] = {"Неправильный месяц", "Янв", "Февр", "Март"};</code></p>
    <image l:href="#pic_9.jpg"/>
    <p>с объявлением и рисунком для двумерного массива:</p>
    <p><code>char aname[][15] = {"Неправ. месяц", "Янв", "Февр", "Март"};</code></p>
    <image l:href="#pic_10.jpg"/>
    <p><strong>Упражнение 5.9</strong>. Перепишите программы <emphasis>day_of_year</emphasis> и <emphasis>month_day</emphasis>, используя вместо индексов указатели.</p>
   </section>
   <section>
    <title>
     <p>5.10 Аргументы командной строки</p>
    </title>
    <p>В операционной среде, обеспечивающей поддержку Си, имеется возможность передать аргументы или параметры запускаемой программе с помощью командной строки. В момент вызова <emphasis>main</emphasis> получает два аргумента. В первом, обычно называемом <emphasis>argc</emphasis> (сокращение от <emphasis>argument count</emphasis>), стоит количество аргументов, задаваемых в командной строке. Второй, <emphasis>argv</emphasis> (от <emphasis>argument vector</emphasis>), является указателем на массив символьных строк, содержащих сами аргументы. Для работы с этими строками обычно используются указатели нескольких уровней.</p>
    <p>Простейший пример - программа <emphasis>echo</emphasis> ("эхо"), которая печатает аргументы своей командной строки в одной строчке, отделяя их друг от друга пробелами. Так, команда</p>
    <p><code>echo Здравствуй, мир!</code></p>
    <p>Напечатает</p>
    <p><code>Здравствуй, мир!</code></p>
    <p>По соглашению <emphasis>argv[0]</emphasis> есть имя вызываемой программы, так что значение <emphasis>argc</emphasis> никогда не бывает меньше 1. Если <emphasis>argc</emphasis> равен 1, то в командной строке после имени программы никаких аргументов нет. В нашем примере <emphasis>argc</emphasis> равен 3, и соответственно <emphasis>argv[0]</emphasis>, <emphasis>argv[1]</emphasis> и <emphasis>argv[2]</emphasis> суть строки <emphasis>"echo"</emphasis>, <emphasis>"Здравствуй,"</emphasis> и <emphasis>"мир!</emphasis>". Первый необязательный аргумент - это <emphasis>argv[1]</emphasis>, последний - <emphasis>argv[argc-1]</emphasis>. Кроме того, стандарт требует, чтобы <emphasis>argv[argc]</emphasis> всегда был пустым указателем.</p>
    <image l:href="#pic_11.jpg"/>
    <p>Первая версия программы <emphasis>echo</emphasis> трактует <emphasis>argv</emphasis> как массив символьных указателей.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <empty-line/>
    <p><code>/* эхо аргументов командной строки: версия 1 */</code></p>
    <p><code>main(int argc, char *argv[])</code></p>
    <p><code>{</code></p>
    <p><code> int i;</code></p>
    <p><code> for (i = 1; i ‹ argc; i++)</code></p>
    <p><code>  printf("%s%s", argv[i], (i ‹ argc-1) ? " " : ");</code></p>
    <p><code> printf("\n");</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Так как <emphasis>argv</emphasis> - это указатель на массив указателей, мы можем работать с ним как с указателем, а не как с индексируемым массивом. Следующая программа основана на приращении <emphasis>argv</emphasis>, он приращивается так, что его значение в каждый отдельный момент указывает на очередной указатель на <emphasis>char</emphasis>; перебор указателей заканчивается, когда исчерпан <emphasis>argc</emphasis>.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <empty-line/>
    <p><code>/* эхо аргументов командной строки; версия 2 */</code></p>
    <p><code>main(int argc, char *argv[])</code></p>
    <p><code>{</code></p>
    <p><code> while (--argc › 0)</code></p>
    <p><code>  printf("%s%s", *++argv, (argc › 1) ? " " : ");</code></p>
    <p><code> print f("\n");</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Аргумент <emphasis>argv</emphasis> - указатель на начало массива строк аргументов. Использование в <emphasis>++argv</emphasis> префиксного оператора <strong>++</strong> приведет к тому, что первым будет напечатан <emphasis>argv[1]</emphasis>,а не <emphasis>argv[0]</emphasis>. Каждое очередное приращение указателя дает нам следующий аргумент, на который указывает <emphasis>*argv</emphasis>. В это же время значение <emphasis>argc</emphasis> уменьшается на 1, и, когда оно станет нулем, все аргументы будут напечатаны. Инструкцию <emphasis>printf</emphasis> можно было бы написать и так:</p>
    <p><code>printf((argc › 1)? "%s ": "%s", *++argv);</code></p>
    <p>Как видим, формат в <emphasis>printf</emphasis> тоже может быть выражением.</p>
    <p>В качестве второго примера возьмем программу поиска образца, рассмотренную в параграфе 4.1, и несколько усовершенствуем ее. Если вы помните, образец для поиска мы "вмонтировали" глубоко в программу, а это, очевидно, не лучшее решение. Построим нашу программу по аналогии с <emphasis>grep</emphasis> из UNIXa, т. е. так, чтобы образец для поиска задавался первым аргументом в командной строке.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <p><code>#define MAXLINE 1000</code></p>
    <empty-line/>
    <p><code>int getline(char *line, int max);</code></p>
    <p><code>/* find: печать строк с образцом, заданным 1-м аргументом */</code></p>
    <p><code>main(int argc, char *argv[])</code></p>
    <p><code>{</code></p>
    <p><code> char line[MAXLINE];</code></p>
    <p><code> int found = 0;</code></p>
    <empty-line/>
    <p><code> if (argc != 2)</code></p>
    <p><code>  printf("Используйте в find образец\n");</code></p>
    <p><code> else</code></p>
    <p><code>  while (getline(line, MAXLINE) › 0)</code></p>
    <p><code>   if (strstr(line, argv[1]) ›= NULL) {</code></p>
    <p><code>    printf ("%s", line);</code></p>
    <p><code>    found++;</code></p>
    <p><code>   }</code></p>
    <p><code> return found;</code></p>
    <p><code>}</code></p>
    <p>Стандартная функция <emphasis>strstr(s,t)</emphasis> возвращает указатель на первую встретившуюся строку <emphasis>t</emphasis> в строке <emphasis>s</emphasis> или NULL, если таковой в <emphasis>s</emphasis> не встретилось. Функция объявлена в заголовочном файле ‹string.h›.</p>
    <p>Эту модель можно развивать и дальше, чтобы проиллюстрировать другие конструкции с указателями. Предположим, что мы вводим еще два необязательных аргумента. Один из них предписывает печатать все строки, кроме тех, в которых встречается образец; второй - перед каждой выводимой строкой печатать ее порядковый номер.</p>
    <p>По общему соглашению для Си-программ в системе UNIX знак минус перед аргументом вводит необязательный признак или параметр. Так, если <emphasis>-x</emphasis> служит признаком слова "кроме", которое изменяет задание на противоположное, а <emphasis>-n</emphasis> указывает на потребность в нумерации строк, то команда</p>
    <p><code>find -x -n образец</code></p>
    <p>напечатает все строки, в которых не найден указанный образец, и, кроме того, перед каждой строкой укажет ее номер.</p>
    <p>Необязательные аргументы разрешается располагать в любом порядке, при этом лучше, чтобы остальная часть программы не зависела от числа представленных аргументов. Кроме того, пользователю было бы удобно, если бы он мог комбинировать необязательные аргументы, например так:</p>
    <p><code>find -nx образец</code></p>
    <p>А теперь запишем нашу программу.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <p><code>#define MAXLINE 1000</code></p>
    <empty-line/>
    <p><code>int getline(char *line, int max);</code></p>
    <empty-line/>
    <p><code>/* find: печать строк образцами из 1-го аргумента */</code></p>
    <p><code>main(int argc, char *argv[])</code></p>
    <p><code>{</code></p>
    <p><code> char line[MAXLINE];</code></p>
    <p><code> long lineno = 0;</code></p>
    <p><code> int c, except = 0, number = 0, found = 0;</code></p>
    <empty-line/>
    <p><code> while (--argc › 0 &amp;&amp; (*++argv)[0] == '-')</code></p>
    <p><code>  while (c = *++argv[0])</code></p>
    <p><code>   switch (c) {</code></p>
    <p><code>   case 'x':</code></p>
    <p><code>    except = 1;</code></p>
    <p><code>    break;</code></p>
    <p><code>   case 'n':</code></p>
    <p><code>    number = 1;</code></p>
    <p><code>    break;</code></p>
    <p><code>   default:</code></p>
    <p><code>    printf("find: неверный параметр %c\n", c);</code></p>
    <p><code>    argc = 0;</code></p>
    <p><code>    found = -1;</code></p>
    <p><code>    break;</code></p>
    <p><code>   }</code></p>
    <p><code> if (argc != 1)</code></p>
    <p><code>  printf("Используйте: find -x -n образец\n");</code></p>
    <p><code> else</code></p>
    <p><code>  while (getline(line, MAXLINE) › 0) {</code></p>
    <p><code>   lineno++;</code></p>
    <p><code>   if ((strstr(line, *argv) != NULL) != except) {</code></p>
    <p><code>    if (number)</code></p>
    <p><code>     printf("%ld:", lineno);</code></p>
    <p><code>    printf("%s", line);</code></p>
    <p><code>    found++;</code></p>
    <p><code>   }</code></p>
    <p><code>  }</code></p>
    <p><code> return found;</code></p>
    <p><code>}</code></p>
    <p>Перед получением очередного аргумента <emphasis>argc</emphasis> уменьшается на 1, а <emphasis>argv</emphasis> "перемещается" на следующий аргумент. После завершения цикла при отсутствии ошибок <emphasis>argc</emphasis> содержит количество еще не обработанных аргументов, a <emphasis>argv</emphasis> указывает на первый из них. Таким образом, <emphasis>argc</emphasis> должен быть равен 1, a <emphasis>*argv</emphasis> указывать на образец. Заметим, что <emphasis>*++argv</emphasis> является указателем на аргумент- строку, a <emphasis>(*++argv)[0]</emphasis> - его первым символом, на который можно сослаться и другим способом:</p>
    <p><code>**++argv;</code></p>
    <p>Поскольку оператор индексирования <strong>[]</strong> имеет более высокий приоритет, чем <strong>*</strong> и <strong>++</strong>, круглые скобки здесь обязательны, без них выражение трактовалось бы так же, как <emphasis>*++(argv[0])</emphasis>. Именно такое выражение мы применим во внутреннем цикле, где просматриваются символы конкретного аргумента. Во внутреннем цикле выражение <emphasis>*++argv[0]</emphasis> приращивает указатель <emphasis>argv[0]</emphasis>.</p>
    <p>Потребность в более сложных выражениях для указателей возникает не так уж часто. Но если такое случится, то разбивая процесс вычисления указателя на два или три шага, вы облегчите восприятие этого выражения.</p>
    <p><strong>Упражнение 5.10</strong>. Напишите программу <emphasis>expr</emphasis>, интерпретирующую обратную польскую запись выражения, задаваемого командной строкой, в которой каждый оператор и операнд представлены отдельным аргументом. Например,</p>
    <p><code>expr 2 3 4 + *</code></p>
    <p>вычисляется так же, как выражение 2*(3+4).</p>
    <p><strong>Упражнение 5.11</strong>. Усовершенствуйте программы <emphasis>entab</emphasis> и <emphasis>detab</emphasis> (см. упражнения 1.20 и 1.21) таким образом, чтобы через аргументы можно было задавать список "стопов" табуляции.</p>
    <p><strong>Упражнение 5.12</strong>. Расширьте возможности <emphasis>entab</emphasis> и <emphasis>detab</emphasis> таким образом, чтобы при обращении вида</p>
    <p><code>entab -m +n</code></p>
    <p>"стопы" табуляции начинались с <emphasis>m</emphasis>-й позиции и выполнялись через каждые <emphasis>n</emphasis> позиций. Разработайте удобный для пользователя вариант поведения программы по умолчанию (когда нет никаких аргументов).</p>
    <p><strong>Упражнение 5.13</strong>. Напишите программу <emphasis>tail</emphasis>, печатающую <emphasis>n</emphasis> последних введенных строк. По умолчанию значение <emphasis>n</emphasis> равно 10, но при желании <emphasis>n</emphasis> можно задать с помощью аргумента. Обращение вида</p>
    <p><code>tail -n</code></p>
    <p>печатает <emphasis>n</emphasis> последних строк. Программа должна вести себя осмысленно при любых входных данных и любом значении <emphasis>n</emphasis>. Напишите программу так, чтобы наилучшим образом использовать память; запоминание строк организуйте, как в программе сортировки, описанной в параграфе 5.6, а не на основе двумерного массива с фиксированным размером строки.</p>
   </section>
   <section>
    <title>
     <p>5.11 Указатели на функции</p>
    </title>
    <p>В Си сама функция не является переменной, но можно определить указатель на функцию и работать с ним, как с обычной переменной: присваивать, размещать в массиве, передавать в качестве параметра функции, возвращать как результат из функции и т. д. Для иллюстрации этих возможностей воспользуемся программой сортировки, которая уже встречалась в настоящей главе. Изменим ее так, чтобы при задании необязательного аргумента -n вводимые строки упорядочивались по их числовому значению, а не в лексикографическом порядке.</p>
    <p>Сортировка, как правило, распадается на три части: на сравнение, определяющее упорядоченность пары объектов; перестановку, меняющую местами пару объектов, и сортирующий алгоритм, который осуществляет сравнения и перестановки до тех пор, пока все объекты не будут упорядочены. Алгоритм сортировки не зависит от операций сравнения и перестановки, так что передавая ему в качестве параметров различные функции сравнения и перестановки, его можно настроить на различные критерии сортировки.</p>
    <p>Лексикографическое сравнение двух строк выполняется функцией <emphasis>strcmp</emphasis> (мы уже использовали эту функцию в ранее рассмотренной программе сортировки); нам также потребуется программа <emphasis>numcmp</emphasis>, сравнивающая две строки как числовые значения и возвращающая результат сравнения в том же виде, в каком его выдает <emphasis>strcmp</emphasis>. Эти функции объявляются перед <emphasis>main</emphasis>, а указатель на одну из них передается функции <emphasis>qsort</emphasis>. Чтобы сосредоточиться на главном, мы упростили себе задачу, отказавшись от анализа возможных ошибок при задании аргументов.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <empty-line/>
    <p><code>#define MAXLINES 5000 /* максимальное число строк */</code></p>
    <p><code>char *lineptr[MAXLINES]; /* указатели на строки текста */</code></p>
    <empty-line/>
    <p><code>int readlines(char *lineptr[], int nlines);</code></p>
    <p><code>void writelines(char *lineptr[], int nlines);</code></p>
    <p><code>void qsort(void *lineptr[], int left, int right,</code></p>
    <p><code>int (*comp)(void *, void *));</code></p>
    <p><code>int numcmp(char *, char *);</code></p>
    <empty-line/>
    <p><code>/* сортировка строк */</code></p>
    <p><code>main(int argc, char *argv[])</code></p>
    <p><code>{</code></p>
    <p><code> int nlines; /* количество прочитанных строк */</code></p>
    <p><code> int numeric = 0; /* 1, если сорт. по числ. знач. */</code></p>
    <p><code> if (argc › 1 &amp;&amp; strcmp(argv[1], "-n") == 0)</code></p>
    <p><code>  numeric = 1;</code></p>
    <p><code> if ((nlines = readlines(lineptr, MAXLINES)) ›= 0) {</code></p>
    <p><code>  qsort((void **) lineptr, 0, nlines-1,</code></p>
    <p><code>   (int (*)(void*,void*))(numeric ? numcmp : strcmp));</code></p>
    <p><code>  writelines(lineptr, nlines);</code></p>
    <p><code>  return 0;</code></p>
    <p><code> } else {</code></p>
    <p><code>  printf("Bведено слишком много строк\n");</code></p>
    <p><code>  return 1;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>В обращениях к функциям <emphasis>qsort</emphasis>, <emphasis>strcmp</emphasis> и <emphasis>numcmp</emphasis> их имена трактуются как адреса этих функций, поэтому оператор&amp; перед ними не нужен, как он не был нужен и перед именем массива.</p>
    <p>Мы написали <emphasis>qsort</emphasis> так, чтобы она могла обрабатывать данные любого типа, а не только строки символов. Как видно из прототипа, функция <emphasis>qsort</emphasis> в качестве своих аргументов ожидает массив указателей, два целых значения и функцию с двумя аргументами-указателями. В качестве аргументов-указателей заданы указатели обобщенного типа <emphasis>void *</emphasis>. Любой указатель можно привести к типу <emphasis>void *</emphasis> и обратно без потери информации, поэтому мы можем обратиться к <emphasis>qsort</emphasis>, предварительно преобразовав аргументы в <emphasis>void *</emphasis>. Внутри функции сравнения ее аргументы будут приведены к нужному ей типу. На самом деле эти преобразования никакого влияния на представления аргументов не оказывают, они лишь обеспечивают согласованность типов для компилятора.</p>
    <p><code>/* qsort: сортирует v[left]…v[right] по возрастанию */</code></p>
    <p><code>void qsort(void *v[], int left, int right, int (*comp)(void *, void *))</code></p>
    <p><code>{</code></p>
    <p><code> int i, last;</code></p>
    <p><code> void swap(void *v[], int, int);</code></p>
    <empty-line/>
    <p><code> if (left ›= right) /* ничего не делается, если */</code></p>
    <p><code>  return; /* в массиве менее двух элементов */</code></p>
    <p><code> swap(v, left, (left + right)/2);</code></p>
    <p><code> last = left;</code></p>
    <p><code> for (i = left+1; i ‹= right; i++)</code></p>
    <p><code>  if ((*comp)(v[i], v[left]) ‹ 0)</code></p>
    <p><code>   swap(v, ++last, i);</code></p>
    <p><code> swap(v, left, last);</code></p>
    <p><code> qsort(v, left, last-1, comp);</code></p>
    <p><code> qsort(v, last+1, right, comp);</code></p>
    <p><code>}</code></p>
    <p>Повнимательней приглядимся к объявлениям. Четвертый параметр функции qsort:</p>
    <p><code>int (*comp)(void *, void *)</code></p>
    <p>сообщает, что <emphasis>comp</emphasis> - это указатель на функцию, которая имеет два аргумента- указателя и выдает результат типа <emphasis>int</emphasis>. Использование <emphasis>comp</emphasis> в строке</p>
    <p><code>if ((*comp)(v[i], v[left]) ‹ 0)</code></p>
    <p>согласуется с объявлением "<emphasis>comp</emphasis> - это указатель на функцию", и, следовательно, <emphasis>*comp</emphasis> - это функция, а</p>
    <p><code>(*comp)(v[i], v[left])</code></p>
    <p>- обращение к ней. Скобки здесь нужны, чтобы обеспечить правильную трактовку объявления; без них объявление</p>
    <p><code>int *comp(void *, void *) /* НЕВЕРНО */</code></p>
    <p>говорило бы, что <emphasis>comp</emphasis> - это функция, возвращающая указатель на <emphasis>int</emphasis>, а это совсем не то, что требуется.</p>
    <p>Мы уже рассматривали функцию <emphasis>strcmp</emphasis>, сравнивающую две строки. Ниже приведена функция <emphasis>numcmp</emphasis>, которая сравнивает две строки, рассматривая их как числа; предварительно они переводятся в числовые значения функцией <emphasis>atof</emphasis>.</p>
    <p><code>#include ‹stdlib.h›</code></p>
    <empty-line/>
    <p><code>/* numcmp: сравнивает s1 и s2 как числа */</code></p>
    <p><code>int numcmp(char *s1, char *s2)</code></p>
    <p><code>{</code></p>
    <p><code> double v1, v2;</code></p>
    <empty-line/>
    <p><code> v1 = atof(s1);</code></p>
    <p><code> v2 = atof(s2);</code></p>
    <p><code> if (v1 ‹ v2)</code></p>
    <p><code>  return -1;</code></p>
    <p><code> else if (v1 › v2)</code></p>
    <p><code>  return 1;</code></p>
    <p><code> else</code></p>
    <p><code>  return 0;</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>swap</emphasis>, меняющая местами два указателя, идентична той, что мы привели ранее в этой главе за исключением того, что объявления указателей заменены на <emphasis>void*</emphasis>.</p>
    <p><code>void swap(void *v[], int i, int j)</code></p>
    <p><code>{</code></p>
    <p><code> void *temp;</code></p>
    <p><code> temp = v[i];</code></p>
    <p><code> v[i] = v[j];</code></p>
    <p><code> v[j] = temp;</code></p>
    <p><code>}</code></p>
    <p>Программу сортировки можно дополнить и множеством других возможностей; реализовать некоторые из них предлагается в качестве упражнений.</p>
    <p><strong>Упражнение 5.14</strong>. Модифицируйте программу сортировки, чтобы она реагировала на параметр <emphasis>-r</emphasis>, указывающий, что объекты нужно сортировать в обратном порядке, т. е. в порядке убывания. Обеспечьте, чтобы <emphasis>-r</emphasis> работал и вместе с <emphasis>-n</emphasis>.</p>
    <p><strong>Упражнение 5.15</strong>. Введите в программу необязательный параметр <emphasis>-f</emphasis>, задание которого делало бы неразличимыми символы нижнего и верхнего регистров (например, a и A должны оказаться при сравнении равными).</p>
    <p><strong>Упражнение 5.16</strong>. Предусмотрите в программе необязательный параметр <emphasis>-d</emphasis>, который заставит программу при сравнении учитывать только буквы, цифры и пробелы. Организуйте программу таким образом, чтобы этот параметр мог работать вместе с параметром <emphasis>-f</emphasis>.</p>
    <p><strong>Упражнение 5.17</strong>. Реализуйте в программе возможность работы с полями: возможность сортировки по полям внутри строк. Для каждого поля предусмотрите свой набор параметров. Предметный указатель этой книги (Имеется в виду оригинал книги на английским языке. - <emphasis>Примеч. пер.</emphasis>) упорядочивался с параметрами: <emphasis>-df</emphasis> для терминов и <emphasis>-n</emphasis> для номеров страниц.</p>
   </section>
   <section>
    <title>
     <p>5.12 Сложные объявления</p>
    </title>
    <p>Иногда Си ругают за синтаксис объявлений, особенно тех, которые содержат в себе указатели на функции. Таким синтаксис получился в результате нашей попытки сделать похожими объявления объектов и их использование. В простых случаях этот синтаксис хорош, однако в сложных ситуациях он вызывает затруднения, поскольку объявления перенасыщены скобками и их невозможно читать слева направо. Проблему иллюстрирует различие следующих двух объявлений:</p>
    <p><code>int *f(); /* f: функция, возвращающая ук-ль на int */</code></p>
    <p><code>int (*pf)(); /* pf: ук-ль на ф-цию, возвращающую int */</code></p>
    <p>Приоритет префиксного оператора <strong>*</strong> ниже, чем приоритет <strong>()</strong>, поэтому во втором случае скобки необходимы.</p>
    <p>Хотя на практике по-настоящему сложные объявления встречаются редко, все же важно знать, как их понимать, а если потребуется, и как их конструировать. Укажем хороший способ: объявления можно синтезировать, двигаясь небольшими шагами с помощью <strong>typedef</strong>, этот способ рассмотрен в параграфе 6.7. В настоящем параграфе на примере двух программ, осуществляющих преобразования правильных Си-объявлений в соответствующие им словесные описания и обратно, мы демонстрируем иной способ конструирования объявлений. Словесное описание читается слева направо.</p>
    <p>Первая программа, <emphasis>dcl</emphasis>, - более сложная. Она преобразует Си-объявления в словесные описания так, как показано в следующих примерах:</p>
    <p><code>char **argv</code></p>
    <p>argv: указ. на указ. на char</p>
    <p><code>int (*daytab)[13]</code></p>
    <p>daytab: указ. на массив[13] из int</p>
    <p><code>int (*daytab)[13]</code></p>
    <p>daytab: массив[13] из указ. на int</p>
    <p><code>void *comp()</code></p>
    <p>comp: функц. возвр. указ. на void</p>
    <p><code>void (*comp)()</code></p>
    <p>comp: указ. на функц. возвр. void</p>
    <p><code>char (*(*x())[])()</code></p>
    <p>x: функц. возвр. указ. на массив[] из указ. на функц. возвр. char</p>
    <p><code>char(*(*x[3])())[5]</code></p>
    <p>x: массив[3] из указ. на функц. возвр. указ. на массив[5] из char</p>
    <p>Функция <emphasis>dcl</emphasis> в своей работе использует грамматику, специфицирующую объявитель. Эта грамматика строго изложена в параграфе 8.5 приложения A, а в упрощенном виде записывается так:</p>
    <p><code><emphasis>объявитель</emphasis>:              необязательные * <emphasis>собственно-объявитель</emphasis></code></p>
    <p><code><emphasis>собственно-объявитель</emphasis>:   <emphasis>имя</emphasis></code></p>
    <p><code>                         (<emphasis>объявитель</emphasis>)</code></p>
    <p><code>                         <emphasis>собственно-объявитель</emphasis>()</code></p>
    <p><code>                         <emphasis>собственно-объявитель</emphasis> [необязательный <emphasis>размер</emphasis>]</code></p>
    <p>Говоря простым языком, <emphasis>объявитель</emphasis> есть <emphasis>собственно-объявитель</emphasis>, перед которым может стоять * (т. е. одна или несколько звездочек), где <emphasis>собственно- объявитель</emphasis> есть <emphasis>имя</emphasis>, или <emphasis>объявитель</emphasis> в скобках, или <emphasis>собственно-объявитель</emphasis> с последующей парой скобок, или <emphasis>собственно-объявитель</emphasis> с последующей парой квадратных скобок, внутри которых может быть помещен <emphasis>размер</emphasis>.</p>
    <p>Эту грамматику можно использовать для грамматического разбора объявлений. Рассмотрим, например, такой объявитель:</p>
    <p><code>(*pfa[])()</code></p>
    <p>Имя <emphasis>pfa</emphasis> будет классифицировано как <emphasis>имя</emphasis> и, следовательно, как <emphasis>собственно- объявитель</emphasis>. Затем <emphasis>pfa[]</emphasis> будет распознано как <emphasis>собственно-объявитель</emphasis>, а <emphasis>*pfa[]</emphasis> - как <emphasis>объявитель</emphasis> и, следовательно, <emphasis>(*pfa[])</emphasis> есть <emphasis>собственно-объявитель</emphasis>. Далее, <emphasis>(*pfa[])()</emphasis> есть <emphasis>собственно-объявитель</emphasis> и, таким образом, <emphasis>объявитель</emphasis>. Этот грамматический разбор можно проиллюстрировать деревом разбора, приведенным на следующей странице (где <emphasis>собственно-объявитель</emphasis> обозначен более коротко, а именно <emphasis>собств.-объяв.</emphasis>).</p>
    <p>Сердцевиной программы обработки объявителя является пара функций <emphasis>dcl</emphasis> и <emphasis>dirdcl</emphasis>, осуществляющих грамматический разбор объявления согласно приведенной грамматике. Поскольку грамматика определена рекурсивно, эти функции обращаются друг к другу рекурсивно, по мере распознавания отдельных частей объявления. Метод, примененный в обсуждаемой программе для грамматического разбора, называется рекурсивным спуском.</p>
    <image l:href="#pic_12.jpg"/>
    <p><code>/* dcl: разбор объявителя */</code></p>
    <p><code>void dcl(void)</code></p>
    <p><code>{</code></p>
    <p><code> int ns;</code></p>
    <empty-line/>
    <p><code> for (ns = 0, gettoken() == '*';) /* подсчет звездочек */</code></p>
    <p><code>  ns++;</code></p>
    <empty-line/>
    <p><code> dirdcl();</code></p>
    <p><code> while(ns- › 0)</code></p>
    <p><code> strcat(out, "указ. на");</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* dirdcl: разбор собственно объявителя */</code></p>
    <p><code>void dirdcl(void)</code></p>
    <p><code>{</code></p>
    <p><code> int type;</code></p>
    <empty-line/>
    <p><code> if (tokentype == '(') {</code></p>
    <p><code>  dcl();</code></p>
    <p><code>  if (tokentype != ')')</code></p>
    <p><code>   printf("oшибкa: пропущена)\n");</code></p>
    <p><code> } else if (tokentype == NAME) /* имя переменной */</code></p>
    <p><code>  strcpy(name, token);</code></p>
    <p><code> else</code></p>
    <p><code>  printf("ошибка: должно быть name или (dcl)\n");</code></p>
    <empty-line/>
    <p><code> while((type = gettoken()) == PARENS || type == BRACKETS)</code></p>
    <p><code>  if (type == PARENS)</code></p>
    <p><code>   strcat(out, "функц. возвр.");</code></p>
    <p><code>  else {</code></p>
    <p><code>   strcat(out, " массив");</code></p>
    <p><code>   strcat(out, token);</code></p>
    <p><code>   strcat(out, " из");</code></p>
    <p><code>  }</code></p>
    <p><code>}</code></p>
    <p>Приведенные программы служат только иллюстративным целям и не вполне надежны. Что касается <emphasis>dcl</emphasis>, то ее возможности существенно ограничены. Она может работать только с простыми типами вроде <emphasis>char</emphasis> и <emphasis>int</emphasis> и не справляется с типами аргументов в функциях и с квалификаторами вроде <emphasis>const</emphasis>. Лишние пробелы для нее опасны. Она не предпринимает никаких мер по выходу из ошибочной ситуации, и поэтому неправильные описания также ей противопоказаны. Устранение этих недостатков мы оставляем для упражнений. Ниже приведены глобальные переменные и главная программа <emphasis>main</emphasis>.</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p><code>#include ‹string.h›</code></p>
    <p><code>#include ‹ctype.h›</code></p>
    <empty-line/>
    <p><code>#define MAXTOKEN 100</code></p>
    <empty-line/>
    <p><code>enum {NAME, PARENS, BRACKETS};</code></p>
    <empty-line/>
    <p><code>void dcl(void);</code></p>
    <p><code>void dirdcl(void);</code></p>
    <empty-line/>
    <p><code>int gettoken(void);</code></p>
    <p><code>int tokentype; /* тип последней лексемы */</code></p>
    <p><code>char token[MAXTOKEN]; /* текст последней лексемы */</code></p>
    <p><code>char name[MAXTOKEN]; /* имя */</code></p>
    <p><code>char datatype[MAXTOKEN]; /* тип = char, int и т.д. */</code></p>
    <p><code>char out[1000]; /* выдаваемый текст */</code></p>
    <empty-line/>
    <p><code>main() /* преобразование объявления в словесное описание */</code></p>
    <p><code>{</code></p>
    <p><code> while (gettoken() != EOF) {/* 1-я лексема в строке */</code></p>
    <p><code>  strcpy(datatype, token); /* это тип данных */</code></p>
    <p><code>  out[0] = '\0';</code></p>
    <p><code>  dcl(); /* разбор остальной части строки */</code></p>
    <p><code>  if (tokentype != '\n')</code></p>
    <p><code>   printf("синтаксическая ошибка\n");</code></p>
    <p><code>  printf("%s: %s %s\n", name, out, datatype);</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>gettoken</emphasis> пропускает пробелы и табуляции и затем получает следующую лексему из ввода: "лексема" (<emphasis>token</emphasis>) - это имя, или пара круглых скобок, или пара квадратных скобок (быть может, с помещенным в них числом), или любой другой единичный символ.</p>
    <p><code>int gettoken(void) /* возвращает следующую лексему */</code></p>
    <p><code>{</code></p>
    <p><code> int с, getch(void);</code></p>
    <p><code> void ungetch(int);</code></p>
    <p><code> char *p = token;</code></p>
    <empty-line/>
    <p><code> while ((c = getch()) == ' ' || с == '\t')</code></p>
    <p><code>  ;</code></p>
    <p><code> if (c == '(') {</code></p>
    <p><code>  if ((c = getch()) == ')' {</code></p>
    <p><code>   strcpy(token, "()");</code></p>
    <p><code>   return tokentype = PARENS;</code></p>
    <p><code>  } else {</code></p>
    <p><code>   ungetch(c);</code></p>
    <p><code>   return tokentype = '(';</code></p>
    <p><code>  }</code></p>
    <p><code> } else if (c == '[') {</code></p>
    <p><code>  for (*p++ = c; (*p++ = getch()) != ']';)</code></p>
    <p><code>   ;</code></p>
    <p><code>  *p = '\0';</code></p>
    <p><code>  return tokentype = BRACKETS;</code></p>
    <p><code> } else if (isalpha(c)) {</code></p>
    <p><code>  for (*p++ = c; isalnum(c = getch());)</code></p>
    <p><code>  *p++ = c;</code></p>
    <p><code>  *p = '\0';</code></p>
    <p><code>  ungetch(c);</code></p>
    <p><code>  return tokentype = NAME;</code></p>
    <p><code> } else</code></p>
    <p><code> return tokentype = c;</code></p>
    <p><code>}</code></p>
    <p>Функции <emphasis>getch</emphasis> и <emphasis>ungetch</emphasis> были рассмотрены в главе 4.</p>
    <p>Обратное преобразование реализуется легче, особенно если не придавать значения тому, что будут генерироваться лишние скобки. Программа <emphasis>undcl</emphasis> превращает фразу вроде "x есть функция, возвращающая указатель на массив указателей на функции, возвращающие <emphasis>char</emphasis>", которую мы будем представлять в виде</p>
    <p><code>х () * [] * () char</code></p>
    <p>в объявление</p>
    <p><code>char (*(*х())[])()</code></p>
    <p>Такой сокращенный входной синтаксис позволяет повторно пользоваться функцией <emphasis>gettoken</emphasis>. Функция <emphasis>undcl</emphasis> использует те же самые внешние переменные, что и <emphasis>dcl</emphasis>.</p>
    <p><code>/* undcl: преобразует словесное описание в объявление */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int type;</code></p>
    <p><code> char temp[MAXTOKEN];</code></p>
    <empty-line/>
    <p><code> while (gettoken() != EOF) {</code></p>
    <p><code>  strcpy(out, token);</code></p>
    <p><code>  while ((type = gettoken()) != '\n')</code></p>
    <p><code>   if (type == PARENS || type == BRACKETS)</code></p>
    <p><code>    strcat(out, token);</code></p>
    <p><code>   else if (type == '*') {</code></p>
    <p><code>    sprintf(temp, "(*%s)", out);</code></p>
    <p><code>    strcpy(out, temp);</code></p>
    <p><code>   } else if (type == NAME) {</code></p>
    <p><code>    sprintf(temp, "%s %s", token, out);</code></p>
    <p><code>    strcpy(out, temp);</code></p>
    <p><code>   } else</code></p>
    <p><code>    printf("неверный элемент %s в фразе\n", token);</code></p>
    <p><code>  printf("%s\n", out);</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p><strong>Упражнение 5.18</strong>. Видоизмените <emphasis>dcl</emphasis> таким образом, чтобы она обрабатывала ошибки во входной информации.</p>
    <p><strong>Упражнение 5.19</strong>. Модифицируйте <emphasis>undcl</emphasis> так, чтобы она не генерировала лишних скобок.</p>
    <p><strong>Упражнение 5.20</strong>. Расширьте возможности <emphasis>dcl</emphasis>, чтобы <emphasis>dcl</emphasis> обрабатывала объявления с типами аргументов функции, квалификаторами вроде <emphasis>const</emphasis> и т. п.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Глава 6. Структуры</p>
   </title>
   <section>
    <p><emphasis>Структура</emphasis> - это одна или несколько переменных (возможно, различных типов), которые для удобства работы с ними сгруппированы под одним именем. (В некоторых языках, в частности в Паскале, структуры называются записями.) Структуры помогают в организации сложных данных (особенно в больших программах), поскольку позволяют группу связанных между собой переменных трактовать не как множество отдельных элементов, а как единое целое.</p>
    <p>Традиционный пример структуры - строка платежной ведомости. Она содержит такие сведения о служащем, как его полное имя, адрес, номер карточки социального страхования, зарплата и т. д. Некоторые из этих характеристик сами могут быть структурами: например, полное имя состоит из нескольких компонент (фамилии, имени и отчества); аналогично адрес, и даже зарплата. Другой пример (более типичный для Си) - из области графики: точка есть пара координат, прямоугольник есть пара точек и т. д.</p>
    <p>Главные изменения, внесенные стандартом ANSI в отношении структур, - это введение для них операции присваивания. Структуры могут копироваться, над ними могут выполняться операции присваивания, их можно передавать функциям в качестве аргументов, а функции могут возвращать их в качестве результатов. В большинстве компиляторов уже давно реализованы эти возможности, но теперь они точно оговорены стандартом. Для автоматических структур и массивов теперь также допускается инициализация.</p>
   </section>
   <section>
    <title>
     <p>6.1 Основные сведения о структурах</p>
    </title>
    <p>Сконструируем несколько графических структур. В качестве основного объекта выступает точка с координатами <emphasis>x</emphasis> и <emphasis>y</emphasis> целого типа.</p>
    <image l:href="#fig6_1.jpg"/>
    <p>Указанные две компоненты можно поместить в структуру, объявленную, например, следующим образом:</p>
    <p><code>struct point {int x; int y;};</code></p>
    <p>Объявление структуры начинается с ключевого слова <strong>struct</strong> и содержит список объявлений, заключенный в фигурные скобки. За словом <strong>struct</strong> может следовать имя, называемое <emphasis>тегом структуры</emphasis> (от английского слова tag - ярлык, этикетка. - Примеч. пер.), <emphasis>point</emphasis> в нашем случае. Тег дает название структуре данного вида и далее может служить кратким обозначением той части объявления, которая заключена в фигурные скобки.</p>
    <p>Перечисленные в структуре переменные называются <emphasis>элементами</emphasis> (<emphasis>members</emphasis> - В некоторых изданиях, в том числе во 2-м издании на русским языке этой книги structure members переводится как члены структуры. - Примеч. ред). Имена элементов и тегов без каких-либо коллизий могут совпадать с именами обычных переменных (т. е. не элементов), так как они всегда различимы по контексту. Более того, одни и те же имена элементов могут встречаться в разных структурах, хотя, если следовать хорошему стилю программирования, лучше одинаковые имена давать только близким по смыслу объектам.</p>
    <p>Объявление структуры определяет тип. За правой фигурной скобкой, закрывающей список элементов, могут следовать переменные точно так же, как они могут быть указаны после названия любого базового типа. Таким образом, выражение</p>
    <p><code>struct {…} x, y, z;</code></p>
    <p>с точки зрения синтаксиса аналогично выражению</p>
    <p><code>int х, у, z;</code></p>
    <p>в том смысле, что и то и другое объявляет <emphasis>x</emphasis>, <emphasis>y</emphasis> и <emphasis>z</emphasis> переменными указанного типа; и то и другое приведет к выделению памяти соответствующего размера.</p>
    <p>Объявление структуры, не содержащей списка переменных, не резервирует памяти; оно просто описывает шаблон, или образец структуры. Однако если структура имеет тег, то этим тегом далее можно пользоваться при определении структурных объектов. Например, с помощью заданного выше описания структуры <emphasis>point</emphasis> строка</p>
    <p><code>struct point pt;</code></p>
    <p>определяет структурную переменную <emphasis>pt</emphasis> типа <emphasis>struct point</emphasis>. Структурную переменную при ее определении можно инициализировать, формируя список инициализаторов ее элементов в виде константных выражений:</p>
    <p><code>struct point maxpt = {320, 200};</code></p>
    <p>Инициализировать автоматические структуры можно также присваиванием или обращением к функции, возвращающей структуру соответствующего типа.</p>
    <p>Доступ к отдельному элементу структуры осуществляется посредством конструкции вида:</p>
    <p><code><emphasis>имя-структуры</emphasis>.<emphasis>элемент</emphasis></code></p>
    <p>Оператор доступа к элементу структуры <strong>.</strong> соединяет имя структуры и имя элемента. Чтобы напечатать, например, координаты точки <emphasis>pt</emphasis>, годится следующее обращение к <emphasis>printf</emphasis>:</p>
    <p><code>printf("%d, %d", pt.x, pt.y);</code></p>
    <p>Другой пример: чтобы вычислить расстояние от начала координат (0,0) до <emphasis>pt</emphasis>, можно написать</p>
    <p><code>double dist, sqrt(double); dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);</code></p>
    <p>Структуры могут быть вложены друг в друга. Одно из возможных представлений прямоугольника - это пара точек на углах одной из его диагоналей:</p>
    <image l:href="#fig6_2.jpg"/>
    <p><code>struct rect {struct point pt1; struct point pt2;};</code></p>
    <p>Структура <emphasis>rect</emphasis> содержит две структуры <emphasis>point</emphasis>. Если мы объявим <emphasis>screen</emphasis> как</p>
    <p><code>struct rect screen;</code></p>
    <p>то</p>
    <p><code>screen.pt1.x</code></p>
    <p>обращается к координате <emphasis>x</emphasis> точки <emphasis>pt1</emphasis> из <emphasis>screen</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>6.2 Структуры и функции</p>
    </title>
    <p>Единственно возможные операции над структурами - это их копирование, присваивание, взятие адреса с помощью &amp; и осуществление доступа к ее элементам. Копирование и присваивание также включают в себя передачу функциям аргументов и возврат ими значений. Структуры нельзя сравнивать. Инициализировать структуру можно списком константных значений ее элементов; автоматическую структуру также можно инициализировать присваиванием.</p>
    <p>Чтобы лучше познакомиться со структурами, напишем несколько функций, манипулирующих точками и прямоугольниками. Возникает вопрос: а как передавать функциям названные объекты? Существует по крайней мере три подхода: передавать компоненты по отдельности, передавать всю структуру целиком и передавать указатель на структуру. Каждый подход имеет свои плюсы и минусы.</p>
    <p>Первая функция, <emphasis>makepoint</emphasis>, получает два целых значения и возвращает структуру <emphasis>point</emphasis>.</p>
    <p><code>/* makepoint: формирует точку по компонентам x и y */ </code></p>
    <p><code>struct point makepoint(int х, int у) {</code></p>
    <p><code> struct point temp;</code></p>
    <p><code> temp.x = х;</code></p>
    <p><code> temp.у = у;</code></p>
    <p><code> return temp;</code></p>
    <p><code>}</code></p>
    <p>Заметим: никакого конфликта между именем аргумента и именем элемента структуры не возникает; более того, сходство подчеркивает родство обозначаемых им объектов.</p>
    <p>Теперь с помощью <emphasis>makepoint</emphasis> можно выполнять динамическую инициализацию любой структуры или формировать структурные аргументы для той или иной функции:</p>
    <p><code>struct rect screen; </code></p>
    <p><code>struct point middle; </code></p>
    <p><code>struct point makepoint(int, int); </code></p>
    <empty-line/>
    <p><code>screen.pt1 = makepoint(0, 0); </code></p>
    <p><code>screen.pt2 = makepoint(XMAX, YMAX); </code></p>
    <p><code>middle = makepoint((screen.pt1.x + screen.pt2.x)/2, (screen.pt1.y + screen.pt2.y)/2);</code></p>
    <p>Следующий шаг состоит в определении ряда функций, реализующих различные операции над точками. В качестве примера рассмотрим следующую функцию:</p>
    <p><code>/* addpoint: сложение двух точек */ </code></p>
    <p><code>struct point addpoint(struct point p1, struct point p2) </code></p>
    <p><code>{</code></p>
    <p><code> p1.x += p2.x;</code></p>
    <p><code> p1.y += p2.y;</code></p>
    <p><code> return p1;</code></p>
    <p><code>}</code></p>
    <p>Здесь оба аргумента и возвращаемое значение - структуры. Мы увеличиваем компоненты прямо в р1 и не используем для этого временной переменной, чтобы подчеркнуть, что структурные параметры передаются по значению так же, как и любые другие.</p>
    <p>В качестве другого примера приведем функцию <emphasis>ptinrect</emphasis>, которая проверяет: находится ли точка внутри прямоугольника, относительно которого мы принимаем соглашение, что в него входят его левая и нижняя стороны, но не входят верхняя и правая.</p>
    <p><code>/* ptinrect: возвращает 1, если p в r, и 0 в противном случае */</code></p>
    <p><code>int ptinrect(struct point р, struct rect r) {</code></p>
    <p><code> return p.x &gt;= r.pt1.x &amp;&amp; p.x &lt; r.pt2.x  &amp;&amp; p.y &gt;= r.pt1.y &amp;&amp; p.y &lt; r.pt2.y;</code></p>
    <p><code>} </code></p>
    <p>Здесь предполагается, что прямоугольник представлен в стандартном виде, т.е. координаты точки <emphasis>pt1</emphasis> меньше соответствующих координат точки <emphasis>pt2</emphasis>. Следующая функция гарантирует получение прямоугольника в каноническом виде. </p>
    <p><code>#define min(a, b) ((a) &lt; (b) ? (a) : (b))</code></p>
    <p><code>#define max(a, b) ((a) &gt; (b) ? (a) : (b))</code></p>
    <empty-line/>
    <p><code>/* canonrect: канонизация координат прямоугольника */</code></p>
    <p><code>struct rect canonrect(struct rect r)</code></p>
    <p><code>{</code></p>
    <p><code> struct rect temp;</code></p>
    <p><code> temp.pt1.x = min(r.pt1.x, r.pt2.x);</code></p>
    <p><code> temp.ptl.y = min(r.pt1.y, r.pt2.у);</code></p>
    <p><code> temp.pt2.x = max(r.pt1.x, r.pt2.x);</code></p>
    <p><code> temp.pt2.y = max(r.pt1.y, r.pt2.y);</code></p>
    <p><code> return temp;</code></p>
    <p><code>}</code></p>
    <p>Если функции передается большая структура, то, чем копировать ее целиком, эффективнее передать указатель на нее. Указатели на структуры ничем не отличаются от указателей на обычные переменные. Объявление</p>
    <p><code>struct point *pp;</code></p>
    <p>сообщает, что <emphasis>pp</emphasis> - это указатель на структуру типа <emphasis>struct point</emphasis>. Если <emphasis>pp</emphasis> указывает на структуру <emphasis>point</emphasis>, то <emphasis>*pp</emphasis> - это сама структура, а <emphasis>(*pp).x</emphasis> и <emphasis>(*pp).y</emphasis> - ее элементы. Используя указатель <emphasis>pp</emphasis>, мы могли бы написать</p>
    <p><code>struct point origin, *pp;</code></p>
    <p><code>pp =&amp;origin; </code></p>
    <p><code>printf("origin: (%d,%d)\n", (*pp).x, (*pp).y);</code></p>
    <p>Скобки в <emphasis>(*pp).x</emphasis> необходимы, поскольку приоритет оператора <strong>.</strong> выше, чем приоритет <strong>*</strong>. Выражение <emphasis>*pp.x</emphasis> будет проинтерпретировано как <emphasis>*(pp.x)</emphasis>, что неверно, поскольку <emphasis>pp.x</emphasis> не является указателем.</p>
    <p>Указатели на структуры используются весьма часто, поэтому для доступа к ее элементам была придумана еще одна, более короткая форма записи. Если <emphasis>p</emphasis> - указатель на структуру, то</p>
    <p>р-›<code><emphasis>элемент-структуры</emphasis></code></p>
    <p>есть ее отдельный элемент. (Оператор <strong>-›</strong> состоит из знака -, за которым сразу следует знак ›.) Поэтому <emphasis>printf</emphasis> можно переписать в виде</p>
    <p>printf("origin: (%d,%d)\n", pp-›х, pp-›y);</p>
    <p>Операторы. и -› выполняются слева направо. Таким образом, при наличии объявления</p>
    <p><code>struct rect r, *rp = &amp;r;</code></p>
    <p>следующие четыре выражения будут эквивалентны:</p>
    <p><code>r.pt1.x rp-›pt1.x (r.pt1).x (rp-›pt1).x</code></p>
    <p>Операторы доступа к элементам структуры <strong>.</strong> и <strong>-›</strong> вместе с операторами вызова функции <strong>()</strong> и индексации массива <strong>[]</strong> занимают самое высокое положение в иерархии приоритетов и выполняются раньше любых других операторов. Например, если задано объявление</p>
    <p><code>struct {int len; char *str;} *p;</code></p>
    <p>то</p>
    <p><code>++p-›len</code></p>
    <p>увеличит на 1 значение элемента структуры <emphasis>len</emphasis>, а не указатель <emphasis>p</emphasis>, поскольку в этом выражении как бы неявно присутствуют скобки: <emphasis>++(p-›len)</emphasis>. Чтобы изменить порядок выполнения операций, нужны явные скобки. Так, в <emphasis>(++р)-›len</emphasis>, прежде чем взять значение <emphasis>len</emphasis>, программа прирастит указатель <emphasis>p</emphasis>. В <emphasis>(р++)-›len</emphasis> указатель <emphasis>p</emphasis> увеличится после того, как будет взято значение <emphasis>len</emphasis> (в последнем случае скобки не обязательны).</p>
    <p>По тем же правилам <emphasis>*p-›str</emphasis> обозначает содержимое объекта, на который указывает <emphasis>str</emphasis>; <emphasis>*p-›str++</emphasis> прирастит указатель <emphasis>str</emphasis> после получения значения объекта, на который он указывал (как и в выражении <emphasis>*s++</emphasis>), <emphasis>(*p-›str)++</emphasis> увеличит значение объекта, на который указывает <emphasis>str</emphasis>; <emphasis>*p++-›str</emphasis> увеличит <emphasis>p</emphasis> после получения того, на что указывает <emphasis>str</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>6.3 Массивы структур</p>
    </title>
    <p>Рассмотрим программу, определяющую число вхождений каждого ключевого слова в текст Си-программы. Нам нужно уметь хранить ключевые слова в виде массива строк и счетчики ключевых слов в виде массива целых. Один из возможных вариантов - это иметь два параллельных массива:</p>
    <p><code>char *keyword[NKEYS]; </code></p>
    <p><code>int keycount[NKEYS];</code></p>
    <p>Однако именно тот факт, что они параллельны, подсказывает нам другую организацию хранения - через массив структур. Каждое ключевое слово можно описать парой характеристик</p>
    <p><code>char *word; </code></p>
    <p><code>int count;</code></p>
    <p>Такие пары составляют массив. Объявление</p>
    <p><code>struct key {</code></p>
    <p><code> char *word;</code></p>
    <p><code> int count;</code></p>
    <p><code>} keytab[NKEYS];</code></p>
    <p>объявляет структуру типа <emphasis>key</emphasis> и определяет массив <emphasis>keytab</emphasis>, каждый элемент которого является структурой этого типа и которому где-то будет выделена память. Это же можно записать и по-другому:</p>
    <p><code>struct key {</code></p>
    <p><code> char *word;</code></p>
    <p><code> int count;</code></p>
    <p><code>};</code></p>
    <p><code>struct key keytab[NKEYS];</code></p>
    <p>Так как <emphasis>keytab</emphasis> содержит постоянный набор имен, его легче всего сделать внешним массивом и инициализировать один раз в момент определения. Инициализация структур аналогична ранее демонстрировавшимся инициализациям - за определением следует список инициализаторов, заключенный в фигурные скобки:</p>
    <p><code>struct key {</code></p>
    <p><code> char *word;</code></p>
    <p><code> int count;</code></p>
    <p><code>} keytab[] = {</code></p>
    <p><code> "auto", 0,</code></p>
    <p><code> "break", 0,</code></p>
    <p><code> "case", 0,</code></p>
    <p><code> "char", 0,</code></p>
    <p><code> "const", 0,</code></p>
    <p><code> "continue", 0,</code></p>
    <p><code> "default", 0,</code></p>
    <p><code> /*…*/</code></p>
    <p><code> "unsigned", 0,</code></p>
    <p><code> "void", 0,</code></p>
    <p><code> "volatile", 0,</code></p>
    <p><code> "while", 0</code></p>
    <p><code>};</code></p>
    <p>Инициализаторы задаются парами, чтобы соответствовать конфигурации структуры. Строго говоря, пару инициализаторов для каждой отдельной структуры следовало бы заключить в фигурные скобки, как, например, в</p>
    <p><code>{"auto", 0}, </code></p>
    <p><code>{"break", 0}, </code></p>
    <p><code>{"case", 0},</code></p>
    <p><code>…</code></p>
    <p>Однако когда инициализаторы - простые константы или строки символов и все они имеются в наличии, во внутренних скобках нет необходимости. Число элементов массива <emphasis>keytab</emphasis> будет вычислено по количеству инициализаторов, поскольку они представлены полностью, а внутри квадратных скобок "[]" ничего не задано.</p>
    <p>Программа подсчета ключевых слов начинается с определения <emphasis>keytab</emphasis>. Программа <emphasis>main</emphasis> читает ввод, многократно обращаясь к функции <emphasis>getword</emphasis> и получая на каждом ее вызове очередное слово. Каждое слово ищется в <emphasis>keytab</emphasis>. Для этого используется функция бинарного поиска, которую мы написали в главе 3. Список ключевых слов должен быть упорядочен в алфавитном порядке.</p>
    <p><code>#include &lt;stdio.h&gt;</code></p>
    <p><code>#include &lt;ctype.h&gt;</code></p>
    <p><code>#include &lt;string.h&gt;</code></p>
    <empty-line/>
    <p><code>#define MAXWORD 100</code></p>
    <empty-line/>
    <p><code>int getword(char *, int);</code></p>
    <p><code>int binsearch(char *, struct key *, int);</code></p>
    <empty-line/>
    <p><code>/* подсчет ключевых слов Си */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> int n;</code></p>
    <p><code> char word[MAXWORD];</code></p>
    <empty-line/>
    <p><code> while(getword(word, MAXWORD) != EOF)</code></p>
    <p><code>  if (isalpha(word[0]))</code></p>
    <p><code>   if ((n = binsearch(word, keytab, NKEYS)) &gt;= 0)</code></p>
    <p><code>    keytab[n].count++;</code></p>
    <p><code> for (n = 0; n &lt; NKEYS; n++)</code></p>
    <p><code>  if (keytab[n].count &gt; 0)</code></p>
    <p><code>   printf("%4d %s\n", keytab[n].count, keytab[n].word);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* binsearch: найти слово в tab[0]...tab[n-1] */</code></p>
    <p><code>int binsearch(char *word, struct key tab[], int n)</code></p>
    <p><code>{</code></p>
    <p><code> int cond;</code></p>
    <p><code> int low, high, mid;</code></p>
    <empty-line/>
    <p><code> low = 0;</code></p>
    <p><code> high = n-1;</code></p>
    <p><code> while (low &lt;= high) {</code></p>
    <p><code>  mid = (low + high)/2;</code></p>
    <p><code>  if ((cond = strcmp(word, tab[mid].word)) &lt; 0)</code></p>
    <p><code>   high = mid - 1;</code></p>
    <p><code>  else if (cond &gt; 0)</code></p>
    <p><code>   low = mid + 1;</code></p>
    <p><code>  else</code></p>
    <p><code>   return mid;</code></p>
    <p><code> }</code></p>
    <p><code> return -1;</code></p>
    <p><code>}</code></p>
    <p>Чуть позже мы рассмотрим функцию <emphasis>getword</emphasis>, а сейчас нам достаточно знать, что при каждом ее вызове получается очередное слово, которое запоминается в массиве, заданном первым аргументом.</p>
    <p>NKEYS - количество ключевых слов в <emphasis>keytab</emphasis>. Хотя мы могли бы подсчитать число таких слов вручную, гораздо легче и безопасней сделать это с помощью машины, особенно если список ключевых слов может быть изменен. Одно из возможных решений - поместить в конец списка инициализаторов пустой указатель (NULL) и затем перебирать в цикле элементы <emphasis>keytab</emphasis>, пока не встретится концевой элемент.</p>
    <p>Но возможно и более простое решение. Поскольку размер массива полностью определен во время компиляции и равен произведению количества элементов массива на размер его отдельного элемента, число элементов массива можно вычислить по формуле</p>
    <p><code><emphasis>размер</emphasis> keytab / <emphasis>размер</emphasis> struct key</code></p>
    <p>В Си имеется унарный оператор <strong>sizeof</strong>, который работает во время компиляции. Его можно применять для вычисления размера любого объекта. Выражения</p>
    <p><code>sizeof <emphasis>объект</emphasis></code></p>
    <p>и</p>
    <p><code>sizeof (<emphasis>имя типа</emphasis>)</code></p>
    <p>выдают целые значения, равные размеру указанного объекта или типа в байтах. (Строго говоря, <strong>sizeof</strong> выдает беззнаковое целое, тип которого <strong>size_t</strong> определена заголовочном файле <strong>‹stddef.h›</strong>.) Что касается объекта, то это может быть переменная, массив или структура. В качестве имени типа может выступать имя базового типа (<emphasis>int</emphasis>, <emphasis>double</emphasis>…) или имя производного типа, например структуры или указателя.</p>
    <p>В нашем случае, чтобы вычислить количество ключевых слов, размер массива надо поделить на размер одного элемента. Указанное вычисление используется в инструкции <emphasis>#define</emphasis> для установки значения NKEYS:</p>
    <p><code>#define NKEYS (sizeof keytab / sizeof(struct key))</code></p>
    <p>Этот же результат можно получить другим способом - поделить размер массива на размер какого-то его конкретного элемента:</p>
    <p><code>#define NKEYS (sizeof keytab / sizeof keytab[0])</code></p>
    <p>Преимущество такого рода записей в том, что их не надо коppектировать при изменении типа.</p>
    <p>Поскольку препроцессор не обращает внимания на имена типов, оператор <strong>sizeof</strong> нельзя применять в <strong>#if</strong>. Но в <strong>#define</strong> выражение препроцессором не вычисляется, так что предложенная нами запись допустима.</p>
    <p>Теперь поговорим о функции <emphasis>getword</emphasis>. Мы написали <emphasis>getword</emphasis> в несколько более общем виде, чем требуется для нашей программы, но она от этого не стала заметно сложнее. Функция <emphasis>getword</emphasis> берет из входного потока следующее "слово". Под словом понимается цепочка букв-цифр, начинающаяся с буквы, или отдельный символ, отличный от символа-разделителя. В случае конца файла функция возвращает EOF, в остальных случаях ее значением является код первого символа слова или сам символ, если это не буква.</p>
    <p><code>/* getword: принимает следующее слово или символ из ввода */ </code></p>
    <p><code>int getword (char *word, int lim) {</code></p>
    <p><code> int c, getch(void);</code></p>
    <p><code> void ungetch(int);</code></p>
    <p><code> char *w = word;</code></p>
    <empty-line/>
    <p><code> while (isspace(c = getch()))</code></p>
    <p><code>  ;</code></p>
    <p><code> if (c != EOF)</code></p>
    <p><code>  *w++ = c;</code></p>
    <p><code> if (!isalpha(c)) {</code></p>
    <p><code>  *w = '\0';</code></p>
    <p><code>  return c;</code></p>
    <p><code> }</code></p>
    <p><code> for (; --lim › 0; w++)</code></p>
    <p><code>  if (!isalnum(*w = getch())) {</code></p>
    <p><code>   ungetch(*w);</code></p>
    <p><code>   break;</code></p>
    <p><code>  }</code></p>
    <p><code> *w = '\0';</code></p>
    <p><code> return word[0];</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>getword</emphasis> обращается к <emphasis>getch</emphasis> и <emphasis>ungetch</emphasis>, которые мы написали в главе 4. По завершении набора букв-цифр оказывается, что <emphasis>getword</emphasis> взяла лишний символ. Обращение к <emphasis>ungetch</emphasis> позволяет вернуть его назад во входной поток. В <emphasis>getword</emphasis> используются также <strong>isspace</strong> - для пропуска символов-разделителей, <strong>isalpha</strong> - для идентификации букв и <strong>isalnum</strong> - для распознавания букв-цифр. Все они описаны в стандартном заголовочном файле <strong>‹ctype.h›</strong>.</p>
    <p><strong>Упражнение 6.1</strong>. Haшa вepcия <emphasis>getword</emphasis> не обрабатывает должным образом знак подчеркивания, строковые константы, комментарии и управляющие строки препроцессора. Напишите более совершенный вариант программы.</p>
   </section>
   <section>
    <title>
     <p>6.4 Указатели на структуры</p>
    </title>
    <p>Для иллюстрации некоторых моментов, касающихся указателей на структуры и массивов структур, перепишем программу подсчета ключевых слов, пользуясь для получения элементов массива вместо индексов указателями.</p>
    <p>Внешнее объявление массива <emphasis>keytab</emphasis> остается без изменения, a <emphasis>main</emphasis> и <emphasis>binsearch</emphasis> нужно модифицировать.</p>
    <p><code>#include &lt;stdio.h&gt;</code></p>
    <p><code>#include &lt;ctype.h&gt;</code></p>
    <p><code>#include &lt;string.h&gt;</code></p>
    <p><code>#define MAXWORD 100</code></p>
    <empty-line/>
    <p><code>int getword(char *, int);</code></p>
    <p><code>struct key *binsearch(char *, struct key *, int);</code></p>
    <empty-line/>
    <p><code>/* подсчет ключевых слов Си: версия с указателями */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> char word[MAXWORD];</code></p>
    <p><code> struct key *p;</code></p>
    <p><code> while (getword(word, MAXWORD) != EOF)</code></p>
    <p><code>  if (isalpha(word[0]))</code></p>
    <p><code>   if ((p = binsearch(word, keytab, NKEYS)) != NULL)</code></p>
    <p><code>    p-&gt;count++;</code></p>
    <p><code>   for (p = keytab; p &lt; keytab + NKEYS; p++)</code></p>
    <p><code>    if (p-&gt;count &gt; 0)</code></p>
    <p><code>     printf("%4d %s\n", p-&gt;count, p-&gt;word);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* binsearch: найти слово word в tab[0]...tab[n-1] */</code></p>
    <p><code>struct key *binsearch(char *word, struct key *tab, int n)</code></p>
    <p><code>{</code></p>
    <p><code> int cond;</code></p>
    <p><code> struct key *low = &amp;tab[0];</code></p>
    <p><code> struct key *high = &amp;tab[n];</code></p>
    <p><code> struct key *mid;</code></p>
    <p><code> while (low &lt; high) {</code></p>
    <p><code>  mid = low + (high - low) / 2;</code></p>
    <p><code>  if ((cond = strcmp(word, mid-&gt;word)) &lt; 0)</code></p>
    <p><code>   high = mid;</code></p>
    <p><code>  else if (cond &gt; 0)</code></p>
    <p><code>   low = mid + 1;</code></p>
    <p><code>  else</code></p>
    <p><code>   return mid;</code></p>
    <p><code> }</code></p>
    <p><code> return NULL;</code></p>
    <p><code>}</code></p>
    <p>Некоторые детали этой программы требуют пояснений. Во-первых, описание функции <emphasis>binsearch</emphasis> должно отражать тот факт, что она возвращает указатель на <emphasis>struct key</emphasis>, а не целое, это объявлено как в прототипе функции, так и в функции <emphasis>binsearch</emphasis>. Если <emphasis>binsearch</emphasis> находит слово, то она выдает указатель на него, в противном случае она возвращает NULL. Во-вторых, к элементам <emphasis>keytab</emphasis> доступ в нашей программе осуществляется через указатели. Это потребовало значительных изменений в <emphasis>binsearch</emphasis>. Инициализаторами для <emphasis>low</emphasis> и <emphasis>high</emphasis> теперь служат указатели на начало и на место сразу после конца массива. Вычисление положения среднего элемента с помощью формулы</p>
    <p><code>mid = (low + high) / 2 /* НЕВЕРНО */</code></p>
    <p>не годится, поскольку указатели нельзя складывать. Однако к ним можно применить операцию вычитания, и так как <emphasis>high-low</emphasis> есть число элементов, присваивание</p>
    <p><code>mid = low + (high-low) / 2</code></p>
    <p>превратит <emphasis>mid</emphasis> в указатель на элемент, лежащий посередине между <emphasis>low</emphasis> и <emphasis>high</emphasis>.</p>
    <p>Самое важное при переходе на новый вариант программы - сделать так, чтобы не генерировались неправильные указатели и не было попыток обратиться за пределы массива. Проблема в том, что и &amp;<emphasis>tab[-1]</emphasis>, и <emphasis>&amp;tab[n]</emphasis> находятся вне границ массива. Первый адрес определенно неверен, нельзя также осуществить доступ и по второму адресу. По правилам языка, однако, гарантируется, что адрес ячейки памяти, следующей сразу за концом массива (т. е. <emphasis>&amp;tab[n]</emphasis>), в арифметике с указателями воспринимается правильно.</p>
    <p>В главной программе <emphasis>main</emphasis> мы написали</p>
    <p><code>for (р = keytab; р &lt; keytab + NKEYS; р++)</code></p>
    <p>Если <emphasis>p</emphasis> - это указатель на структуру, то при выполнении операций с <emphasis>р</emphasis> учитывается размер структуры. Поэтому <emphasis>р++</emphasis> увеличит р на такую величину, чтобы выйти на следующий структурный элемент массива, а проверка условия вовремя остановит цикл. </p>
    <p>Не следует, однако, полагать, что размер структуры равен сумме размеров ее элементов. Вследствие выравнивания объектов разной длины в структуре могут появляться безымянные "дыры". Например, если переменная типа <emphasis>char</emphasis> занимает один байт, а <emphasis>int</emphasis> - четыре байта, то для структуры </p>
    <p><code>struct { </code></p>
    <p><code> char с; </code></p>
    <p><code> int i;</code></p>
    <p><code>};</code></p>
    <p>может потребоваться восемь байтов, а не пять. Оператор <emphasis>sizeof</emphasis> возвращает правильное значение. </p>
    <p>Наконец, несколько слов относительно формата программы. Если функция возвращает значение сложного типа, как, например, в нашем случае она возвращает указатель на структуру: </p>
    <p><code>struct key *binsearch(char *word, struct key *tab, int n)</code></p>
    <p>то "высмотреть" имя функции оказывается совсем не просто. В подобных случаях иногда пишут так: </p>
    <p><code>struct key *</code></p>
    <p><code>binsearch(char *word, struct key *tab, int n)</code></p>
    <p>Какой форме отдать предпочтение - дело вкуса. Выберите ту, которая больше всего вам нравится, и придерживайтесь ее. </p>
   </section>
   <section>
    <title>
     <p>6.5 Структуры со ссылками на себя</p>
    </title>
    <p>Предположим, что мы хотим решить более общую задачу - написать программу, подсчитывающую частоту встречаемости для любых слов входного потока. Так как список слов заранее не известен, мы не можем предварительно упорядочить его и применить бинарный поиск. Было бы неразумно пользоваться и линейным поиском каждого полученного слова, чтобы определять, встречалось оно ранее или нет - в этом случае программа работала бы слишком медленно. (Более точная оценка: время работы такой программы пропорционально квадрату количества слов.) Как можно организовать данные, чтобы эффективно справиться со списком произвольных слов? </p>
    <p>Один из способов - постоянно поддерживать упорядоченность уже полученных слов, помещая каждое новое слово в такое место, чтобы не нарушалась имеющаяся упорядоченность. Делать это передвижкой слов в линейном массиве не следует, - хотя бы потому, что указанная процедура тоже слишком долгая. Вместо этого мы воспользуемся структурой данных, называемой бинарным деревом. </p>
    <p>В дереве на каждое отдельное слово предусмотрен "узел", который содержит: </p>
    <p><emphasis>- указатель на текст слова;</emphasis></p>
    <p><emphasis>- счетчик числа встречаемости;</emphasis></p>
    <p><emphasis>- указатель на левый сыновний узел;</emphasis></p>
    <p><emphasis>- указатель на правый сыновний узел.</emphasis> </p>
    <p>У каждого узла может быть один или два сына, или узел вообще может не иметь сыновей. </p>
    <p>Узлы в дереве располагаются так, что по отношению к любому узлу левое поддерево содержит только те слова, которые лексикографически меньше, чем слово данного узла, а правое - слова, которые больше него. Вот как выглядит дерево, построенное для фразы "<emphasis>now is the time for all good men to come to the aid of their party</emphasis>" ("настало время всем добрым людям помочь своей партии"), по завершении процесса, в котором для каждого нового слова в него добавлялся новый узел: </p>
    <image l:href="#fig6_3.jpg"/>
    <p>Чтобы определить, помещено ли уже в дерево вновь поступившее слово, начинают с корня, сравнивая это слово со словом из корневого узла. Если они совпали, то ответ на вопрос - положительный. Если новое слово меньше слова из дерева, то поиск продолжается в левом поддереве, если больше, то - в правом. Если же в выбранном направлении поддерева не оказалось, то этого слова в дереве нет, а пустующая позиция, говорящая об отсутствии поддерева, как раз и есть то место, куда нужно "подвесить" узел с новым словом. Описанный процесс по сути рекурсивен, так как поиск в любом узле использует результат поиска в одном из своих сыновних узлов. В соответствии с этим для добавления узла и печати дерева здесь наиболее естественно применить рекурсивные функции. </p>
    <p>Вернемся к описанию узла, которое удобно представить в виде структуры с четырьмя компонентами: </p>
    <p><code>struct tnode { /* узел дерева */</code></p>
    <p><code> char *word; /* указатель на текст */</code></p>
    <p><code> int count; /* число вхождений */</code></p>
    <p><code> struct tnode *left; /* левый сын */</code></p>
    <p><code> struct tnode *right; /* правый сын */</code></p>
    <p><code>};</code></p>
    <p>Приведенное рекурсивное определение узла может показаться рискованным, но оно правильное. Структура не может включать саму себя, но ведь </p>
    <p><code>struct tnode *left;</code></p>
    <p>объявляет <emphasis>left</emphasis> как указатель на <emphasis>tnode</emphasis>, а не сам <emphasis>tnode</emphasis>. </p>
    <p>Иногда возникает потребность во взаимоссылающихся структурах: двух структурах, ссылающихся друг на друга. Прием, позволяющий справиться с этой задачей, демонстрируется следующим фрагментом: </p>
    <p><code>struct t {</code></p>
    <p><code> ...</code></p>
    <p><code> struct s *p; /* р указывает на s */</code></p>
    <p><code>};</code></p>
    <p><code>struct s {</code></p>
    <p><code> ... struct t *q; /* q указывает на t */</code></p>
    <p><code>};</code></p>
    <p>Вся программа удивительно мала - правда, она использует вспомогательные программы вроде <emphasis>getword</emphasis>, уже написанные нами. Главная программа читает слова с помощью <emphasis>getword</emphasis> и вставляет их в дерево посредством <emphasis>addtree</emphasis>. </p>
    <p><code>#include &lt;stdio.h&gt;</code></p>
    <p><code>#include &lt;ctype.h&gt;</code></p>
    <p><code>#include &lt;string.h&gt; </code></p>
    <empty-line/>
    <p><code>#define MAXWORD 100</code></p>
    <empty-line/>
    <p><code>struct tnode *addtree(struct tnode *, char *);</code></p>
    <p><code>void treeprint(struct tnode *);</code></p>
    <p><code>int getword(char *, int);</code></p>
    <empty-line/>
    <p><code>/* подсчет частоты встречаемости слов */</code></p>
    <p><code>main()</code></p>
    <p><code>{</code></p>
    <p><code> struct tnode *root;</code></p>
    <p><code> char word[MAXWORD];</code></p>
    <empty-line/>
    <p><code> root = NULL;</code></p>
    <p><code> while (getword (word, MAXWORD) != EOF)</code></p>
    <p><code>  if (isalpha(word[0])) root = addtree(root, word);</code></p>
    <p><code> treeprint(root);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>addtree</emphasis> рекурсивна. Первое слово функция <emphasis>main</emphasis> помещает на верхний уровень дерева (корень дерева). Каждое вновь поступившее слово сравнивается со словом узла и "погружается" или в левое, или в правое поддерево с помощью рекурсивного обращения к <emphasis>addtree</emphasis>. Через некоторое время это слово обязательно либо совпадет с каким-нибудь из имеющихся в дереве слов (в этом случае к счетчику будет добавлена 1), либо программа встретит пустую позицию, что послужит сигналом для создания нового узла и добавления его к дереву. Создание нового узла сопровождается тем, что <emphasis>addtree</emphasis> возвращает на него указатель, который вставляется в узел родителя. </p>
    <p><code>struct tnode *talloc(void);</code></p>
    <p><code>char *strdup(char *); </code></p>
    <empty-line/>
    <p><code>/* addtree: добавляет узел со словом w в р или ниже него */ </code></p>
    <p><code>struct tnode *addtree(struct tnode *p, char *w)</code></p>
    <p><code>{</code></p>
    <p><code> int cond;</code></p>
    <empty-line/>
    <p><code> if (р == NULL) { /* слово встречается впервые */</code></p>
    <p><code>  p = talloc(); /* создается новый узел */</code></p>
    <p><code>  p-&gt;word = strdup(w);</code></p>
    <p><code>  p-&gt;count = 1;</code></p>
    <p><code>  p-&gt;left = p-&gt;right = NULL;</code></p>
    <p><code> } else if ((cond = strcmp(w, p-&gt;word)) == 0)</code></p>
    <p><code>  p-&gt;count++; /* это слово уже встречалось */</code></p>
    <p><code> else if (cond &lt; 0) /* меньше корня левого поддерева */</code></p>
    <p><code>  p-&gt;left = addtree(p-&gt;left, w);</code></p>
    <p><code> else /* больше корня правого поддерева */</code></p>
    <p><code>  p-&gt;right = addtree(p-&gt;right, w);</code></p>
    <p><code> return p;</code></p>
    <p><code>}</code></p>
    <p>Память для нового узла запрашивается с помощью программы <emphasis>talloc</emphasis>, которая возвращает указатель на свободное пространство, достаточное для хранения одного узла дерева, а копирование нового слова в отдельное место памяти осуществляется с помощью <emphasis>strdup</emphasis>. (Мы рассмотрим эти программы чуть позже.) В тот (и только в тот) момент, когда к дереву подвешивается новый узел, происходит инициализация счетчика и обнуление указателей на сыновей. Мы опустили (что неразумно) контроль ошибок, который должен выполняться при получении значений от <emphasis>strdup</emphasis> и <emphasis>talloc</emphasis>.</p>
    <p>Функция <emphasis>treeprint</emphasis> печатает дерево в лексикографическом порядке: для каждого узла она печатает его левое поддерево (все слова, которые меньше слова данного узла), затем само слово и, наконец, правое поддерево (слова, которые больше слова данного узла).</p>
    <p><code>/* treeprint: упорядоченная печать дерева р */ </code></p>
    <p><code>void treeprint(struct tnode *p) </code></p>
    <p><code>{</code></p>
    <p><code> if (p != NULL) {</code></p>
    <p><code>  treeprint (p-›left);</code></p>
    <p><code>  printf("%4d %s\n", p-›count, p-›word);</code></p>
    <p><code>  treeprint(p-›right);</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>Если вы не уверены, что досконально разобрались в том, как работает рекурсия, "проиграйте" действия <emphasis>treeprint</emphasis> на дереве, приведенном выше. Практическое замечание: если дерево "несбалансировано" (что бывает, когда слова поступают не в случайном порядке), то время работы программы может сильно возрасти. Худший вариант, когда слова уже упорядочены; в этом случае затраты на вычисления будут такими же, как при линейном поиске. Существуют обобщения бинарного дерева, которые не страдают этим недостатком, но здесь мы их не описываем.</p>
    <p>Прежде чем завершить обсуждение этого примера, сделаем краткое отступление от темы и поговорим о механизме запроса памяти. Очевидно, хотелось бы иметь всего лишь одну функцию, выделяющую память, даже если эта память предназначается для разного рода объектов. Но если одна и та же функция обеспечивает память, скажем) и для указателей на <emphasis>char</emphasis>, и для указателей на <emphasis>struct tnode</emphasis>, то возникают два вопроса. Первый: как справиться с требованием большинства машин, в которых объекты определенного типа должны быть выровнены (например, <emphasis>int</emphasis> часто должны размещаться, начиная с четных адресов)? И второе: как объявить функцию-распределитель памяти, которая вынуждена в качестве результата возвращать указатели разных типов?</p>
    <p>Вообще говоря, требования, касающиеся выравнивания, можно легко выполнить за счет некоторого перерасхода памяти. Однако для этого возвращаемый указатель должен быть таким, чтобы удовлетворялись любые ограничения, связанные с выравниванием. Функция <emphasis>alloc</emphasis>, описанная в главе 5, не гарантирует нам любое конкретное выравнивание, поэтому мы будем пользоваться стандартной библиотечной функцией <strong>malloc</strong>, которая это делает. В главе 8 мы покажем один из способов ее реализации.</p>
    <p>Вопрос об объявлении типа таких функций, как <strong>malloc</strong>, является камнем преткновения в любом языке с жесткой проверкой типов. В Си вопрос решается естественным образом: <strong>malloc</strong> объявляется как функция, которая возвращает указатель на <strong>void</strong>. Полученный указатель затем явно приводится к желаемому типу (Замечание о приведении типа величины, возвращаемой функцией <emphasis>malloc</emphasis>, нужно переписать. Пример коpректен и работает, но совет является спорным в контексте стандартов ANSI/ISO 1988-1989 г. На самом деле это не обязательно (при условии что приведение <emphasis>void*</emphasis> к <emphasis>ALMOSTANYTYPE*</emphasis> выполняется автоматически) и возможно даже опасно, если <emphasis>malloc</emphasis> или ее заместитель не может быть объявлен как функция, возвращающая <emphasis>void*</emphasis>. Явное приведение типа может скрыть случайную ошибку. В другие времена (до появления стандарта ANSI) приведение считалось обязательным, что также справедливо и для C++. - Примеч. авт.). Описания <emphasis>malloc</emphasis> и связанных с ней функций находятся в стандартном заголовочном файле <strong>‹stdlib.h›</strong>. Таким образом, функцию <emphasis>talloc</emphasis> можно записать так:</p>
    <p><code>#include ‹stdlib.h› </code></p>
    <empty-line/>
    <p><code>/* talloc: создает tnode */ </code></p>
    <p><code>struct tnode *talloc(void) {</code></p>
    <p><code> return (struct tnode *) malloc(sizeof(struct tnode));</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>strdup</emphasis> просто копирует строку, указанную в аргументе, в место, полученное с помощью <emphasis>malloc</emphasis>:</p>
    <p><code>char *strdup(char *s) /* делает дубликат s */ </code></p>
    <p><code>{</code></p>
    <p><code> char *p;</code></p>
    <empty-line/>
    <p><code> p = (char *) malloc(strlen(s)+1); /* +1 для '\0' */</code></p>
    <p><code> if (p != NULL)</code></p>
    <p><code>  strcpy(p, s);</code></p>
    <p><code> return p;</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>malloc</emphasis> возвращает NULL, если свободного пространства нет; <emphasis>strdup</emphasis> возвращает это же значение, оставляя заботу о выходе из ошибочной ситуации вызывающей программе.</p>
    <p>Память, полученную с помощью <emphasis>malloc</emphasis>, можно освободить для повторного использования, обратившись к функции <emphasis>free</emphasis> (см. главы 7 и 8).</p>
    <p><strong>Упражнение 6.2</strong>. Напишите программу, которая читает текст Си-программы и печатает в алфавитном порядке все группы имен переменных, в которых совпадают первые 6 символов, но последующие в чем-то различаются. Не обрабатывайте внутренности закавыченных строк и комментариев. Число 6 сделайте параметром, задаваемым в командной строке.</p>
    <p><strong>Упражнение 6.3</strong>. Напишите программу печати таблицы "перекрестных ссылок", которая будет печатать все слова документа и указывать для каждого из них номера строк, где оно встретилось. Программа должна игнорировать "шумовые" слова, такие как "и", "или" и пр.</p>
    <p><strong>Упражнение 6.4</strong>. Напишите программу, которая печатает весь набор различных слов, образующих входной поток, в порядке возрастания частоты их встречаемости. Перед каждым словом должно быть указано число вхождений.</p>
   </section>
   <section>
    <title>
     <p>6.6 Просмотр таблиц</p>
    </title>
    <p>В этом параграфе, чтобы проиллюстрировать новые аспекты применения структур, мы напишем ядро пакета программ, осуществляющих вставку элементов в таблицы и их поиск внутри таблиц. Этот пакет - типичный набор программ, с помощью которых работают с таблицами имен в любом макропроцессоре или компиляторе. Рассмотрим, например, инструкцию <strong>#define</strong>. Когда встречается строка вида</p>
    <p><code>#define IN 1</code></p>
    <p>имя IN и замещающий его текст 1 должны запоминаться в таблице. Если затем имя IN встретится в инструкции, например в</p>
    <p><code>state = IN;</code></p>
    <p>это должно быть заменено на 1.</p>
    <p>Существуют две программы, манипулирующие с именами и замещающими их текстами. Это <emphasis>install(s,t)</emphasis>, которая записывает имя <emphasis>s</emphasis> и замещающий его текст <emphasis>t</emphasis> в таблицу, где <emphasis>s</emphasis> и <emphasis>t</emphasis> - строки, и <emphasis>lookup(s)</emphasis>, осуществляющая поиск <emphasis>s</emphasis> в таблице и возвращающая указатель на место, где имя <emphasis>s</emphasis> было найдено, или NULL, если <emphasis>s</emphasis> в таблице не оказалось.</p>
    <p>Алгоритм основан на <emphasis>хэш-поиске</emphasis>: поступающее имя свертывается в неотрицательное число (хэш-код), которое затем используется в качестве индекса в массиве указателей. Каждый элемент этого массива является указателем на начало связанного списка блоков, описывающих имена с данным хэш-кодом. Если элемент массива равен NULL, это значит, что имен с соответствующим хэш-кодом нет.</p>
    <image l:href="#fig6_4.jpg"/>
    <p>Блок в списке - это структура, содержащая указатели на имя, на замещающий текст и на следующий блок в списке; значение NULL в указателе на следующий блок означает конец списка.</p>
    <p><code>struct nlist {/* элемент таблицы */</code></p>
    <p><code> struct nlist *next; /* указатель на следующий элемент */</code></p>
    <p><code> char *name; /* определенное имя */</code></p>
    <p><code> char *defn; /* замещающий текст */</code></p>
    <p><code>};</code></p>
    <p>А вот как записывается определение массива указателей:</p>
    <p><code>#define HASHSIZE 101 </code></p>
    <p><code>static struct nlist *hashtab[HASHSIZE]; /* таблица указателей */</code></p>
    <p>Функция хэширования, используемая в <emphasis>lookup</emphasis> и <emphasis>install</emphasis>, суммирует коды символов в строке и в качестве результата выдаст остаток от деления полученной суммы на размер массива указателей. Это не самая лучшая функция хэширования, но достаточно лаконичная и эффективная.</p>
    <p><code>/* hash: получает хэш-код для строки s */ </code></p>
    <p><code>unsigned hash(char *s) </code></p>
    <p><code>{</code></p>
    <p><code> unsigned hashval;</code></p>
    <p><code> for (hashval = 0; *s != '\0'; s++)</code></p>
    <p><code>  hashval = *s + 31 * hashval;</code></p>
    <p><code> return hashval % HASHSIZE;</code></p>
    <p><code>}</code></p>
    <p>Беззнаковая арифметика гарантирует, что хэш-код будет неотрицательным.</p>
    <p>Хэширование порождает стартовый индекс для массива <emphasis>hashtab</emphasis>; если соответствующая строка в таблице есть, она может быть обнаружена только в списке блоков, на начало которого указывает элемент массива <emphasis>hashtab</emphasis> с этим индексом. Поиск осуществляется с помощью <emphasis>lookup</emphasis>. Если <emphasis>lookup</emphasis> находит элемент с заданной строкой, то возвращает указатель на нее, если не находит, то возвращает NULL.</p>
    <p><code>/* lookup: ищет s */ </code></p>
    <p><code>struct nlist *lookup(char *s) </code></p>
    <p><code>{</code></p>
    <p><code> struct nlist *np;</code></p>
    <empty-line/>
    <p><code> for (np = hashtab[hash(s)]; np != NULL; np = np-›next)</code></p>
    <p><code>  if (strcmp(s, np-›name) == 0)</code></p>
    <p><code>   return np; /* нашли */</code></p>
    <p><code> return NULL; /* не нашли */</code></p>
    <p><code>}</code></p>
    <p>В <emphasis>for</emphasis>-цикле функции <emphasis>lookup</emphasis> для просмотра списка используется стандартная конструкция</p>
    <p><code>for (ptr = head; ptr != NULL; ptr = ptr-›next)…</code></p>
    <p>Функция <emphasis>install</emphasis> обращается к <emphasis>lookup</emphasis>, чтобы определить, имеется ли уже вставляемое имя. Если это так, то старое определение будет заменено новым. В противном случае будет образован новый элемент. Если запрос памяти для нового элемента не может быть удовлетворен, функция <emphasis>install</emphasis> выдает NULL.</p>
    <p><code>struct nlist *lookup(char *); </code></p>
    <p><code>char *strdup(char *); </code></p>
    <empty-line/>
    <p><code>/* install: заносит имя и текст (name, defn) в таблицу */ </code></p>
    <p><code>struct nlist *install(char *name, char *defn) </code></p>
    <p><code>{</code></p>
    <p><code> struct nlist *np;</code></p>
    <p><code> unsigned hashval;</code></p>
    <p><code> if ((np = lookup(name)) == NULL) {/* не найден */</code></p>
    <p><code>  np = (struct nlist *) malloc(sizeof(*np));</code></p>
    <p><code>  if (np == NULL || (np-›name = strdup(name)) == NULL)</code></p>
    <p><code>   return NULL;</code></p>
    <p><code>  hashval = hash(name);</code></p>
    <p><code>  np-›next = hashtab[hashval];</code></p>
    <p><code>  hashtab[hashval] = np;</code></p>
    <p><code> }</code></p>
    <p><code> else /* уже имеется */</code></p>
    <p><code>  free((void *) np-›defn); /* освобождаем прежний defn */</code></p>
    <p><code> if ((np-›defn = strdup(defn)) == NULL)</code></p>
    <p><code>  return NULL;</code></p>
    <p><code> return np;</code></p>
    <p><code>}</code></p>
    <p><strong>Упражнение 6.5</strong>. Напишите функцию <emphasis>undef</emphasis>, удаляющую имя и определение из таблицы, организация которой поддерживается функциями <emphasis>lookup</emphasis> и <emphasis>install</emphasis>.</p>
    <p><strong>Упражнение 6.6</strong>. Реализуйте простую версию <emphasis>#define</emphasis>-npoцeccopa (без аргументов), которая использовала бы программы этого параграфа и годилась бы для Си-программ. Вам могут помочь программы <emphasis>getch</emphasis> и <emphasis>ungetch</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>6.7 Средство typedef</p>
    </title>
    <p>Язык Си предоставляет средство, называемое <strong>typedef</strong>, которое позволяет давать типам данных новые имена. Например, объявление</p>
    <p><code>typedef int Length;</code></p>
    <p>делает имя <emphasis>Length</emphasis> синонимом <emphasis>int</emphasis>. С этого момента тип <emphasis>Length</emphasis> можно применять в объявлениях, в операторе приведения и т. д. точно так же, как тип <emphasis>int</emphasis>:</p>
    <p><code>Length len, maxlen; </code></p>
    <p><code>Length *lengths[];</code></p>
    <p>Аналогично объявление</p>
    <p><code>typedef char *String;</code></p>
    <p>делает <emphasis>String</emphasis> синонимом <emphasis>char *</emphasis>, т. e. указателем на <emphasis>char</emphasis>, и правомерным будет, например, следующее его использование:</p>
    <p><code>String р, lineptr[MAXLINES], alloc(int); </code></p>
    <p><code>int strcmp(String, String); </code></p>
    <p><code>p = (String) malloc(100);</code></p>
    <p>Заметим, что объявляемый в <strong>typedef</strong> тип стоит на месте имени переменной в обычном объявлении, а не сразу за словом <strong>typedef</strong>. С точки зрения синтаксиса слово <emphasis>typedef</emphasis> напоминает класс памяти - <emphasis>extern</emphasis>, <emphasis>static</emphasis> и т. д. Имена типов записаны с заглавных букв для того, чтобы они выделялись.</p>
    <p>Для демонстрации более сложных примеров применения <emphasis>typedef</emphasis> воспользуемся этим средством при задании узлов деревьев, с которыми мы уже встречались в данной главе.</p>
    <p><code>typedef struct tnode *Treeptr; </code></p>
    <p><code>typedef struct tnode {/* узел дерева: */</code></p>
    <p><code> char *word; /* указатель на текст */</code></p>
    <p><code> int count; /* число вхождений */</code></p>
    <p><code> Treeptr left; /* левый сын */</code></p>
    <p><code> Treeptr right; /* правый сын */</code></p>
    <p><code>} Treenode;</code></p>
    <p>В результате создаются два новых названия типов: <emphasis>Treenode</emphasis> (структура) и <emphasis>Treeptr</emphasis> (указатель на структуру). Теперь программу <emphasis>talloc</emphasis> можно записать в следующем виде:</p>
    <p><code>Treeptr talloc(void) {</code></p>
    <p><code> return (Treeptr) malloc(sizeof(Treenode));</code></p>
    <p><code>}</code></p>
    <p>Следует подчеркнуть, что объявление <emphasis>typedef</emphasis> не создает объявления нового типа, оно лишь сообщает новое имя уже существующему типу. Никакого нового смысла эти новые имена не несут, они объявляют переменные в точности с теми же свойствами, как если бы те были объявлены напрямую без переименования типа. Фактически <emphasis>typedef</emphasis> аналогичен <emphasis>#define</emphasis> с тем лишь отличием, что при интерпретации компилятором он может справиться с такой текстовой подстановкой, которая не может быть обработана препроцессором. Например</p>
    <p><code>typedef int (*PFI)(char *, char *);</code></p>
    <p>создает тип <emphasis>PFI</emphasis> - "указатель на функцию (двух аргументов типа <emphasis>char *</emphasis>), возвращающую <emphasis>int</emphasis>", который, например, в программе сортировки, описанной в главе 5, можно использовать в таком контексте:</p>
    <p><code>PFI strcmp, numcmp;</code></p>
    <p>Помимо просто эстетических соображений, для применения <emphasis>typedef</emphasis> существуют две важные причины. Первая - параметризация программы, связанная с проблемой переносимости. Если с помощью <emphasis>typedef</emphasis> объявить типы данных, которые, возможно, являются машинно-зависимыми, то при переносе программы на другую машину потребуется внести изменения только в определения <emphasis>typedef</emphasis>. Одна из распространенных ситуаций - использование <emphasis>typedef</emphasis>-имен для варьирования целыми величинами. Для каждой конкретной машины это предполагает соответствующие установки <emphasis>short</emphasis>, <emphasis>int</emphasis> или <emphasis>long</emphasis>, которые делаются аналогично установкам стандартных типов, например <emphasis>size_t</emphasis> и <emphasis>ptrdiff_t</emphasis>.</p>
    <p>Вторая причина, побуждающая к применению <emphasis>typedef</emphasis>,- желание сделать более ясным текст программы. Тип, названный <emphasis>Тreeptr</emphasis> (от английских слов tree - дерево и pointer - указатель), более понятен, чем тот же тип, записанный как указатель на некоторую сложную структуру.</p>
   </section>
   <section>
    <title>
     <p>6.8 Объединения</p>
    </title>
    <p><emphasis>Объединение</emphasis> - это переменная, которая может содержать (в разные моменты времени) объекты различных типов и размеров. Все требования относительно размеров и выравнивания выполняет компилятор. Объединения позволяют хранить разнородные данные в одной и той же области памяти без включения в программу машинно-зависимой информации. Эти средства аналогичны вариантным записям в Паскале.</p>
    <p>Примером использования объединений мог бы послужить сам компилятор, заведующий таблицей символов, если предположить, что константа может иметь тип <emphasis>int</emphasis>, <emphasis>float</emphasis> или являться указателем на символ и иметь тип <emphasis>char *</emphasis>. Значение каждой конкретной константы должно храниться в переменной соответствующего этой константе типа. Работать с таблицей символов всегда удобнее, если значения занимают одинаковую по объёму память и запоминаются в одном и том же месте независимо от своего типа. Цель введения в программу объединения - иметь переменную, которая бы на законных основаниях хранила в себе значения нескольких типов. Синтаксис объединений аналогичен синтаксису структур. Приведем пример объединения.</p>
    <p><code>union u_tag {</code></p>
    <p><code> int ival;</code></p>
    <p><code> float fval;</code></p>
    <p><code> char *sval;</code></p>
    <p><code>} u;</code></p>
    <p>Переменная <emphasis>u</emphasis> будет достаточно большой, чтобы в ней поместилась любая переменная из указанных трех типов: точный ее размер зависит от реализации. Значение одного из этих трех типов может быть присвоено переменной <emphasis>u</emphasis> и далее использовано в выражениях, если это правомерно, т. е. если тип взятого ею значения совпадает с типом последнего присвоенного ей значения. Выполнение этого требования в каждый текущий момент - целиком на совести программиста. В том случае, если нечто запомнено как значение одного типа, а извлекается как значение другого типа, результат зависит от реализации. Синтаксис доступа к элементам объединения следующий:</p>
    <p><code><emphasis>имя-объединения</emphasis>.<emphasis>элемент</emphasis></code></p>
    <p>или</p>
    <p><emphasis><code><emphasis>указатель-на-объединение</emphasis>-›<emphasis>элемент</emphasis></code></emphasis></p>
    <p>т. е. в точности такой, как в структурах. Если для хранения типа текущего значения <emphasis>u</emphasis> использовать, скажем, переменную <emphasis>utype</emphasis>, то можно написать такой фрагмент программы:</p>
    <p><code>if (utype == INT)</code></p>
    <p><code> printf("%d\n", u.ival); </code></p>
    <p><code>else if (utype == FLOAT)</code></p>
    <p><code> printf("%f\n", u.fval); </code></p>
    <p><code>else if (utype == STRING)</code></p>
    <p><code> printf("%s\n", u.sval); </code></p>
    <p><code>else </code></p>
    <p><code> printf ("неверный тип %d в utype\n", utype);</code></p>
    <p>Объединения могут входить в структуры и массивы, и наоборот. Запись доступа к элементу объединения, находящегося в структуре (как и структуры, находящейся в объединении), такая же, как и для вложенных структур. Например, в массиве структур</p>
    <p><code>struct {</code></p>
    <p><code> char *name;</code></p>
    <p><code> int flags;</code></p>
    <p><code> int utype;</code></p>
    <p><code> union {</code></p>
    <p><code>  int ival;</code></p>
    <p><code>  float fval;</code></p>
    <p><code>  char *sval;</code></p>
    <p><code> } u;</code></p>
    <p><code>} symtab[NSYM];</code></p>
    <p>к <emphasis>ival</emphasis> обращаются следующим образом:</p>
    <p><code>symtab[i].u.ival</code></p>
    <p>а к первому символу строки <emphasis>sval</emphasis> можно обратиться любым из следующих двух способов:</p>
    <p><code>*symtab[i].u.sval </code></p>
    <p><code>symtab[i].u.sval[0]</code></p>
    <p>Фактически объединение - это структура, все элементы которой имеют нулевое смещение относительно ее базового адреса и размер которой позволяет поместиться в ней самому большому ее элементу, а выравнивание этой структуры удовлетворяет всем типам объединения. Операции, применимые к структурам, годятся и для объединений, т. е. законны присваивание объединения и копирование его как единого целого, взятие адреса от объединения и доступ к отдельным его элементам.</p>
    <p>Инициализировать объединение можно только значением, имеющим тип его первого элемента; таким образом, упомянутую выше переменную <emphasis>u</emphasis> можно инициализировать лишь значением типа <emphasis>int</emphasis>.</p>
    <p>В главе 8 (на примере программы, заведующей выделением памяти) мы покажем, как, применяя объединение, можно добиться, чтобы расположение переменной было выровнено по соответствующей границе в памяти.</p>
   </section>
   <section>
    <title>
     <p>6.9 Битовые поля</p>
    </title>
    <p>При дефиците памяти может возникнуть необходимость запаковать несколько объектов в одно слово машины. Одна из обычных ситуаций, встречающаяся в задачах обработки таблиц символов для компиляторов, - это объединение групп однобитовых флажков. Форматы некоторых данных могут от нас вообще не зависеть и диктоваться, например, интерфейсами с аппаратурой внешних устройств: здесь также возникает потребность адресоваться к частям слова.</p>
    <p>Вообразим себе фрагмент компилятора, который заведует таблицей символов. Каждый идентификатор программы имеет некоторую связанную с ним информацию: например, представляет ли он собой ключевое слово и, если это переменная, к какому классу принадлежит: внешняя и/или статическая и т. д. Самый компактный способ кодирования такой информации - расположить однобитовые флажки в одном слове типа <emphasis>char</emphasis> или <emphasis>int</emphasis>.</p>
    <p>Один из распространенных приемов работы с битами основан на определении набора "масок", соответствующих позициям этих битов, как, например, в</p>
    <p><code>#define KEYWORD 01 /* ключевое слово */ </code></p>
    <p><code>#define EXTERNAL 02 /* внешний */ </code></p>
    <p><code>#define STATIC 04 /* статический */</code></p>
    <p>или в</p>
    <p><code>enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };</code></p>
    <p>Числа должны быть степенями двойки. Тогда доступ к битам становится делом "побитовых операций", описанных в главе 2 (сдвиг, маскирование, взятие дополнения). Некоторые виды записи выражений встречаются довольно часто. Так,</p>
    <p><code>flags |= EXTERNAL | STATIC;</code></p>
    <p>устанавливает 1 в соответствующих битах переменной <emphasis>flags</emphasis>,</p>
    <p><code>flags &amp;= ~(EXTERNAL | STATIC);</code></p>
    <p>обнуляет их, a</p>
    <p><code>if ((flags &amp; (EXTERNAL | STATIC)) == 0)…</code></p>
    <p>оценивает условие как истинное, если оба бита нулевые.</p>
    <p>Хотя научиться писать такого рода выражения не составляет труда, вместо побитовых логических операций можно пользоваться предоставляемым Си другим способом прямого определения и доступа к полям внутри слова. Битовое поле (или для краткости просто поле) - это некоторое множество битов, лежащих рядом внутри одной, зависящей от реализации единицы памяти, которую мы будем называть "словом". Синтаксис определения полей и доступа к ним базируется на синтаксисе структур. Например, строки <emphasis>#define</emphasis>, фигурировавшие выше при задании таблицы символов, можно заменить на определение трех полей:</p>
    <p><code>struct {</code></p>
    <p><code> unsigned int is_keyword: 1;</code></p>
    <p><code> unsigned int is_extern: 1;</code></p>
    <p><code> unsigned int is_static: 1;</code></p>
    <p><code>} flags;</code></p>
    <p>Эта запись определяет переменную <emphasis>flags</emphasis>, которая содержит три однобитовых поля. Число, следующее за двоеточием, задает ширину поля. Поля объявлены как <emphasis>unsigned int</emphasis>, чтобы они воспринимались как беззнаковые величины.</p>
    <p>На отдельные поля ссылаются так же, как и на элементы обычных структур: <emphasis>flags.is_keyword</emphasis>, <emphasis>flags.is_extern</emphasis> и т.д. Поля "ведут себя" как малые целые и могут участвовать в арифметических выражениях точно так же, как и другие целые. Таким образом, предыдущие примеры можно написать более естественно:</p>
    <p><code>flags.is_extern = flags.is_static = 1;</code></p>
    <p>устанавливает 1 в соответствующие биты;</p>
    <p><code>flags.is_extern = flags.is_static = 0;</code></p>
    <p>их обнуляет, а</p>
    <p><code>if (flags.is_extern == 0 &amp;&amp; flags.is_ststic == 0)…</code></p>
    <p>проверяет их.</p>
    <p>Почти все технические детали, касающиеся полей, в частности, возможность поля перейти границу слова, зависят от реализации. Поля могут не иметь имени; с помощью безымянного поля (задаваемого только двоеточием и шириной) организуется пропуск нужного количества разрядов. Особая ширина, равная нулю, используется, когда требуется выйти на границу следующего слова.</p>
    <p>На одних машинах поля размещаются слева направо, на других - справа налево. Это значит, что при всей полезности работы с ними, если формат данных, с которыми мы имеем дело, дан нам свыше, то необходимо самым тщательным образом исследовать порядок расположения полей; программы, зависящие от такого рода вещей, не переносимы. Поля можно определять только с типом <emphasis>int</emphasis>, а для того чтобы обеспечить переносимость, надо явно указывать <emphasis>signed</emphasis> или <emphasis>unsigned</emphasis>. Они не могут быть массивами и не имеют адресов, и, следовательно, оператор <strong>&amp;</strong> к ним не применим.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Глава 7. Ввод и вывод</p>
   </title>
   <section>
    <p>Возможности для ввода и вывода не являются частью самого языка Си, поэтому мы подробно и не рассматривали их до сих пор. Между тем реальные программы взаимодействуют со своим окружением гораздо более сложным способом, чем те, которые были затронуты ранее. В этой главе мы опишем стандартную библиотеку, содержащую набор функций, обеспечивающих ввод-вывод, работу со строками, управление памятью, стандартные математические функции и разного рода сервисные Си-программы. Но особое внимание уделим вводу-выводу.</p>
    <p>Библиотечные функции ввода-вывода точно определяются стандартом ANSI, так что они совместимы на любых системах, где поддерживается Си. Программы, которые в своем взаимодействии с системным окружением не выходят за рамки возможностей стандартной библиотеки, можно без изменений переносить с одной машины на другую.</p>
    <p>Свойства библиотечных функций специфицированы в более чем дюжине заголовочных файлов; вам уже встречались некоторые из них, в том числе <strong>‹stdio.h›</strong>, <strong>‹string.h›</strong> и <strong>‹ctype.h›</strong>. Мы не рассматриваем здесь всю библиотеку, так как нас больше интересует написание Си-программ, чем использование библиотечных функций. Стандартная библиотека подробно описана в приложении B.</p>
   </section>
   <section>
    <title>
     <p>7.1 Стандартный ввод-вывод</p>
    </title>
    <p>Как уже говорилось в главе 1, библиотечные функции реализуют простую модель текстового ввода-вывода. Текстовый поток состоит из последовательности строк; каждая строка заканчивается символом новой строки. Если система в чем-то не следует принятой модели, библиотека сделает так, чтобы казалось, что эта модель удовлетворяется полностью. Например, пара символов - <emphasis>возврат-каретки</emphasis> и <emphasis>перевод-строки</emphasis> - при вводе могла бы быть преобразована в один символ новой строки, а при выводе выполнялось бы обратное преобразование.</p>
    <p>Простейший механизм ввода - это чтение одного символа из <emphasis>стандартного ввода</emphasis> (обычно с клавиатуры) функцией <emphasis>getchar</emphasis>:</p>
    <p><code>int getchar(void)</code></p>
    <p>В качестве результата каждого своего вызова функция <emphasis>getchar</emphasis> возвращает следующий символ ввода или, если обнаружен конец файла, <strong>EOF</strong>. Именованная константа EOF (аббревиатура от <emphasis>end of file</emphasis> - конец файла) определена в <strong>‹stdio.h›</strong>. Обычно значение <strong>EOF</strong> равно -1, но, чтобы не зависеть от конкретного значения этой константы, обращаться к ней следует по имени (EOF).</p>
    <p>Во многих системах клавиатуру можно заменить файлом, перенаправив ввод с помощью значка <strong>‹</strong>. Так, если программа <emphasis>prog</emphasis> использует <emphasis>getchar</emphasis>, то командная строка</p>
    <p><code>prog ‹ infile</code></p>
    <p>предпишет программе <emphasis>prog</emphasis> читать символы из <emphasis>infile</emphasis>, а не с клавиатуры. Переключение ввода делается так, что сама программа <emphasis>prog</emphasis> не замечает подмены; в частности строка <emphasis>"‹ infile"</emphasis> не будет включена в аргументы командной строки <emphasis>argv</emphasis>. Переключение ввода будет также незаметным, если ввод исходит от другой программы и передается конвейерным образом. В некоторых системах командная строка</p>
    <p><code>otherprog | prog</code></p>
    <p>приведет к тому, что запустится две программы, <emphasis>otherprog</emphasis> и <emphasis>prog</emphasis>, и стандартный выход <emphasis>otherprog</emphasis> поступит на стандартный вход <emphasis>prog</emphasis>. Функция</p>
    <p><code>int putchar(int)</code></p>
    <p>используется для вывода: <emphasis>putchar(c)</emphasis> отправляет символ <emphasis>c</emphasis> в <emphasis>стандартный вывод</emphasis>, под которым по умолчанию подразумевается экран. Функция <emphasis>putchar</emphasis> в качестве результата возвращает посланный символ или, в случае ошибки, <emphasis>EOF</emphasis>. То же и в отношении вывода: с помощью записи вида <emphasis>› имя-файла</emphasis> вывод можно перенаправить в файл. Например, если <emphasis>prog</emphasis> использует для вывода функцию <emphasis>putchar</emphasis>, то</p>
    <p><code>prog › outfile</code></p>
    <p>будет направлять стандартный вывод не на экран, а в <emphasis>outfile</emphasis>. А командная строка</p>
    <p><code>prog | anotherprog</code></p>
    <p>соединит стандартный вывод программы <emphasis>prog</emphasis> со стандартным вводом программы <emphasis>anotherprog</emphasis>.</p>
    <p>Вывод, осуществляемый функцией <emphasis>printf</emphasis>, также отправляется в стандартный выходной поток. Вызовы <emphasis>putchar</emphasis> и <emphasis>printf</emphasis> могут как угодно чередоваться, при этом вывод будет формироваться в той последовательности, в которой происходили вызовы этих функций.</p>
    <p>Любой исходный Си-файл, использующий хотя бы одну функцию библиотеки ввода-вывода, должен содержать в себе строку</p>
    <p><code>#include ‹stdio.h›</code></p>
    <p>причем она должна быть расположена до первого обращения к вводу-выводу. Если имя заголовочного файла заключено в угловые скобки ‹ и ›, это значит, что поиск заголовочного файла ведется в стандартном месте (например в системе UNIX это обычно директорий <emphasis>/usr/include</emphasis>).</p>
    <p>Многие программы читают только из одного входного потока и пишут только в один выходной поток. Для организации ввода-вывода таким программам вполне хватит функций <emphasis>getchar</emphasis>, <emphasis>putchar</emphasis> и <emphasis>printf</emphasis>, а для начального обучения уж точно достаточно ознакомления с этими функциями. В частности, перечисленных функций достаточно, когда требуется вывод одной программы соединить с вводом следующей. В качестве примера рассмотрим программу <emphasis>lower</emphasis>, переводящую свой ввод на нижний регистр:</p>
    <p><code>#include ‹stdio.h› </code></p>
    <p><code>#include ‹ctype.h› </code></p>
    <empty-line/>
    <p><code>main() /* lower: переводит ввод на нижний регистр */ </code></p>
    <p><code>{</code></p>
    <p><code> int с; </code></p>
    <p><code> while ((с = getchar()) != EOF)</code></p>
    <p><code>  putchar(tolower(c));</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>tolower</emphasis> определена в <strong>‹ctype.h›</strong>. Она переводит буквы верхнего регистра в буквы нижнего регистра, а остальные символы возвращает без изменений. Как мы уже упоминали, "функции" вроде <emphasis>getchar</emphasis> и <emphasis>putchar</emphasis> из библиотеки <strong>‹stdio.h›</strong> и функция <emphasis>tolower</emphasis> из библиотеки <strong>‹ctype.h›</strong> часто реализуются в виде макросов, чтобы исключить накладные расходы от вызова функции на каждый отдельный символ. В параграфе 8.5 мы покажем, как это делается. Независимо от того, как на той или иной машине реализованы функции библиотеки <strong>‹ctype.h›</strong>, использующие их программы могут ничего не знать о кодировке символов.</p>
    <p><strong>Упражнение 7.1</strong>. Напишите программу, осуществляющую перевод ввода с верхнего регистра на нижний или с нижнего на верхний в зависимости от имени, по которому она вызывается и текст которого находится в <emphasis>arg[0]</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>7.2 Форматный вывод (printf)</p>
    </title>
    <p>Функция <strong>printf</strong> переводит внутренние значения в текст.</p>
    <p><code>int printf(char *format, arg<sub>1</sub>, arg<sub>2</sub>, …)</code></p>
    <p>В предыдущих главах мы использовали <emphasis>printf</emphasis> неформально. Здесь мы покажем наиболее типичные случаи применения этой функции: полное ее описание дано в приложении B.</p>
    <p>Функция <emphasis>printf</emphasis> преобразует, форматирует и печатает свои аргументы в стандартном выводе под управлением формата. Возвращает она количество напечатанных символов.</p>
    <p>Форматная строка содержит два вида объектов: обычные символы, которые напрямую копируются в выходной поток, и спецификации преобразования, каждая из которых вызывает преобразование и печать очередного аргумента <emphasis>printf</emphasis>. Любая спецификация преобразования начинается знаком <strong>%</strong> и заканчивается <emphasis>символом-спецификатором</emphasis>. Между <emphasis>%</emphasis> и символом-спецификатором могут быть расположены (в указанном ниже порядке) следующие элементы:</p>
    <p>• Знак минус, предписывающий выравнивать преобразованный аргумент по левому краю поля.</p>
    <p>• Число, специфицирующее минимальную ширину поля. Преобразованный аргумент будет занимать поле по крайней мере указанной ширины. При необходимости лишние позиции слева (или справа при левостороннем расположении) будут заполнены пробелами.</p>
    <p>• Точка, отделяющая ширину поля от величины, устанавливающей точность.</p>
    <p>• Число (точность), специфицирующее максимальное количество печатаемых символов в строке, или количество цифр после десятичной точки - для чисел с плавающей запятой, или минимальное количество цифр - для целого.</p>
    <p>• Буква h, если печатаемое целое должно рассматриваться как short, или l (латинская буква ell), если целое должно рассматриваться как long.</p>
    <p>Символы-спецификаторы перечислены в таблице 7.1. Если за <strong>%</strong> не помещен символ- спецификатор, поведение функции <emphasis>printf</emphasis> будет не определено. Ширину и точность можно специфицировать с помощью <strong>*</strong>; значение ширины (или точности) в этом случае берется из следующего аргумента (который должен быть типа <emphasis>int</emphasis>). Например, чтобы напечатать не более <emphasis>max</emphasis> символов из строки <emphasis>s</emphasis>, годится следующая запись:</p>
    <p>printf("%.*s", max, s);</p>
    <p><strong>Таблица 7.1 Основные преобразования printf</strong></p>
    <table>
     <tr align="left">
      <th align="left" valign="top">Символ </th>
      <th align="left" valign="top">Тип аргумента; вид печати </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>d</strong>, <strong>i </strong></td>
      <td align="left" valign="top"><strong>int</strong>; десятичное целое </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>o </strong></td>
      <td align="left" valign="top"><strong>unsigned int</strong>; беззнаковое восьмеричное (<emphasis>octal</emphasis>) целое (без нуля слева)</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>x</strong>, </td>
      <td align="left" valign="top"><strong>X unsigned int</strong>; беззнаковое шестнадцатеричное целое (без 0x или 0X слева), для 10…15 используются abcdef или ABCDEF</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>u </strong></td>
      <td align="left" valign="top"><strong>unsigned int</strong>; беззнаковое десятичное целое </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>c </strong></td>
      <td align="left" valign="top"><strong>int</strong>; одиночный символ </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>s </strong></td>
      <td align="left" valign="top"><strong>char *</strong>; печатает символы, расположенные до знака \0, или в количестве, заданном точностью</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>f </strong></td>
      <td align="left" valign="top"><strong>double</strong>; <strong>[-]m.dddddd</strong>, где количество цифр <strong>d</strong> задается точностью (по умолчанию равно 6) </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>e</strong>, <strong>E </strong></td>
      <td align="left" valign="top"><strong>double</strong>; <strong>[-]m.dddddde+xx</strong> или <strong>[-]m.ddddddE+xx</strong>, где количество цифр <strong>d</strong> задается точностью (по умолчанию равно 6) </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>g</strong>, <strong>G </strong></td>
      <td align="left" valign="top"><strong>double</strong>; использует <strong>%e</strong> или <strong>%E</strong>, если порядок меньше, чем -4, или больше или равен точности; в противном случае использует <strong>%f</strong>. Завершающие нули и завершающая десятичная точка не печатаются </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>p </strong></td>
      <td align="left" valign="top"><strong>void *</strong>; указатель (представление зависит от реализации) </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>%</strong> </td>
      <td align="left" valign="top">Аргумент не преобразуется; печатается знак <strong>%</strong> </td>
     </tr>
    </table>
    <p>Большая часть форматных преобразований была продемонстрирована в предыдущих главах. Исключение составляет задание точности для строк. Далее приводится перечень спецификаций и показывается их влияние на печать строки "hello, world", состоящей из 12 символов. Поле специально обрамлено двоеточиями, чтобы была видна его протяженность.</p>
    <p><code>:%s:        :hello, world:</code></p>
    <p><code>:%10s       :hello, world:</code></p>
    <p><code>:%.10s:     :hello, wor:</code></p>
    <p><code>:%-10s:     :hello, world:</code></p>
    <p><code>:%.15s:     :hello, world:</code></p>
    <p><code>:%-15s:     :hello, world     :</code></p>
    <p><code>:%15.10s:   :       hello, wor:</code></p>
    <p><code>:%-15.10s:  :hello, wor       :</code></p>
    <p>Предостережение: функция <emphasis>printf</emphasis> использует свой первый аргумент, чтобы определить, сколько еще ожидается аргументов и какого они будут типа. Вы не получите правильного результата, если аргументов будет не хватать или они будут принадлежать не тому типу. Вы должны также понимать разницу в следующих двух обращениях:</p>
    <p><code>printf(s); /* НЕВЕРНО, если в s есть % */ </code></p>
    <p><code>printf("%s", s); /* ВЕРНО всегда */</code></p>
    <p>Функция <strong>sprintf</strong> выполняет те же преобразования, что и <emphasis>printf</emphasis>, но вывод запоминает в строке</p>
    <p><code>int sprintf(char *string, char *format, arg<sub>1</sub>, arg<sub>2</sub>,…)</code></p>
    <p>Эта функция форматирует <emphasis>arg<sub>1</sub></emphasis>, <emphasis>arg<sub>2</sub></emphasis> и т. д. в соответствии с информацией, заданной аргументом <emphasis>format</emphasis>, как мы описывали ранее, но результат помещает не в стандартный вывод, а в <emphasis>string</emphasis>. Заметим, что строка <emphasis>string</emphasis> должна быть достаточно большой, чтобы в ней поместился результат.</p>
    <p><strong>Упражнение 7.2</strong>. Напишите программу, которая будет печатать разумным способом любой ввод. Как минимум она должна уметь печатать неграфические символы в восьмеричном или шестнадцатеричном виде (в форме, принятой на вашей машине), обрывая длинные текстовые строки.</p>
   </section>
   <section>
    <title>
     <p>7.3 Списки аргументов переменной длины</p>
    </title>
    <p>Этот параграф содержит реализацию минимальной версии <emphasis>printf</emphasis>. Приводится она для того, чтобы показать, как надо писать функции со списками аргументов переменной длины, причем такие, которые были бы переносимы. Поскольку нас главным образом интересует обработка аргументов, функцию <emphasis>minprintf</emphasis> напишем таким образом, что она в основном будет работать с задающей формат строкой и аргументами; что же касается форматных преобразований, то они будут осуществляться с помощью стандартного <emphasis>printf</emphasis>.</p>
    <p>Объявление стандартной функции <emphasis>printf</emphasis> выглядит так:</p>
    <p><code>int printf(char *fmt, …)</code></p>
    <p>Многоточие в объявлении означает, что число и типы аргументов могут изменяться. Знак многоточие может стоять только в конце списка аргументов. Наша функция <emphasis>minprintf</emphasis> объявляется как</p>
    <p><code>void minprintf(char *fmt, …)</code></p>
    <p>поскольку она не будет выдавать число символов, как это делает <emphasis>printf</emphasis>.</p>
    <p>Вся сложность в том, каким образом <emphasis>minprintf</emphasis> будет продвигаться вдоль списка аргументов, - ведь у этого списка нет даже имени. Стандартный заголовочный файл <strong>‹stdarg.h›</strong> содержит набор макроопределений, которые устанавливают, как шагать по списку аргументов. Наполнение этого заголовочного файла может изменяться от машины к машине, но представленный им интерфейс везде одинаков.</p>
    <p>Тип <strong>va_list</strong> служит для описания переменной, которая будет по очереди указывать на каждый из аргументов; в <emphasis>minprintf</emphasis> эта переменная имеет имя <emphasis>ap</emphasis> (от "<emphasis>argument pointer</emphasis>" - указатель на аргумент). Макрос <strong>va_start</strong> инициализирует переменную <emphasis>ap</emphasis>) чтобы она указывала на первый безымянный аргумент. К <strong>va_start</strong> нужно обратиться до первого использования <emphasis>ap</emphasis>. Среди аргументов по крайней мере один должен быть именованным: от последнего именованного аргумента этот макрос "отталкивается" при начальной установке.</p>
    <p>Макрос <strong>va_arg</strong> на каждом своем вызове выдает очередной аргумент, а <emphasis>ap</emphasis> передвигает на следующий: но имени типа он определяет тип возвращаемого значения и размер шага для выхода на следующий аргумент. Наконец, макрос <strong>va_end</strong> делает очистку всего, что необходимо. К <strong>va_end</strong> следует обратиться перед самым выходом из функции.</p>
    <p>Перечисленные средства образуют основу нашей упрощенной версии <emphasis>prinf</emphasis>.</p>
    <p><code>#include ‹stdarg.h› </code></p>
    <empty-line/>
    <p><code>/* minprintf: минимальный printf с переменным числом аргументов */ </code></p>
    <p><code>void minprintf(char *fmt, …) </code></p>
    <p><code>{</code></p>
    <p><code> va_list ap; /* указывает на очередной безымянный аргумент */</code></p>
    <p><code> char *p, *sval;</code></p>
    <p><code> int ival;</code></p>
    <p><code> double dval;</code></p>
    <empty-line/>
    <p><code> va_start(ap, fmt); /* устанавливает ap на 1-й безымянный аргумент */</code></p>
    <p><code> for (p=fmt; *p; p++) {</code></p>
    <p><code>  if (*p !='%') {</code></p>
    <p><code>   putchar(*p);</code></p>
    <p><code>   continue;</code></p>
    <p><code>  }</code></p>
    <p><code>  switch (*++p) {</code></p>
    <p><code>  case 'd':</code></p>
    <p><code>   ival = va_arg(ap, int);</code></p>
    <p><code>   printf ("%d", ival);</code></p>
    <p><code>   break;</code></p>
    <p><code>  case 'f':</code></p>
    <p><code>   dval = va_arg(ap, double);</code></p>
    <p><code>   printf("%f", dval);</code></p>
    <p><code>   break;</code></p>
    <p><code>  case 's':</code></p>
    <p><code>    for (sval = va_arg(ap, char *); *sval; sval++)</code></p>
    <p><code>     putchar(*sval);</code></p>
    <p><code>    break;</code></p>
    <p><code>  default:</code></p>
    <p><code>   putchar(*p);</code></p>
    <p><code>   break;</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> va_end(ap); /* очистка, когда все сделано */</code></p>
    <p><code>}</code></p>
    <p><strong>Упражнение 7.3</strong>. Дополните <emphasis>minprintf</emphasis> другими возможностями <emphasis>printf</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>7.4 Форматный ввод (scanf)</p>
    </title>
    <p>Функция <strong>scanf</strong>, обеспечивающая ввод, является аналогом <emphasis>printf</emphasis>; она выполняет многие из упоминавшихся преобразований, но в противоположном направлении. Ее объявление имеет следующий вид:</p>
    <p><code>int scanf(char *format, …)</code></p>
    <p>Функция <emphasis>scanf</emphasis> читает символы из стандартного входного потока, интерпретирует их согласно спецификациям строки <emphasis>format</emphasis> и рассылает результаты в свои остальные аргументы. Аргумент <emphasis>format</emphasis> мы опишем позже; другие аргументы, каждый из которых должен быть указателем, определяют, где будут запоминаться должным образом преобразованные данные. Как и для <emphasis>printf</emphasis>, в этом параграфе дается сводка наиболее полезных, но отнюдь не всех возможностей данной функции.</p>
    <p>Функция <emphasis>scanf</emphasis> прекращает работу, когда оказывается, что исчерпался формат или вводимая величина не соответствует управляющей спецификации. В качестве результата <emphasis>scanf</emphasis> возвращает количество успешно введенных элементов данных. По исчерпании файла она выдает <emphasis>EOF</emphasis>. Существенно то, что значение EOF не равно нулю, поскольку нуль <emphasis>scanf</emphasis> выдает, когда вводимый символ не соответствует первой спецификации форматной строки. Каждое очередное обращение к <emphasis>scanf</emphasis> продолжает ввод символа, следующего сразу за последним обработанным.</p>
    <p>Существует также функция <emphasis>sscanf</emphasis>, которая читает из строки (а не из стандартного ввода).</p>
    <p><code>int sscanf(char *string, char *format, arg<sub>1</sub>, arg<sub>2</sub>,…)</code></p>
    <p>Функция <emphasis>sscanf</emphasis> просматривает строку <emphasis>string</emphasis> согласно формату <emphasis>format</emphasis> и рассылает полученные значения в <emphasis>arg<sub>1</sub></emphasis>, <emphasis>arg<sub>2</sub></emphasis> и т. д. Последние должны быть указателями.</p>
    <p>Формат обычно содержит спецификации, которые используются для управления преобразованиями ввода. В него могут входить следующие элементы:</p>
    <p>• Пробелы или табуляции, которые игнорируются.</p>
    <p>• Обычные символы (исключая %), которые, как ожидается, совпадут с очередными символами, отличными от символов-разделителей входного потока.</p>
    <p>• Спецификации преобразования, каждая из которых начинается со знака % и завершается символом-спецификатором типа преобразования. В промежутке между этими двумя символами в любой спецификации могут располагаться, причем в том порядке, как они здесь указаны: знак * (признак подавления присваивания); число, определяющее ширину поля; буква h, l или L, указывающая на размер получаемого значения; и символ преобразования (o, d, x).</p>
    <p>Спецификация преобразования управляет преобразованием следующего вводимого поля. Обычно результат помещается в переменную, на которую указывает соответствующий аргумент. Однако если в спецификации преобразования присутствует <emphasis>*</emphasis>, то поле ввода пропускается и никакое присваивание не выполняется. Поле ввода определяется как строка без символов-разделителей; оно простирается до следующего символа-разделителя или же ограничено шириной поля, если она задана. Поскольку символ новой строки относится к символам-разделителям, то <emphasis>sscanf</emphasis> при чтении будет переходить с одной строки на другую. (<strong>Символами-разделителями являются символы пробела, табуляции, новой строки, возврата каретки, вертикальной табуляции и перевода страницы.</strong>)</p>
    <p>Символ-спецификатор указывает, каким образом следует интерпретировать очередное поле ввода. Соответствующий аргумент должен быть указателем, как того требует механизм передачи параметров по значению, принятый в Си. Символы-спецификаторы приведены в таблице 7.2.</p>
    <p>Перед символами-спецификаторами <strong>d</strong>, <strong>l</strong>, <strong>o</strong>, <strong>u</strong> и <strong>x</strong> может стоять буква <strong>h</strong>, указывающая на то, что соответствующий аргумент должен иметь тип <emphasis>short *</emphasis> (а не <emphasis>int *</emphasis>),или <strong>l</strong> (латинская ell), указывающая на тип <emphasis>long *</emphasis>. Аналогично, перед символами-спецификаторами <strong>e</strong>, <strong>f</strong> и <strong>g</strong> может стоять буква <strong>l</strong>, указывающая, что тип аргумента - <emphasis>double *</emphasis> (а не <emphasis>float *</emphasis>).</p>
    <p><strong>Таблица 7.2 Основные преобразования scanf</strong></p>
    <table>
     <tr align="left">
      <th align="left" valign="top">Символ </th>
      <th align="left" valign="top">Вводимые данные; тип аргумента </th>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>d</strong> </td>
      <td align="left" valign="top">десятичное целое: <strong>int *</strong> </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>i</strong> </td>
      <td align="left" valign="top">целое: <strong>int *</strong>. Целое может быть восьмеричным (с 0 слева) или шестнадцатеричным (с 0x или 0X слева) </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>o</strong> </td>
      <td align="left" valign="top">восьмеричное целое (с нулем слева или без него); <strong>int *</strong> </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>u</strong> </td>
      <td align="left" valign="top">беззнаковое десятичное целое; <strong>unsigned int *</strong> </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>x</strong> </td>
      <td align="left" valign="top">шестнадцатеричное целое (с 0x или 0X слева или без них); <strong>int *</strong> </td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>c</strong> </td>
      <td align="left" valign="top">символы; <strong>char *</strong>. Следующие символы ввода (по умолчанию один) размещаются в указанном месте. Обычный пропуск символов- разделителей подавляется; чтобы прочесть очередной символ, отличный от символа-разделителя, используйте %1s</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>s</strong> </td>
      <td align="left" valign="top">Строка символов(без обрамляющих кавычек); <strong>char *</strong>, указывающая на массив символов, достаточный для строки и завершающего символа '\0', который будет добавлен</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>e</strong>, <strong>f</strong>, <strong>g</strong> </td>
      <td align="left" valign="top">число с плавающей точкой, возможно, со знаком; обязательно присутствие либо десятичной точки, либо экспоненциальной части, а возможно, и обеих вместе; <strong>float *</strong></td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>%</strong> </td>
      <td align="left" valign="top">сам знак <strong>%</strong>, никакое присваивание не выполняется </td>
     </tr>
    </table>
    <p>Чтобы построить первый пример, обратимся к программе калькулятора из главы 4, в которой организуем ввод с помощью функции <emphasis>scanf</emphasis>:</p>
    <p><code>#include ‹stdio.h› </code></p>
    <empty-line/>
    <p><code>main() /* программа-калькулятор */ {</code></p>
    <p><code> double sum, v;</code></p>
    <empty-line/>
    <p><code> sum = 0;</code></p>
    <p><code> while (scanf ("%lf", &amp;v) == 1)</code></p>
    <p><code>  printf("\t%.2f\n", sum += v);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Предположим, что нам нужно прочитать строки ввода, содержащие данные вида</p>
    <p><code>25 дек 1988</code></p>
    <p>Обращение к <emphasis>scanf</emphasis> выглядит следующим образом:</p>
    <p><code>int day, year; /* день, год */ </code></p>
    <p><code>char monthname[20]; /* название месяца */ </code></p>
    <empty-line/>
    <p><code>scanf ("%d %s %d", &amp;day, monthname, &amp;year);</code></p>
    <p>Знак <emphasis>&amp;</emphasis> перед <emphasis>monthname</emphasis> не нужен, так как имя массива есть указатель.</p>
    <p>В строке формата могут присутствовать символы, не участвующие ни в одной из спецификаций; это значит, что эти символы должны появиться на вводе. Так, мы могли бы читать даты вида <emphasis>mm/dd/yy</emphasis> с помощью следующего обращения к <emphasis>scanf</emphasis>:</p>
    <p><code>int day, month, year; /* день, месяц, год */ </code></p>
    <p><code>scanf("%d/%d/%d", &amp;day, &amp;month, &amp;year);</code></p>
    <p>В своем формате функция <emphasis>scanf</emphasis> игнорирует пробелы и табуляции. Кроме того, при поиске следующей порции ввода она пропускает во входном потоке все символы- разделители (пробелы, табуляции, новые строки и т.д.). Воспринимать входной поток, не имеющий фиксированного формата, часто оказывается удобнее, если вводить всю строку целиком и для каждого отдельного случая подбирать подходящий вариант <emphasis>sscanf</emphasis>. Предположим, например, что нам нужно читать строки с датами, записанными в любой из приведенных выше форм. Тогда мы могли бы написать:</p>
    <p><code>while (getline(line, sizeof(line)) › 0) {</code></p>
    <p><code> if (sscanf(line, "%d %s %d", &amp;day, monthname, &amp;year) == 3)</code></p>
    <p><code>  printf("вepно: %s\r", line); /* в виде 25 дек 1968 */</code></p>
    <p><code> else if (sscanf(line, "%d/%d/%d", &amp;month, &amp;day, &amp;year) == 3)</code></p>
    <p><code>  printf("вepно: %s\n", line); /* в виде mm/dd/yy */</code></p>
    <p><code> else</code></p>
    <p><code>  printf("неверно: %s\n", line); /* неверная форма даты */</code></p>
    <p><code>}</code></p>
    <p>Обращения к <emphasis>scanf</emphasis> могут перемежаться с вызовами других функций ввода. Любая функция ввода, вызванная после <emphasis>scanf</emphasis>, продолжит чтение с первого еще непрочитанного символа.</p>
    <p>В завершение еще раз напомним, что аргументы функций <emphasis>scanf</emphasis> и <emphasis>sscanf</emphasis> должны быть указателями.</p>
    <p>Одна из самых распространенных ошибок состоит в том, что вместо того, чтобы написать</p>
    <p><code>scanf ("%d",&amp;n);</code></p>
    <p>пишут</p>
    <p><code>scanf("%d", n);</code></p>
    <p>Компилятор о подобной ошибке ничего не сообщает.</p>
    <p><strong>Упражнение 7.4</strong>. Напишите свою версию <emphasis>scanf</emphasis> по аналогии с <emphasis>minprintf</emphasis> из предыдущего параграфа.</p>
    <p><strong>Упражнение 7.5</strong>. Перепишите основанную на постфиксной записи программу калькулятора из главы 4 таким образом, чтобы для ввода и преобразования чисел она использовала <emphasis>scanf</emphasis> и/или <emphasis>sscanf</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>7.5 Доступ к файлам</p>
    </title>
    <p>Во всех предыдущих примерах мы имели дело со стандартным вводом и стандартным выводом, которые для программы автоматически предопределены операционной системой конкретной машины.</p>
    <p>Следующий шаг - научиться писать программы, которые имели бы доступ к файлам, заранее не подсоединенным к программам. Одна из программ, в которой возникает такая необходимость, - это программа <emphasis>cat</emphasis>, объединяющая несколько именованных файлов и направляющая результат в стандартный вывод. Функция <emphasis>cat</emphasis> часто применяется для выдачи файлов на экран, а также как универсальный "коллектор" файловой информации для тех программ, которые не имеют возможности обратиться к файлу по имени. Например, команда</p>
    <p><code>cat x.c y.c</code></p>
    <p>направит в стандартный вывод содержимое файлов <emphasis>x.c</emphasis> и <emphasis>y.c</emphasis> (и ничего более).</p>
    <p>Возникает вопрос: что надо сделать, чтобы именованные файлы можно было читать; иначе говоря, как связать внешние имена, придуманные пользователем, с инструкциями чтения данных?</p>
    <p>На этот счет имеются простые правила. Для того чтобы можно было читать из файла или писать в файл, он должен быть предварительно открыт с помощью библиотечной функции <strong>fopen</strong>. Функция <emphasis>fopen</emphasis> получает внешнее имя типа <emphasis>x.c</emphasis> или <emphasis>y.c</emphasis>, после чего осуществляет некоторые организационные действия и "переговоры" с операционной системой (технические детали которых здесь не рассматриваются) и возвращает указатель, используемый в дальнейшем для доступа к файлу.</p>
    <p>Этот указатель, называемый <emphasis>указателем файла</emphasis>, ссылается на структуру, содержащую информацию о файле (адрес буфера, положение текущего символа в буфере, открыт файл на чтение или на запись, были ли ошибки при работе с файлом и не встретился ли конец файла). Пользователю не нужно знать подробности, поскольку определения, полученные из ‹stdio.h›, включают описание такой структуры, называемой <strong>FILE</strong>.</p>
    <p>Единственное, что требуется для определения указателя файла, - это задать описания такого, например, вида:</p>
    <p><code>FILE *fp; </code></p>
    <p><code>FILE *fopen(char *name, char *mode);</code></p>
    <p>Это говорит, что <emphasis>fp</emphasis> есть указатель на <emphasis>FILE</emphasis>, a <emphasis>fopen</emphasis> возвращает указатель на <emphasis>FILE</emphasis>. Заметим, что <emphasis>FILE</emphasis> - это имя типа) наподобие <emphasis>int</emphasis>, а не тег структуры. Оно определено с помощью <strong>typedef</strong>. (Детали того, как можно реализовать <emphasis>fopen</emphasis> в системе UNIX, приводятся в параграфе 8.5.)</p>
    <p>Обращение к <emphasis>fopen</emphasis> в программе может выглядеть следующим образом:</p>
    <p><code>fp = fopen(name, mode);</code></p>
    <p>Первый аргумент - строка, содержащая имя файла. Второй аргумент несет информацию о режиме. Это тоже строка: в ней указывается, каким образом пользователь намерен применять файл. Возможны следующие режимы: чтение (<emphasis>read</emphasis> - "r"), запись (<emphasis>write</emphasis> - "w") и добавление (<emphasis>append</emphasis> - "a"), т. е. запись информации в конец уже существующего файла. В некоторых системах различаются текстовые и бинарные файлы; в случае последних в строку режима необходимо добавить букву "b" (<emphasis>binary</emphasis> - бинарный).</p>
    <p>Тот факт, что некий файл, которого раньше не было, открывается на запись или добавление, означает, что он создается (если такая процедура физически возможна). Открытие уже существующего файла на запись приводит к выбрасыванию его старого содержимого, в то время как при открытии файла на добавление его старое содержимое сохраняется. Попытка читать несуществующий файл является ошибкой. Могут иметь место и другие ошибки; например, ошибкой считается попытка чтения файла, который по статусу запрещено читать. При наличии любой ошибки <emphasis>fopen</emphasis> возвращает NULL. (Возможна более точная идентификация ошибки; детальная информация по этому поводу приводится в конце параграфа 1 приложения B.)</p>
    <p>Следующее, что нам необходимо знать, - это как читать из файла или писать в файл, коль скоро он открыт. Существует несколько способов сделать это, из которых самый простой состоит в том, чтобы воспользоваться функциями <strong>getc</strong> и <strong>putc</strong>. Функция <emphasis>getc</emphasis> возвращает следующий символ из файла; ей необходимо сообщить указатель файла, чтобы она знала откуда брать символ.</p>
    <p><code>int getc(FILE *fp);</code></p>
    <p>Функция <emphasis>getc</emphasis> возвращает следующий символ из потока, на который указывает <emphasis>*fp</emphasis>; в случае исчерпания файла или ошибки она возвращает EOF.</p>
    <p>Функция <emphasis>putc</emphasis> пишет символ <emphasis>c</emphasis> в файл <emphasis>fp</emphasis></p>
    <p><code>int putc(int с, FILE *fp);</code></p>
    <p>и возвращает записанный символ или EOF в случае ошибки. Аналогично <emphasis>getchar</emphasis> и <emphasis>putchar</emphasis>, реализация <emphasis>getc</emphasis> и <emphasis>putc</emphasis> может быть выполнена в виде макросов, а не функций.</p>
    <p>При запуске Си-программы операционная система всегда открывает три файла и обеспечивает три файловые ссылки на них. Этими файлами являются: стандартный ввод, стандартный вывод и стандартный файл ошибок; соответствующие им указатели называются <strong>stdin</strong>, <strong>stdout</strong> и <strong>stderr</strong>; они описаны в ‹stdio.h›. Обычно <emphasis>stdin</emphasis> соотнесен с клавиатурой, а <emphasis>stdout</emphasis> и <emphasis>stderr</emphasis> - с экраном. Однако <emphasis>stdin</emphasis> и <emphasis>stdout</emphasis> можно связать с файлами или, используя конвейерный механизм, соединить напрямую с другими программами, как это описывалось в параграфе 7.1.</p>
    <p>С помощью <emphasis>getc</emphasis>, <emphasis>putc</emphasis>, <emphasis>stdin</emphasis> и <emphasis>stdout</emphasis> функции <emphasis>getchar</emphasis> и <emphasis>putchar</emphasis> теперь можно определить следующим образом:</p>
    <p><code>#define getchar() getc(stdin) </code></p>
    <p><code>#define putchar(c) putc((c), stdout)</code></p>
    <p>Форматный ввод-вывод файлов можно построить на функциях <strong>fscanf</strong> и <strong>fprintf</strong>. Они идентичны <emphasis>scanf</emphasis> и <emphasis>printf</emphasis> с той лишь разницей, что первым их аргументом является указатель на файл, для которого осуществляется ввод-вывод, формат же указывается вторым аргументом.</p>
    <p><code>int fscanf(FILE *fp, char *format,…) </code></p>
    <p><code>int fprintf(FILE *fp, char *format,…)</code></p>
    <p>Вот теперь мы располагаем теми сведениями, которые достаточны для написания программы <emphasis>cat</emphasis>, предназначенной для конкатенации (последовательного соединения) файлов. Предлагаемая версия функции <emphasis>cat</emphasis>, как оказалось, удобна для многих программ. Если в командной строке присутствуют аргументы, они рассматриваются как имена последовательно обрабатываемых файлов. Если аргументов нет, то обработке подвергается стандартный ввод.</p>
    <p><code>#include ‹stdio.h› </code></p>
    <p><code>/* cat: конкатенация файлов, версия 1 */ </code></p>
    <p><code>main(int argc, char *argv[]) </code></p>
    <p><code>{</code></p>
    <p><code> FILE *fp;</code></p>
    <p><code> void filecopy(FILE *, FILE *);</code></p>
    <empty-line/>
    <p><code> if (argc == 1) /* нет аргументов; копируется стандартный ввод */</code></p>
    <p><code>  filecopy(stdin, stdout);</code></p>
    <p><code> else</code></p>
    <p><code>  while (--argc › 0)</code></p>
    <p><code>   if ((fp = fopen(*++argv, "r")) == NULL) {</code></p>
    <p><code>    printf("cat: не могу открыть файл %s\n", *argv);</code></p>
    <p><code>    return 1;</code></p>
    <p><code>   } else {</code></p>
    <p><code>    filecopy(fp, stdout);</code></p>
    <p><code>    fclose(fp);</code></p>
    <p><code>   }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* filecopy: копирует файл ifp в файл ofp */ </code></p>
    <p><code>void filecopy(FILE *ifp, FILE *ofp) </code></p>
    <p><code>{</code></p>
    <p><code> int c;</code></p>
    <empty-line/>
    <p><code> while ((c = getc(ifp)) != EOF)</code></p>
    <p><code>  putc(c, ofp);</code></p>
    <p><code>}</code></p>
    <p>Файловые указатели <emphasis>stdin</emphasis> и <emphasis>stdout</emphasis> представляют собой объекты типа <emphasis>FILE*</emphasis>. Это константы, а не переменные, следовательно, им нельзя ничего присваивать.</p>
    <p>Функция</p>
    <p><code>int fclose(FILE *fp)</code></p>
    <p>- обратная по отношению к <emphasis>fopen</emphasis>; она разрывает связь между файловым указателем и внешним именем (которая раньше была установлена с помощью <emphasis>fopen</emphasis>), освобождая тем самым этот указатель для других файлов. Так как в большинстве операционных систем количество одновременно открытых одной программой файлов ограничено, то файловые указатели, если они больше не нужны, лучше освобождать, как это и делается в программе <emphasis>cat</emphasis>. Есть еще одна причина применить <emphasis>fclose</emphasis> к файлу вывода, - это необходимость "опорожнить" буфер, в котором <emphasis>putc</emphasis> накопила предназначенные для вывода данные. При нормальном завершении работы программы для каждого открытого файла <emphasis>fclose</emphasis> вызывается автоматически. (Вы можете закрыть <emphasis>stdin</emphasis> и <emphasis>stdout</emphasis>, если они вам не нужны. Воспользовавшись библиотечной функцией <strong>freopen</strong>, их можно восстановить.)</p>
   </section>
   <section>
    <title>
     <p>7.6 Управление ошибками (stderr и exit)</p>
    </title>
    <p>Обработку ошибок в <emphasis>cat</emphasis> нельзя признать идеальной. Беда в том, что если файл по какой-либо причине недоступен, сообщение об этом мы получим по окончании конкатенируемого вывода. Это нас устроило бы, если бы вывод отправлялся только на экран, a не в файл или по конвейеру другой программе. Чтобы лучше справиться с этой проблемой, программе помимо стандартного вывода <emphasis>stdout</emphasis> придается еще один выходной поток, называемый <emphasis>stderr</emphasis>. Вывод в <emphasis>stderr</emphasis> обычно отправляется на экран, даже если вывод <emphasis>stdout</emphasis> перенаправлен в другое место. Перепишем <emphasis>cat</emphasis> так, чтобы сообщения об ошибках отправлялись в <emphasis>stderr</emphasis>.</p>
    <p><code>#include ‹stdio.h› </code></p>
    <p><code>/* cat: конкатенация файлов, версия 2 */ </code></p>
    <p><code>main(int argc, char *argv[]) </code></p>
    <p><code>{</code></p>
    <p><code> FILE *fp;</code></p>
    <p><code> void filecopy(FILE *, FILE *);</code></p>
    <p><code> char *prog = argv[0]; /* имя программы */</code></p>
    <p><code> if (argc == 1) /* нет аргументов, копируется станд. ввод */</code></p>
    <p><code>  filecopy(stdin, stdout);</code></p>
    <p><code> else</code></p>
    <p><code>  while (--argc › 0)</code></p>
    <p><code>   if ((fp = fopen(*++argv, "r")) == NULL) {</code></p>
    <p><code>    fprintf(stderr, "%s: не могу открыть файл %s\n", prog, *argv);</code></p>
    <p><code>    exit(1);</code></p>
    <p><code>   } else {</code></p>
    <p><code>    filecopy(fp, stdout);</code></p>
    <p><code>    fclose(fp);</code></p>
    <p><code>   }</code></p>
    <p><code> if (ferror(stdout)) {</code></p>
    <p><code>  fprintf(stderr, "%s: ошибка записи в stdout\n", prog);</code></p>
    <p><code>  exit(2);</code></p>
    <p><code> }</code></p>
    <p><code> exit(0);</code></p>
    <p><code>}</code></p>
    <p>Программа сигнализирует об ошибках двумя способами. Первый - сообщение об ошибке с помощью <emphasis>fprintf</emphasis> посылается в <emphasis>stderr</emphasis> с тем, чтобы оно попало на экран, а не оказалось на конвейере или в другом файле вывода. Имя программы, хранящееся в <emphasis>argv[0]</emphasis>, мы включили в сообщение, чтобы в случаях, когда данная программа работает совместно с другими, был ясен источник ошибки.</p>
    <p>Второй способ указать на ошибку - обратиться к библиотечной функции <strong>exit</strong>, завершающей работу программы. Аргумент функции <emphasis>exit</emphasis> доступен некоторому процессу, вызвавшему данный процесс. А следовательно, успешное или ошибочное завершение программы можно проконтролировать с помощью некоей программы, которая рассматривает эту программу в качестве подчиненного процесса. По общей договоренности возврат нуля сигнализирует о том, что работа прошла нормально, в то время как ненулевые значения обычно говорят об ошибках. Чтобы опорожнить буфера, накопившие информацию для всех открытых файлов вывода, функция <emphasis>exit</emphasis> вызывает <emphasis>fclose</emphasis>.</p>
    <p>Инструкция <strong>return</strong> <emphasis>exp</emphasis> главной программы <emphasis>main</emphasis> эквивалентна обращению к функции <emphasis>exit(exp)</emphasis>. Последний вариант (с помощью <emphasis>exit</emphasis>) имеет то преимущество, что он пригоден для выхода и из других функций, и, кроме того, слово <emphasis>exit</emphasis> легко обнаружить с помощью программы контекстного поиска, похожей на ту, которую мы рассматривали в главе 5. Функция <strong>ferror</strong> выдает ненулевое значение, если в файле <emphasis>fp</emphasis> была обнаружена ошибка.</p>
    <p><code>int ferror(FILE *fp)</code></p>
    <p>Хотя при выводе редко возникают ошибки, все же они встречаются (например, оказался переполненным диск); поэтому в программах широкого пользования они должны тщательно контролироваться.</p>
    <p>Функция <strong>feof</strong>(<emphasis>FILE *fp</emphasis>) aнaлoгичнa функции <emphasis>ferror</emphasis>; oнa вoзвpaщaeт нeнулевое значение, если встретился конец указанного в аргументе файла.</p>
    <p><code>int feof(FILE *fp);</code></p>
    <p>В наших небольших иллюстративных программах мы не заботились о выдаче статуса выхода, т. е. выдаче некоторого числа, характеризующего состояние программы в момент завершения: работа закончилась нормально или прервана из-за ошибки? Если работа прервана в результате ошибки, то какой? Любая серьезная программа должна выдавать статус выхода.</p>
   </section>
   <section>
    <title>
     <p>7.7 Ввод-вывод строк</p>
    </title>
    <p>В стандартной библиотеке имеется программа ввода <strong>fgets</strong>, аналогичная программе <emphasis>getline</emphasis>, которой мы пользовались в предыдущих главах.</p>
    <p><code>char *fgets(char *line, int maxline, FILE *fp)</code></p>
    <p>Функция <emphasis>fgets</emphasis> читает следующую строку ввода (включая и символ новой строки) из файла <emphasis>fp</emphasis> в массив символов <emphasis>line</emphasis>, причем она может прочитать не более <emphasis>MAXLINE-1</emphasis> символов. Переписанная строка дополняется символом '\0'. Обычно <emphasis>fgets</emphasis> возвращает <emphasis>line</emphasis>, а по исчерпании файла или в случае ошибки - NULL. (Наша <emphasis>getline</emphasis> возвращала длину строки, которой мы потом пользовались, и нуль в случае конца файла.)</p>
    <p>Функция вывода <strong>fputs</strong> пишет строку (которая может и не заканчиваться символом новой строки) в файл.</p>
    <p><code>int fputs(char *line, FILE *fp)</code></p>
    <p>Эта функция возвращает EOF, если возникла ошибка, и неотрицательное значение в противном случае.</p>
    <p>Библиотечные функции <strong>gets</strong> и <strong>puts</strong> подобны функциям <emphasis>fgets</emphasis> и <emphasis>fputs</emphasis>. Отличаются они тем, что оперируют только стандартными файлами <emphasis>stdin</emphasis> и <emphasis>stdout</emphasis>, и кроме того, <emphasis>gets</emphasis> выбрасывает последний символ '\n', a <emphasis>puts</emphasis> его добавляет.</p>
    <p>Чтобы показать, что ничего особенного в функциях вроде <emphasis>fgets</emphasis> и <emphasis>fputs</emphasis> нет, мы приводим их здесь в том виде, в каком они существуют в стандартной библиотеке на нашей системе.</p>
    <p><code>/* fgets: получает не более n символов из iop */ </code></p>
    <p><code>char *fgets(char *s, int n, FILE *iop) {</code></p>
    <p><code> register int c;</code></p>
    <p><code> register char *cs;</code></p>
    <empty-line/>
    <p><code> cs = s;</code></p>
    <p><code> while (--n › 0 &amp;&amp; (с = getc(iop)) != EOF)</code></p>
    <p><code>  if ((*cs++ = c) == '\n')</code></p>
    <p><code>   break;</code></p>
    <p><code> *cs= '\0';</code></p>
    <p><code> return (c == EOF &amp;&amp; cs == s) ? NULL : s;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* fputs: посылает строку s в файл iop */ </code></p>
    <p><code>int fputs(char *s, FILE *iop) </code></p>
    <p><code>{</code></p>
    <p><code> int c;</code></p>
    <empty-line/>
    <p><code> while (c = *s++)</code></p>
    <p><code>  putc(c, iop);</code></p>
    <p><code> return ferror(iop) ? EOF : 0;</code></p>
    <p><code>}</code></p>
    <p>Стандарт определяет, что функция <emphasis>ferror</emphasis> возвращает в случае ошибки ненулевое значение; <emphasis>fputs</emphasis> в случае ошибки возвращает EOF, в противном случае - неотрицательное значение.</p>
    <p>С помощью <emphasis>fgets</emphasis> легко реализовать нашу функцию <emphasis>getline</emphasis>:</p>
    <p><code>/* getline: читает строку, возвращает ее длину */ </code></p>
    <p><code>int getline(char *line, int max) </code></p>
    <p><code>{</code></p>
    <p><code> if (fgets(line, max, stdin) == NULL)</code></p>
    <p><code>  return 0;</code></p>
    <p><code> else</code></p>
    <p><code>  return strlen(line);</code></p>
    <p><code>}</code></p>
    <p><strong>Упражнение 7.6</strong>. Напишите программу, сравнивающую два файла и печатающую первую строку, в которой они различаются.</p>
    <p><strong>Упражнение 7.7</strong>. Модифицируйте программу поиска по образцу из главы 5 таким образом, чтобы она брала текст из множества именованных файлов, а если имен файлов в аргументах нет, то из стандартного ввода. Будет ли печататься имя файла, в котором найдена подходящая строка?</p>
    <p><strong>Упражнение 7.8</strong>. Напишите программу, печатающую несколько файлов. Каждый файл должен начинаться с новой страницы, предваряться заголовком и иметь свою нумерацию страниц.</p>
   </section>
   <section>
    <title>
     <p>7.8 Другие библиотечные функции</p>
    </title>
    <section>
     <p>В стандартной библиотеке представлен широкий спектр различных функций. Настоящий параграф содержит краткий обзор наиболее полезных из них. Более подробно эти и другие функции описаны в приложении B.</p>
    </section>
    <section>
     <title>
      <p>7.8.1 Операции со строками</p>
     </title>
     <p>Мы уже упоминали функции <emphasis>strlen</emphasis>, <emphasis>strcpy</emphasis>, <emphasis>strcat</emphasis> и <emphasis>strcmp</emphasis>, описание которых даны в ‹string.h›. Далее, до конца пункта, предполагается, что <emphasis>s</emphasis> и <emphasis>t</emphasis> имеют тип <emphasis>char *</emphasis>, <emphasis>c</emphasis> и <emphasis>n</emphasis> - тип <emphasis>int</emphasis>.</p>
     <p><strong>strcat(s,t)</strong> - приписывает <emphasis>t</emphasis> в конец <emphasis>s</emphasis>. </p>
     <p><strong>strncat(s,t,n)</strong> - приписывает <emphasis>n</emphasis> символов из <emphasis>t</emphasis> в конец <emphasis>s</emphasis>. </p>
     <p><strong>strcmp(s,t)</strong> - возвращает отрицательное число, нуль или положительное число для <emphasis>s</emphasis> ‹ <emphasis>t</emphasis>, <emphasis>s - t</emphasis> или <emphasis>s</emphasis> › <emphasis>t</emphasis>, соответственно. </p>
     <p><strong>strncmp(s,t,n)</strong> - делает то же, что и <emphasis>strcmp</emphasis>, но количество сравниваемых символов не может превышать <emphasis>n</emphasis> </p>
     <p><strong>strcpy(s,t)</strong> - копирует <emphasis>t</emphasis> в <emphasis>s</emphasis>. </p>
     <p><strong>strncpy(s,t,n)</strong> - копирует не более <emphasis>n</emphasis> символов из <emphasis>t</emphasis> в <emphasis>s</emphasis>. </p>
     <p><strong>strlen(s)</strong> - возвращает длину <emphasis>s</emphasis>. </p>
     <p><strong>strchr(s,c)</strong> - возвращает указатель на первое появление символа <emphasis>c</emphasis> в <emphasis>s</emphasis> или, если <emphasis>c</emphasis> нет в <emphasis>s</emphasis>, NULL. </p>
     <p><strong>strrchr(s,c)</strong> - возвращает указатель на последнее появление символа <emphasis>c</emphasis> в <emphasis>s</emphasis> или, если <emphasis>c</emphasis> нет в <emphasis>s</emphasis>, NULL. </p>
    </section>
    <section>
     <title>
      <p>7.8.2 Анализ класса символов и преобразование символов</p>
     </title>
     <p>Несколько функций из библиотеки ‹ctype.h› выполняют проверки и преобразование символов. Далее, до конца пункта, переменная <emphasis>c</emphasis> - это переменная типа <emphasis>int</emphasis>, которая может быть представлена значением <emphasis>unsigned</emphasis>, <emphasis>char</emphasis> или <emphasis>EOF</emphasis>. Все эти функции возвращают значения типа <emphasis>int</emphasis>.</p>
     <p><strong>isalpha(c)</strong> - не нуль, если <emphasis>c</emphasis> - буква; 0 в противном случае. </p>
     <p><strong>isupper(c)</strong> - не нуль, если <emphasis>c</emphasis> - буква верхнего регистра; 0 в противном случае. </p>
     <p><strong>islower(c)</strong> - не нуль, если <emphasis>c</emphasis> - буква нижнего регистра; 0 в противном случае. </p>
     <p><strong>isdigit(c)</strong> - не нуль, если <emphasis>c</emphasis> - цифра; 0 в противном случае. </p>
     <p><strong>isalnum(c)</strong> - не нуль, если или <emphasis>isalpha(c)</emphasis>, или <emphasis>isdigit(c)</emphasis> истинны; 0 в противном случае. </p>
     <p><strong>isspace(c)</strong> - не нуль, если <emphasis>c</emphasis> - символ пробела, табуляции, новой строки, возврата каретки, перевода страницы, вертикальной табуляции. </p>
     <p><strong>toupper(c)</strong> - возвращает <emphasis>c</emphasis>, приведенную к верхнему регистру. </p>
     <p><strong>tolower(c)</strong> - возвращает <emphasis>c</emphasis>, приведенную к нижнему регистру. </p>
    </section>
    <section>
     <title>
      <p>7.8.3 Функция ungetc</p>
     </title>
     <p>В стандартной библиотеке содержится более ограниченная версия функции <emphasis>ungetch</emphasis> по сравнению с той, которую мы написали в главе 4. Называется она <emphasis>ungetc</emphasis>. Эта функция, имеющая прототип</p>
     <p><code>int ungetc(int с, FILE *fp)</code></p>
     <p>отправляет символ <emphasis>c</emphasis> назад в файл <emphasis>fp</emphasis> и возвращает <emphasis>c</emphasis>, а в случае ошибки EOF. Для каждого файла гарантирован возврат не более одного символа. Функцию <emphasis>ungetc</emphasis> можно использовать совместно с любой из функций ввода вроде <emphasis>scanf</emphasis>, <emphasis>getc</emphasis>, <emphasis>getchar</emphasis> и т. д.</p>
    </section>
    <section>
     <title>
      <p>7.8.4 Исполнение команд операционной системы</p>
     </title>
     <p>Функция <strong>system</strong>(char *s) выполняет команду системы, содержащуюся в строке <emphasis>s</emphasis>, и затем возвращается к выполнению текущей программы.</p>
     <p>Содержимое <emphasis>s</emphasis>, строго говоря, зависит от конкретной операционной системы. Рассмотрим простой пример: в системе UNIX инструкция</p>
     <p><code>system("date");</code></p>
     <p>вызовет программу <emphasis>date</emphasis>, которая направит дату и время в стандартный вывод. Функция возвращает зависящий от системы статус выполненной команды. В системе UNIX возвращаемый статус - это значение, переданное функцией <emphasis>exit</emphasis>.</p>
    </section>
    <section>
     <title>
      <p>7.8.5 Управление памятью</p>
     </title>
     <p>Функции <strong>malloc</strong> и <strong>calloc</strong> динамически запрашивают блоки свободной памяти. Функция <emphasis>malloc</emphasis></p>
     <p><code>void *malloc(size_t n)</code></p>
     <p>возвращает указатель на <emphasis>n</emphasis> байт неинициализированной памяти или NULL, если запрос удовлетворить нельзя. Функция <emphasis>calloc</emphasis></p>
     <p><code>void *calloc(size_t n, size_t size)</code></p>
     <p>возвращает указатель на область, достаточную для хранения массива из <emphasis>n</emphasis> объектов указанного размера (<emphasis>size</emphasis>), или NULL, если запрос не удается удовлетворить. Выделенная память обнуляется.</p>
     <p>Указатель, возвращаемый функциями <emphasis>malloc</emphasis> и <emphasis>calloc</emphasis>, будет выдан с учетом выравнивания, выполненного согласно указанному типу объекта. Тем не менее к нему должна быть применена операция приведения к соответствующему типу (Как уже отмечалось (см. примеч. в параграфе 6.5), замечания о приведении типов значений, возвращаемых функциями <emphasis>malloc</emphasis> или <emphasis>calloc</emphasis>, - неверно. - <emphasis>Примеч. авт.</emphasis>), как это сделано в следующем фрагменте программы:</p>
     <p><code>int *ip; </code></p>
     <p><code>ip = (int *) calloc(n, sizeof(int));</code></p>
     <p>Функция <strong>free(p)</strong> освобождает область памяти, на которую указывает <emphasis>p</emphasis>, - указатель, первоначально полученный с помощью <emphasis>malloc</emphasis> или <emphasis>calloc</emphasis>. Никаких ограничений на порядок, в котором будет освобождаться память, нет, но считается ужасной ошибкой освобождение тех областей, которые не были получены с помощью <emphasis>calloc</emphasis> или <emphasis>malloc</emphasis>.</p>
     <p>Нельзя также использовать те области памяти, которые уже освобождены. Следующий пример демонстрирует типичную ошибку в цикле, освобождающем элементы списка.</p>
     <p><code>for (p = head; p != NULL; p = p-›next) /* НЕВЕРНО */</code></p>
     <p><code> free(p);</code></p>
     <p>Правильным будет, если вы до освобождения сохраните то, что вам потребуется, как в следующем цикле:</p>
     <p><code>for (p = head; p != NULL; p = q) {</code></p>
     <p><code> q = p-›next;</code></p>
     <p><code> free(p);</code></p>
     <p><code>}</code></p>
     <p>В параграфе 8.7 мы рассмотрим реализацию программы управления памятью вроде <emphasis>malloc</emphasis>, позволяющую освобождать выделенные блоки памяти в любой последовательности.</p>
    </section>
    <section>
     <title>
      <p>7.8.6 Математические функции</p>
     </title>
     <p>В <strong>‹math.h›</strong> описано более двадцати математических функций. Здесь же приведены наиболее употребительные. Каждая из них имеет один или два аргумента типа <emphasis>double</emphasis> и возвращает результат также типа <emphasis>double</emphasis>.</p>
     <p><strong>sin(x)</strong> - синус x, x в радианах </p>
     <p><strong>cos(x)</strong> - косинус x, x в радианах </p>
     <p><strong>atan2(y,x)</strong> - арктангенс y/x, y и x в радианах </p>
     <p><strong>exp(x)</strong> - экспоненциальная функция e в степени x </p>
     <p><strong>log(x)</strong> - натуральный (по основанию e) логарифм x (x›0) </p>
     <p><strong>log10(x)</strong> - обычный (по основанию 10) логарифм x (x›0) </p>
     <p><strong>pow(x,y)</strong> - x в степени y </p>
     <p><strong>sqrt(x)</strong> - корень квадратный x (x › 0) </p>
     <p><strong>fabs(x)</strong> - абсолютное значение x </p>
    </section>
    <section>
     <title>
      <p>7.8.7 Генератор случайных чисел</p>
     </title>
     <p>Функция <strong>rand()</strong> вычисляет последовательность псевдослучайных целых в диапазоне от нуля до значения, заданного именованной константой RAND_MAX, которая определена в ‹stdlib.h›. Привести случайные числа к значениям с плавающей точкой, большим или равным 0 и меньшим 1, можно по формуле</p>
     <p><code>#define frand() ((double) rand() / (RAND_MAX+1.0))</code></p>
     <p>(Если в вашей библиотеке уже есть функция для получения случайных чисел с плавающей точкой, вполне возможно, что ее статистические характеристики лучше указанной.)</p>
     <p>Функция <strong>srand</strong>(<emphasis>unsigned</emphasis>) устанавливает семя для <emphasis>rand</emphasis>. Реализации <emphasis>rand</emphasis> и <emphasis>srand</emphasis>, предлагаемые стандартом и, следовательно, переносимые на различные машины, рассмотрены в параграфе 2.7.</p>
     <p><strong>Упражнение 7.9</strong>. Реализуя функции вроде <emphasis>isupper</emphasis>, можно экономить либо память, либо время. Напишите оба варианта функции.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>Глава 8. Интерфейс с системой UNIX</p>
   </title>
   <section>
    <p>Свои услуги операционная система UNIX предлагает в виде набора <emphasis>системных вызовов</emphasis>, которые фактически являются ее внутренними функциями и к которым можно обращаться из программ пользователя. В настоящей главе описано, как в Си-программах можно применять некоторые наиболее важные вызовы. Если вы работаете в системе UNIX, то эти сведения будут вам полезны непосредственно и позволят повысить эффективность работы или получить доступ к тем возможностям, которых нет в библиотеке. Даже если вы используете Си в другой операционной системе, изучение рассмотренных здесь примеров все равно приблизит вас к пониманию программирования на Си; аналогичные программы (отличающиеся лишь деталями) вы встретите практически в любой операционной системе. Так как библиотека Си-программ, утвержденная в качестве стандарта ANSI, в основном отражает возможности системы UNIX, предлагаемые программы помогут вам лучше понять и библиотеку.</p>
    <p>Глава состоит из трех основных частей, описывающих: <emphasis>ввод-вывод</emphasis>, <emphasis>файловую систему</emphasis> и <emphasis>организацию управления памятью</emphasis>. В первых двух частях предполагается некоторое знакомство читателя с внешними характеристиками системы UNIX. В главе 7 мы рассматривали единый для всех операционных систем интерфейс ввода-вывода. В любой конкретной системе программы стандартной библиотеки пишутся с использованием средств именно этой конкретной системы. В следующих нескольких параграфах мы опишем вызовы системы UNIX по вводу-выводу и покажем, как с их помощью можно реализовать некоторые разделы стандартной библиотеки.</p>
   </section>
   <section>
    <title>
     <p>8.1 Дескрипторы файлов</p>
    </title>
    <p>В системе UNIX любые операции ввода-вывода выполняются посредством чтения и записи файлов, поскольку все внешние устройства, включая клавиатуру и экран, рассматриваются как объекты файловой системы. Это значит, что все связи между программой и внешними устройствами осуществляются в рамках единого однородного интерфейса.</p>
    <p>В самом общем случае, прежде чем читать или писать, вы должны проинформировать систему о действиях, которые вы намереваетесь выполнять в отношении файла; эта процедура называется <emphasis>открытием</emphasis> файла. Если вы собираетесь писать в файл, то, возможно, его потребуется создать заново или очистить от хранимой информации. Система проверяет ваши права на эти действия (файл существует? вы имеете к нему доступ?) и, если все в порядке, возвращает программе небольшое неотрицательное целое, называемое <emphasis>дескриптором файла</emphasis>. Всякий раз, когда осуществляется ввод-вывод, идентификация файла выполняется по его дескриптору, а не по имени. (Дескриптор файла аналогичен файловому указателю, используемому в стандартной библиотеке, или хэндлу (<emphasis>handle</emphasis>) в MS- DOS.) Вся информация об открытом файле хранится и обрабатывается операционной системой; программа пользователя обращается к файлу только через его дескриптор.</p>
    <p>Ввод с клавиатуры и вывод на экран применяются настолько часто, что для удобства работы с ними предусмотрены специальные соглашения. При запуске программы командный интерпретатор (<emphasis>shell</emphasis>) открывает три файла с дескрипторами 0, 1 и 2, которые называются соответственно <emphasis>стандартным вводом</emphasis>, <emphasis>стандартным выводом</emphasis> и <emphasis>стандартным файлом ошибок</emphasis>. Если программа читает из файла 0, а пишет в файлы 1 и 2 (здесь цифры - дескрипторы файлов), то она может осуществлять ввод и вывод, не заботясь об их открытии.</p>
    <p>Пользователь программы имеет возможность перенаправить ввод-вывод в файл или из файла с помощью значков ‹ и ›, как, например, в</p>
    <p><code>prog ‹ infile › outfile</code></p>
    <p>В этом случае командный интерпретатор заменит стандартные установки дескрипторов 0 и 1 на именованные файлы. Обычно дескриптор файла 2 остается подсоединенным к экрану, чтобы на него шли сообщения об ошибках. Сказанное верно и для ввода-вывода, связанного в конвейер. Во всех случаях замену файла осуществляет командный интерпретатор, а не программа. Программа, если она ссылается на файл 0 (в случае ввода) и файлы 1 и 2 (в случае вывода), не знает, ни откуда приходит ее ввод, ни куда отправляется ее вывод.</p>
   </section>
   <section>
    <title>
     <p>8.2 Нижний уровень ввода-вывода (read и write)</p>
    </title>
    <p>Ввод-вывод основан на системных вызовах <strong>read</strong> и <strong>write</strong>, к которым Си-программа обращается с помощью функций с именами <emphasis>read</emphasis> и <emphasis>write</emphasis>.</p>
    <p>Для обеих первым аргументом является <emphasis>дескриптор файла</emphasis>. Во втором аргументе указывается массив символов вашей программы, куда посылаются или откуда берутся данные. Третий аргумент - это количество пересылаемых байтов.</p>
    <p><code>int n_read = read(int fd, char *buf, int n); </code></p>
    <p><code>int n_written = write(int fd, char *buf, int n);</code></p>
    <p>Обе функции возвращают число переданных байтов. При чтении количество прочитанных байтов может оказаться меньше числа, указанного в третьем аргументе. Нуль означает конец файла, а -1 сигнализирует о какой-то ошибке. При записи функция возвращает количество записанных байтов, и если это число не совпадает с требуемым, следует считать, что запись не произошла. За один вызов можно прочитать или записать любое число байтов. Обычно это число равно или 1, что означает посимвольную передачу "без буферизации", или чему-нибудь вроде 1024 или 4096, соответствующих размеру физического блока внешнего устройства. Эффективнее обмениваться большим числом байтов, поскольку при этом требуется меньше системных вызовов. Используя полученные сведения, мы можем написать простую программу, копирующую свой ввод на свой вывод и эквивалентную программе копирования файла, описанной в главе 1. С помощью этой программы можно копировать откуда угодно и куда угодно, поскольку всегда существует возможность перенаправить ввод-вывод на любой файл или устройство.</p>
    <p><code>#include "syscalls.h" </code></p>
    <empty-line/>
    <p><code>main() /* копирование ввода на вывод */ </code></p>
    <p><code>{</code></p>
    <p><code> char buf[BUFSIZ]; </code></p>
    <p><code> int n;</code></p>
    <empty-line/>
    <p><code> while ((n = read(0, buf, BUFSIZ)) › 0)</code></p>
    <p><code>  write(i, buf, n);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Прототипы функций, обеспечивающие системные вызовы, мы собрали в файле <emphasis>syscalls.h</emphasis>, что позволяет нам включать его в программы этой главы. Однако имя данного файла не зафиксировано стандартом.</p>
    <p>Параметр BUFSIZ также определен в ‹syscalls.h›: в каждой конкретной системе он имеет свое значение. Если размер файла не кратен BUFSIZ, то какая-то операция чтения вернет значение меньшее, чем BUFSIZ, а следующее обращение к <emphasis>read</emphasis> даст в качестве результата нуль.</p>
    <p>Полезно рассмотреть, как используются <emphasis>read</emphasis> и <emphasis>write</emphasis> при написании программ более высокого уровня - таких как <emphasis>getchar</emphasis>, <emphasis>putchar</emphasis> и т. д. Вот, к примеру, версия программы <emphasis>getchar</emphasis>, которая осуществляет небуферизованный ввод, читая по одному символу из стандартного входного потока.</p>
    <p><code>#include "syscalls.h" </code></p>
    <p><code>/* getchar: небуферизованный ввод одного символа */ </code></p>
    <p><code>int getchar(void) {</code></p>
    <p><code> char с;</code></p>
    <p><code> return (read(0, &amp;c, 1) == 1) ? (unsigned char) с: EOF;</code></p>
    <p><code>}</code></p>
    <p>Переменная <emphasis>c</emphasis> должна быть типа <emphasis>char</emphasis>, поскольку <emphasis>read</emphasis> требует указателя на <emphasis>char</emphasis>. Приведение <emphasis>c</emphasis> к <emphasis>unsigned char</emphasis> перед тем, как вернуть ее в качестве результата, исключает какие-либо проблемы, связанные с распространением знака.</p>
    <p>Вторая версия <emphasis>getchar</emphasis> осуществляет ввод большими кусками, но при каждом обращении выдает только один символ.</p>
    <p><code>#include "syscalls.h"</code></p>
    <empty-line/>
    <p><code>/* getchar: простая версия с буферизацией */</code></p>
    <p><code>int getchar(void) </code></p>
    <p><code>{</code></p>
    <p><code> static char buf[BUFSIZ];</code></p>
    <p><code> static char *bufp = buf;</code></p>
    <p><code> static int n = 0;</code></p>
    <empty-line/>
    <p><code> if (n == 0) { /* буфер пуст */</code></p>
    <p><code>  n = read(0, buf, sizeof buf);</code></p>
    <p><code>  bufp = buf;</code></p>
    <p><code> }</code></p>
    <p><code> return (--n ›= 0) ? (unsigned char) *bufp++ : EOF;</code></p>
    <p><code>}</code></p>
    <p>Если приведенные здесь версии функции getchar компилируются с включением заголовочного файла ‹stdio.h› и в этом заголовочном файле <emphasis>getchar</emphasis> определена как макрос, то нужно задать строку <emphasis>#undef</emphasis> с именем <emphasis>getchar</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>8.3 Системные вызовы open, creat, close, unlink</p>
    </title>
    <p>В отличие от стандартных файлов ввода, вывода и ошибок, которые открыты по умолчанию, остальные файлы нужно открывать явно. Для этого есть два системных вызова: <strong>open</strong> и <strong>creat</strong>.</p>
    <p>Функция <emphasis>open</emphasis> почти совпадает с <emphasis>fopen</emphasis>, рассмотренной в главе 7. Разница между ними в том, что первая возвращает не файловый указатель, а дескриптор файла типа <emphasis>int</emphasis>. При любой ошибке <emphasis>open</emphasis> возвращает -1.</p>
    <p><code>include ‹fcntl.h› </code></p>
    <empty-line/>
    <p><code>int fd; </code></p>
    <p><code>int open(char *name, int flags, int perms); </code></p>
    <empty-line/>
    <p><code>fd = open(name, flags, perms);</code></p>
    <p>Как и в <emphasis>fopen</emphasis>, аргумент <emphasis>name</emphasis> - это строка, содержащая имя файла. Второй аргумент, <emphasis>flags</emphasis>, имеет тип <emphasis>int</emphasis> и специфицирует, каким образом должен быть открыт файл. Его основными значениями являются:</p>
    <p><code>O_RDONLY - открыть только на чтение; </code></p>
    <p><code>O_WRONLY - открыть только на запись; </code></p>
    <p><code>O_RDWR - открыть и на чтение, и на запись.</code></p>
    <p>В System V UNIX эти константы определены в ‹fcntl.h›, а в версиях Berkley (BSD) - в ‹sys/file.h›.</p>
    <p>Чтобы открыть существующий файл на чтение, можно написать</p>
    <p><code>fd = open(name, 0_RDONLY, 0);</code></p>
    <p>Далее везде, где мы пользуемся функцией <emphasis>open</emphasis>, ее аргумент <emphasis>perms</emphasis> равен нулю.</p>
    <p>Попытка открыть несуществующий файл является ошибкой. Создание нового файла или перезапись старого обеспечивается системным вызовом <strong>creat</strong>. Например</p>
    <p><code>int creat(char *name, int perms); </code></p>
    <p><code>fd = creat(name, perms);</code></p>
    <p>Функция <emphasis>creat</emphasis> возвращает дескриптор файла, если файл создан, и -1, если по каким-либо причинам файл создать не удалось. Если файл уже существует, <emphasis>creat</emphasis> "обрежет" его до нулевой длины, что равносильно выбрасыванию предыдущего содержимого данного файла; создание уже существующего файла не является ошибкой.</p>
    <p>Если строится действительно новый файл, то <emphasis>creat</emphasis> его создаст с правами доступа, специфицированными в аргументе <emphasis>perms</emphasis>. В системе UNIX с каждым файлом ассоциированы девять битов, содержащие информацию о правах пользоваться этим файлом для чтения, записи и исполнения лицам трех категорий: собственнику файла, определенной им группе лиц и всем остальным. Таким образом, права доступа удобно специфицировать с помощью трех восьмеричных цифр. Например, 0755 специфицирует чтение, запись и право исполнения собственнику файла, а также чтение и право исполнения группе и всем остальным.</p>
    <p>Для иллюстрации приведем упрощенную версию программы <emphasis>cp</emphasis> системы UNIX, которая копирует один файл в другой. В нашей версии копируется только один файл, не позволяется во втором аргументе указывать директорий (каталог), и права доступа не копируются, а задаются константой.</p>
    <p><code>#include ‹stdio.h› </code></p>
    <p><code>#include ‹fcntl.h› </code></p>
    <p><code>#include "syscalls.h" </code></p>
    <p><code>#define PERMS 0666 /* RW для собственника, группы и остальных */ </code></p>
    <empty-line/>
    <p><code>void error(char *,…); </code></p>
    <empty-line/>
    <p><code>/* cp: копирование f1 в f2 */ </code></p>
    <p><code>main(int argc, char *argv[]) </code></p>
    <p><code>{</code></p>
    <p><code> int f1, f2, n;</code></p>
    <p><code> char buf[BUFSIZ];</code></p>
    <p><code> if (argc != 3)</code></p>
    <p><code>  error("Обращение: cp откуда куда");</code></p>
    <p><code> if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)</code></p>
    <p><code>  error("cp: не могу открыть файл %s", argv[1]);</code></p>
    <p><code> if ((f2 = creat(argv[2], PERMS)) == -1)</code></p>
    <p><code>  error("cp: не могу создать файл %s, режим %03o", argv[2], PERMS);</code></p>
    <p><code> while ((n = read(f1, buf, BUFSIZ)) › 0)</code></p>
    <p><code>  if (write(f2, buf, n) != n)</code></p>
    <p><code>   error ("cp: ошибка при записи в файл %s", argv[2]);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Данная программа создаст файл вывода с фиксированными правами доступа, определяемыми кодом 0666. С помощью системного вызова <emphasis>stat</emphasis>, который будет описан в параграфе 8.6, мы можем определить режим использования существующего файла и задать тот же режим для копии.</p>
    <p>Заметим, что функция <emphasis>error</emphasis>, вызываемая с различным числом аргументов, во многом похожа на <emphasis>printf</emphasis>. Реализация <emphasis>error</emphasis> иллюстрирует, как пользоваться другими программами семейства <emphasis>printf</emphasis>. Библиотечная функция <emphasis>vprintf</emphasis> аналогична <emphasis>printf</emphasis>, с той лишь оговоркой, что переменная часть списка аргументов заменена в ней одним аргументом, который инициализируется макросом <emphasis>va_start</emphasis>. Подобным же образом соотносятся функции <emphasis>vfprinf</emphasis> с <emphasis>fprintf</emphasis> и <emphasis>vsprintf</emphasis> с <emphasis>sprintf</emphasis>.</p>
    <p><code>#include ‹stdio.h› </code></p>
    <p><code>#include ‹stdarg.h› </code></p>
    <empty-line/>
    <p><code>/* error: печатает сообщение об ошибке и умирает */ </code></p>
    <p><code>void error(char *fmt, …) {</code></p>
    <p><code> va_list args;</code></p>
    <empty-line/>
    <p><code> va_start(args, fmt);</code></p>
    <p><code> fprintf(stderr, "ошибка: ");</code></p>
    <p><code> vfprintf(stderr, fmt, args);</code></p>
    <p><code> fprintf(stderr, "\n");</code></p>
    <p><code> va_end(args);</code></p>
    <p><code> exit(1);</code></p>
    <p><code>}</code></p>
    <p>На количество одновременно открытых в программе файлов имеется ограничение (обычно их число колеблется около 20). Поэтому любая программа, которая намеревается работать с большим количеством файлов, должна быть готова повторно использовать их дескрипторы. Функция <strong>close</strong>(<emphasis>int fd</emphasis>) разрывает связь между файловым дескриптором и открытым файлом и освобождает дескриптор для его применения с другим файлом. Она аналогична библиотечной функции <emphasis>fclose</emphasis> с тем лишь различием, что никакой очистки буфера не делает. Завершение программы с помощью <emphasis>exit</emphasis> или <emphasis>return</emphasis> в главной программе закрывает все открытые файлы.</p>
    <p>Функция <strong>unlink</strong>(<emphasis>char *name</emphasis>) удаляет имя файла из файловой системы. Она соответствует функции <emphasis>remove</emphasis> стандартной библиотеки.</p>
    <p><strong>Упражнение 8.1</strong>. Перепишите программу <emphasis>cat</emphasis> из главы 7, используя функции <emphasis>read</emphasis>, <emphasis>write</emphasis>, <emphasis>open</emphasis> и <emphasis>close</emphasis>. Замените ими соответствующие функции стандартной библиотеки. Поэкспериментируйте, чтобы сравнить быстродействие двух версий.</p>
   </section>
   <section>
    <title>
     <p>8.4 Произвольный доступ (lseek)</p>
    </title>
    <p>Ввод-вывод обычно бывает последовательным, т. е. каждая новая операция чтения-записи имеет дело с позицией файла, следующей за той, что была в предыдущей операции (чтения-записи). При желании, однако, файл можно читать или производить запись в него в произвольном порядке. Системный вызов <strong>lseek</strong> предоставляет способ передвигаться по файлу, не читая и не записывая данные. Так, функция</p>
    <p><code>long lseek(int fd, long offset, int origin);</code></p>
    <p>в файле с дескриптором <emphasis>fd</emphasis> устанавливает текущую позицию, смещая ее на величину <emphasis>offset</emphasis> относительно места, задаваемого значением <emphasis>origin</emphasis>. Значения параметра origin 0, 1 или 2 означают, что на величину <emphasis>offset</emphasis> отступают соответственно от <emphasis>начала</emphasis>, от <emphasis>текущей позиции</emphasis> или от <emphasis>конца</emphasis> файла. Например, если требуется добавить что-либо в файл (когда в командном интерпретаторе <emphasis>shell</emphasis> системы UNIX ввод перенаправлен оператором ›› в файл или когда в <emphasis>fopen</emphasis> задан аргумент "<emphasis>a</emphasis>"), то прежде чем что-либо записывать, необходимо найти конец файла с помощью вызова функции</p>
    <p><code>lseek(fd, 0L, 2);</code></p>
    <p>Чтобы вернуться назад, в начало файла, надо выполнить</p>
    <p><code>lseek(fd, 0L, 0);</code></p>
    <p>Следует обратить внимание на аргумент 0L: вместо 0L можно было бы написать (<emphasis>long</emphasis>)0 или, если функция <emphasis>lseek</emphasis> должным образом объявлена, просто 0. Благодаря <emphasis>lseek</emphasis> с файлами можно работать так, как будто это большие массивы, правда, с замедленным доступом. Например, следующая функция читает любое число байтов из любого места файла. Она возвращает число прочитанных байтов или -1 в случае ошибки.</p>
    <p><code>#include "syscalls.h" </code></p>
    <p><code>/* get: читает n байт из позиции pos */ </code></p>
    <p><code>int get(int fd, long pos, char *buf, int n) </code></p>
    <p><code>{</code></p>
    <p><code> if (lseek(fd, pos, 0) ›= 0) /* установка позиции */</code></p>
    <p><code>  return read(fd, buf, n);</code></p>
    <p><code> else</code></p>
    <p><code> return -1;</code></p>
    <p><code>}</code></p>
    <p>Возвращаемое функцией <emphasis>lseek</emphasis> значение имеет тип <emphasis>long</emphasis> и является новой позицией в файле или, в случае ошибки, равно -1. Функция <emphasis>fseek</emphasis> из стандартной библиотеки аналогична <emphasis>lseek</emphasis>: от последней она отличается тем, что в случае ошибки возвращает некоторое ненулевое значение, а ее первый аргумент имеет тип <emphasis>FILE*</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>8.5 Пример. Реализация функций fopen и getc</p>
    </title>
    <p>Теперь на примере функций <emphasis>fopen</emphasis> и <emphasis>getc</emphasis> из стандартной библиотеки покажем, как описанные выше части согласуются друг с другом.</p>
    <p>Напомним, что файлы в стандартной библиотеке описываются файловыми указателями, а не дескрипторами. <emphasis>Указатель файла</emphasis> - это указатель на структуру, содержащую информацию о файле: указатель на буфер, позволяющий читать файл большими кусками: число незанятых байтов буфера; указатель на следующую позицию в буфере; дескриптор файла; флажки, описывающие режим (чтение/запись), ошибочные состояния и т. д.</p>
    <p>Структура данных, описывающая файл, содержится в ‹stdio.h›, который необходимо включать (с помощью <emphasis>#include</emphasis>) в любой исходный файл, если в том осуществляется стандартный ввод-вывод. Этот же заголовочный файл включен и в исходные тексты библиотеки ввода-вывода.</p>
    <p>В следующем фрагменте, типичном для файла ‹stdio.h›, имена, используемые только в библиотечных функциях, начинаются с подчеркивания. Это сделано для того, чтобы они случайно не совпали с именами, фигурирующими в программе пользователя. Такое соглашение соблюдается во всех программах стандартной библиотеки.</p>
    <p><code>#define NULL 0 </code></p>
    <p><code>#define EOF (-1) </code></p>
    <p><code>#define BUFSIZ 1024 </code></p>
    <p><code>#define OPEN_MAX 20 /* max число одновременно открытых файлов */ </code></p>
    <p><code>typedef struct _iobuf {</code></p>
    <p><code> int cnt; /* количество оставшихся символов */</code></p>
    <p><code> char *ptr; /* позиция следующего символа */</code></p>
    <p><code> char *base; /* адрес буфера */</code></p>
    <p><code> int flag; /* режим доступа */</code></p>
    <p><code> int fd; /* дескриптор файла */</code></p>
    <p><code>} FILE;</code></p>
    <empty-line/>
    <p><code>extern FILE _iob[OPEN_MAX];</code></p>
    <empty-line/>
    <p><code>#define stdin (&amp;iob[0]) </code></p>
    <p><code>#define stdout (&amp;_iob[1]) </code></p>
    <p><code>#define stderr (&amp;_iob[2]) </code></p>
    <empty-line/>
    <p><code>enum _flags {</code></p>
    <p><code> _READ = 01, /* файл открыт на чтение */</code></p>
    <p><code> _WRITE = 02, /* файл открыт на запись */</code></p>
    <p><code> _UNBUF = 04, /* файл не буферизируется */</code></p>
    <p><code> _EOF = 010, /* в данном файле встретился EOF */</code></p>
    <p><code> _ERR = 020 /* в данном файле встретилась ошибка */</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int _fillbuf(FILE *); </code></p>
    <p><code>int _flushbuf(int, FILE *); </code></p>
    <empty-line/>
    <p><code>#define feof(p) (((p)-›flag &amp; _EOF) != 0) </code></p>
    <p><code>#define ferror(p) (((p)-›flag &amp; _ERR) != 0) </code></p>
    <p><code>#define fileno(p) ((p)-›fd) </code></p>
    <empty-line/>
    <p><code>#define getc(p) (--(p)-›cnt ›= 0 \</code></p>
    <p><code> ? (unsigned char) *(p)-›ptr++ : _fillbuf(p)) </code></p>
    <p><code>#define putc(x,p) (--(p)-›cnt ›= 0 \</code></p>
    <p><code> ? *(p)-›ptr++ = (x) : _flushbuf((x),p)) </code></p>
    <empty-line/>
    <p><code>#define getchar() getc(stdin) </code></p>
    <p><code>#define putchar(x) putc((x), stdout)</code></p>
    <p>Макрос <emphasis>getc</emphasis> обычно уменьшает счетчик числа символов, находящихся в буфере, и возвращает символ, после чего приращивает указатель на единицу. (Напомним, что длинные <emphasis>#define</emphasis> с помощью обратной наклонной черты можно продолжить на следующих строках.) Когда значение счетчика становится отрицательным, <emphasis>getc</emphasis> вызывает <emphasis>_fillbuf</emphasis>, чтобы снова заполнить буфер, инициализировать содержимое структуры и выдать символ. Типы возвращаемых символов приводятся к <emphasis>unsigned</emphasis>; это гарантирует, что все они будут положительными.</p>
    <p>Хотя в деталях ввод-вывод здесь не рассматривается, мы все же привели полное определение <emphasis>putc</emphasis>. Сделано это, чтобы показать, что она действует во многом так же, как и <emphasis>getc</emphasis>, вызывая функцию <emphasis>_flushbuf</emphasis>, когда буфер полон. В тексте имеются макросы, позволяющие получать доступ к флажкам ошибки и конца файла, а также к его дескриптору.</p>
    <p>Теперь можно написать функцию <emphasis>fopen</emphasis>. Большая часть инструкций <emphasis>fopen</emphasis> относится к открытию файла, к соответствующему его позиционированию и к установке флажковых битов, предназначенных для индикации текущего состояния. Сама <emphasis>fopen</emphasis> не отводит места для буфера; это делает <emphasis>_fillbuf</emphasis> при первом чтении файла.</p>
    <p><code>#include &lt;fcntl.h&gt;</code></p>
    <p><code>#include "syscalls.h"</code></p>
    <p><code>#define PERMS 0666 /* RW для собственника, группы и проч. */</code></p>
    <empty-line/>
    <p><code>/* fopen: открывает файл, возвращает файловый указатель */</code></p>
    <p><code>FILE *fopen(char *name, char *mode)</code></p>
    <p><code>{</code></p>
    <p><code> int fd;</code></p>
    <p><code> FILE *fp;</code></p>
    <empty-line/>
    <p><code> if (*mode != 'r' &amp;&amp; *mode != 'w' &amp;&amp; *mode != 'a'</code></p>
    <p><code>  return NULL;</code></p>
    <p><code> for (fp = _iob; fp &lt; _iob + OPEN_MAX; fp++)</code></p>
    <p><code>  if ((fp-&gt;flag &amp; (_READ | _WRITE)) == 0)</code></p>
    <p><code>   break; /* найдена свободная позиция */</code></p>
    <p><code> if (fp &gt;= _iob + OPEN_MAX)  /* нет свободной позиция */</code></p>
    <p><code>  return NULL;</code></p>
    <empty-line/>
    <p><code> if (*mode == 'w')</code></p>
    <p><code>  fd = creat(name, PERMS);</code></p>
    <p><code> else if (*mode == 'a') {</code></p>
    <p><code>  if ((fd = open(name, O_WRONLY, 0)) == -1)</code></p>
    <p><code>   fd = creat(name, PERMS);</code></p>
    <p><code>  lseek(fd, 0L, 2);</code></p>
    <p><code> } else</code></p>
    <p><code>  fd = open(name, O_RDONLY, 0);</code></p>
    <p><code> if (fd == -1) /* невозможен доступ по имени name */</code></p>
    <p><code>  return NULL;</code></p>
    <p><code> fp-&gt;fd = fd;</code></p>
    <p><code> fp-&gt;cnt = 0;</code></p>
    <p><code> fp-&gt;base = NULL;</code></p>
    <p><code> fp-&gt;flag = (*mode == 'r') ? _READ : _WRITE;</code></p>
    <p><code> return fp;</code></p>
    <p><code>}</code></p>
    <p>Приведенная здесь версия <emphasis>fopen</emphasis> реализует не все режимы доступа, оговоренные стандартом; но, мы думаем, их реализация в полном объеме не намного увеличит длину программы. Наша <emphasis>fopen</emphasis> не распознает буквы <emphasis>b</emphasis>, сигнализирующей о бинарном вводе-выводе (поскольку в системах UNIX это не имеет смысла), и знака <emphasis>+</emphasis>, указывающего на возможность одновременно читать и писать.</p>
    <p>Для любого файла в момент первого обращения к нему с помощью макровызова <emphasis>getc</emphasis> счетчик <emphasis>cnt</emphasis> равен нулю. Следствием этого будет вызов <emphasis>_fillbuf</emphasis>. Коли выяснится, что файл на чтение не открыт, то функция <emphasis>_fillbuf</emphasis> немедленно возвратит EOF. В противном случае она попытается запросить память для буфера (если чтение должно быть с буферизацией).</p>
    <p>После получения области памяти для буфера <emphasis>_fillbuf</emphasis> обращается к <emphasis>read</emphasis>, чтобы его наполнить, устанавливает счетчик и указатели и возвращает первый символ из буфера. В следующих обращениях <emphasis>_fillbuf</emphasis> обнаружит, что память для буфера уже выделена.</p>
    <p><code>#include "syscalls.h"</code></p>
    <p><code>/* _fillbuf: запрос памяти и заполнение буфера */</code></p>
    <p><code>int _fillbuf(FILE *fp)</code></p>
    <p><code>{</code></p>
    <p><code> int bufsize;</code></p>
    <empty-line/>
    <p><code> if ((fp-&gt;flag &amp; ( _READ | _EOF | _ERR )) != _READ)</code></p>
    <p><code>  return EOF;</code></p>
    <p><code> bufsize = (fp-&gt;flag &amp; _UNBUF) ? 1 : BUFSIZ;</code></p>
    <p><code> if (fp-&gt;base == NULL) /* буфера еще нет */</code></p>
    <p><code>  if ((fp-&gt;base = (char *) malloc(bufsize)) == NULL)</code></p>
    <p><code>   return EOF; /* нельзя получить буфер */</code></p>
    <p><code> fp-&gt;ptr = fp-&gt;base;</code></p>
    <p><code> fp-&gt;cnt = read(fp-&gt;fd, fp-&gt;ptr, bufsize);</code></p>
    <p><code> if (--fp-&gt;cnt &lt; 0) {</code></p>
    <p><code>  if (fp-&gt;cnt == -1)</code></p>
    <p><code>   fp-&gt;flag |= _EOF;</code></p>
    <p><code>  else</code></p>
    <p><code>   fp-&gt;flag |= _ERR;</code></p>
    <p><code>  fp-&gt;cnt = 0;</code></p>
    <p><code>  return EOF;</code></p>
    <p><code> }</code></p>
    <p><code> return (unsigned char) *fp-&gt;ptr++;</code></p>
    <p><code>}</code></p>
    <p>Единственное, что осталось невыясненным, - это каким образом организовать начало счета. Массив <emphasis>_iob</emphasis> следует определить и инициализировать так, чтобы перед тем как программа начнет работать, в нем уже была информация о файлах <emphasis>stdin</emphasis>, <emphasis>stdout</emphasis> и <emphasis>stderr</emphasis>.</p>
    <p><code>FILE _iob[OPEN_MAX] = { /* stdin, stdout, stderr: */</code></p>
    <p><code> { 0, (char *) 0, (char *) 0, _READ, 0 },</code></p>
    <p><code> { 0, (char *) 0, (char *) 0, _WRITE, 1 },</code></p>
    <p><code> { 0, (char *) 0, (char *) 0, _WRITE | _UNBUF, 2 }</code></p>
    <p><code>};</code></p>
    <p>Инициализация <emphasis>flag</emphasis> как части структуры показывает, что <emphasis>stdin</emphasis> открыт на чтение, <emphasis>stdout</emphasis> - на запись, а <emphasis>stderr</emphasis> - на запись без буферизации.</p>
    <p><strong>Упражнение 8.2</strong>. Перепишите функции <emphasis>fopen</emphasis> и <emphasis>_fillbuf</emphasis>, работая с флажками как с полями, а не с помощью явных побитовых операций. Сравните размеры и скорости двух вариантов программ.</p>
    <p><strong>Упражнение 8.3</strong>. Разработайте и напишите функции <emphasis>_flushbuf</emphasis>, <emphasis>fflush</emphasis> и <emphasis>fclose</emphasis>.</p>
    <p><strong>Упражнение 8.4</strong>. Функция стандартной библиотеки</p>
    <p><code>int fseek(FILE *fp, long offset, int origin)</code></p>
    <p>идентична функции <emphasis>lseek</emphasis> с теми, однако, отличиями, что <emphasis>fp</emphasis> - это файловый указатель, а не дескриптор, и возвращает она значение <emphasis>int</emphasis>, означающее состояние файла, а не позицию в нем. Напишите свою версию <emphasis>fseek</emphasis>. Обеспечьте, чтобы работа вашей <emphasis>fseek</emphasis> по буферизации была согласована с буферизацией, используемой другими функциями библиотеки.</p>
   </section>
   <section>
    <title>
     <p>8.6 Пример. Печать каталогов</p>
    </title>
    <p>При разного рода взаимодействиях с файловой системой иногда требуется получить <emphasis>только</emphasis> информацию о файле, а не его содержимое. Такая потребность возникает, например, в программе печати каталога файлов, работающей аналогично команде <emphasis>ls</emphasis> системы UNIX. Она печатает имена файлов каталога и по желанию пользователя другую дополнительную информацию (размеры, права доступа и т. д.). Аналогичной командой в MS-DOS является <emphasis>dir</emphasis>.</p>
    <p>Так как в системе UNIX каталог - это тоже файл, функции <emphasis>ls</emphasis>, чтобы добраться до имен файлов, нужно только его прочитать. Но чтобы получить другую информацию о файле (например узнать его размер), необходимо выполнить системный вызов. В других системах (в MS-DOS, например) системным вызовом приходится пользоваться даже для получения доступа к именам файлов. Наша цель - обеспечить доступ к информации по возможности системно-независимым способом несмотря на то, что реализация может быть существенно системно-зависима. Проиллюстрируем сказанное написанием программы <emphasis>fsize</emphasis>. Функция <emphasis>fsize</emphasis> - частный случай программы <emphasis>ls</emphasis>: она печатает размеры всех файлов, перечисленных в командной строке. Если какой-либо из файлов сам является каталогом, то, чтобы получить информацию о нем, <emphasis>fsize</emphasis> обращается сама к себе. Если аргументов в командной строке нет, то обрабатывается текущий каталог.</p>
    <p>Для начала вспомним структуру файловой системы в UNIXe. <emphasis>Каталог</emphasis> - это файл, содержащий список имен файлов и некоторую информацию о том, где они расположены. "Место расположения" - это индекс, обеспечивающий доступ в другую таблицу, называемую "списком узлов <strong>inode</strong>". Для каждого файла имеется свой <emphasis>inode</emphasis>, где собрана вся информация о файле, за исключением его имени. Каждый элемент каталога состоит из двух частей: из имени файла и номера узла <emphasis>inode</emphasis>.</p>
    <p>К сожалению, формат и точное содержимое каталога не одинаковы в разных версиях системы. Поэтому, чтобы переносимую компоненту отделить от непереносимой, разобьем нашу задачу на две. Внешний уровень определяет структуру, названную <emphasis>Dirent</emphasis>, и три подпрограммы <emphasis>opendir</emphasis>, <emphasis>readdir</emphasis> и <emphasis>closedir</emphasis>: в результате обеспечивается системно-независимый доступ к имени и номеру узла <emphasis>inode</emphasis> каждого элемента каталога. Мы будем писать программу <emphasis>fsize</emphasis>, рассчитывая на такой интерфейс, а затем покажем, как реализовать указанные функции для систем, использующих ту же структуру каталога, что и Version 7 и System V UNIX. Другие варианты оставим для упражнений.</p>
    <p>Структура <emphasis>Dirent</emphasis> содержит номер узла <emphasis>inode</emphasis> и имя. Максимальная длина имени файла равна NAME_MAX - это значение системно-зависимо. Функция <emphasis>opendir</emphasis> возвращает указатель на структуру, названную <emphasis>DIR</emphasis> (по аналогии с <emphasis>FILE</emphasis>), которая используется функциями <emphasis>readdir</emphasis> и <emphasis>closedir</emphasis>. Эта информация сосредоточена в заголовочном файле <emphasis>dirent.h</emphasis>.</p>
    <p><code>#define NAME_MAX 14 /* максимальная длина имени файла */ </code></p>
    <p><code> /* системно-зависимая величина */ </code></p>
    <empty-line/>
    <p><code>typedef struct { /* универс. структура элемента каталога: */</code></p>
    <p><code> long ino; /* номер inode */</code></p>
    <p><code> char name[NAME_MAX+1]; /* имя + завершающий '\0' */</code></p>
    <p><code>} Dirent;</code></p>
    <empty-line/>
    <p><code>typedef struct { /* минимальный DIR: без буферизации и т.д. */</code></p>
    <p><code> int fd; /* файловый дескриптор каталога */</code></p>
    <p><code> Dirent d; /* элемент каталога */</code></p>
    <p><code>} DIR; </code></p>
    <empty-line/>
    <p><code>DIR *opendir(char *dirname); </code></p>
    <p><code>Dirent *readdir(DIR *dfd); </code></p>
    <p><code>void closedir(DIR *dfd);</code></p>
    <p>Системный вызов <emphasis>stat</emphasis> получает имя файла и возвращает полную о нем информацию, содержащуюся в узле <emphasis>inode</emphasis>, или -1 в случае ошибки. Так,</p>
    <p><code>char *name; </code></p>
    <p><code>struct stat stbuf; </code></p>
    <p><code>int stat(char *, struct stat *); </code></p>
    <empty-line/>
    <p><code>stat(name, &amp;stbuf);</code></p>
    <p>заполняет структуру <emphasis>stbuf</emphasis> информацией из узла <emphasis>inode</emphasis> о файле с именем <emphasis>name</emphasis>. Структура, описывающая возвращаемое функцией <emphasis>stat</emphasis> значение находится в ‹sys/stat.h› и выглядит примерно так:</p>
    <p><code>struct stat /* информация из inode, возвращаемая stat */ </code></p>
    <p><code>{</code></p>
    <p><code> dev_t st_dev; /* устройство */</code></p>
    <p><code> ino_t st_ino; /* номер inode */</code></p>
    <p><code> short st_mode; /* режимные биты */</code></p>
    <p><code> short st_nlink; /* число связей с файлом */</code></p>
    <p><code> short st_uid; /* имя пользователя-собственника */</code></p>
    <p><code> short st_gid; /* имя группы собственника */</code></p>
    <p><code> dev_t st_rdev; /* для специальных файлов */</code></p>
    <p><code> off_t st_size; /* размер файла в символах */</code></p>
    <p><code> time_t st_atime; /* время последнего использования */</code></p>
    <p><code> time_t st_mtime; /* время последней модификации */</code></p>
    <p><code> time_t st_ctime; /* время последнего изменения inode */</code></p>
    <p><code>};</code></p>
    <p>Большинство этих значений объясняется в комментариях. Типы, подобные <emphasis>dev_t</emphasis> и <emphasis>ino_t</emphasis>, определены в файле ‹sys/types.h›, который тоже нужно включить посредством <emphasis>#include</emphasis>.</p>
    <p>Элемент <emphasis>st_mode</emphasis> содержит набор флажков, составляющих дополнительную информацию о файле. Определения флажков также содержатся в ‹sys/stat.h› нам потребуется только та его часть, которая имеет дело с типом файла</p>
    <p><code>#define S_IFMT  0160000 /* тип файла */</code></p>
    <p><code>#define S_IFDIR 0040000 /* каталог */ </code></p>
    <p><code>#define S_IFCHR 0020000 /* символьно-ориентированный */</code></p>
    <p><code>#define S_IFBLK 0060000 /* блочно-ориентированный */</code></p>
    <p><code>#define S_IFREG 0100000 /* обычный */</code></p>
    <p>Теперь мы готовы приступить к написанию программы <emphasis>fsize</emphasis>. Если режимные биты (<emphasis>st_mode</emphasis>), полученные от <emphasis>stat</emphasis>, указывают, что файл не является каталогом, то можно взять его размер (<emphasis>st_size</emphasis>) и напечатать. Однако если файл - каталог, то мы должны обработать все его файлы, каждый из которых в свою очередь может быть каталогом. Обработка каталога - процесс рекурсивный.</p>
    <p>Программа <emphasis>main</emphasis> просматривает параметры командной строки, передавая каждый аргумент функции <emphasis>fsize</emphasis>.</p>
    <p><code>#include ‹stdio.h› </code></p>
    <p><code>#include ‹string.h› </code></p>
    <p><code>#include "syscalls.h" </code></p>
    <p><code>#include ‹fcntl.h› /* флажки чтения и записи */ </code></p>
    <p><code>#include ‹sys/types.h› /* определения типов */ </code></p>
    <p><code>#include ‹sys/stat.h› /* структура, возвращаемая stat */ </code></p>
    <p><code>#include "dirent.h" </code></p>
    <empty-line/>
    <p><code>void fsize(char *); </code></p>
    <empty-line/>
    <p><code>/* печатает размер файлов */ </code></p>
    <p><code>main(int argc, char **argv) {</code></p>
    <p><code> if (argc == 1) /* по умолчанию берется текущий каталог */</code></p>
    <p><code>  fsize(".");</code></p>
    <p><code> else</code></p>
    <p><code>  while (--argc › 0)</code></p>
    <p><code>   fsize(*++argv);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>fsize</emphasis> печатает размер файла. Однако, если файл - каталог, она сначала вызывает <emphasis>dirwalk</emphasis>, чтобы обработать все его файлы. Обратите внимание на то, как используются имена флажков <emphasis>S_IFMT</emphasis> и <emphasis>S_IFDIR</emphasis> из ‹sys/stat.h› при проверке, является ли файл каталогом. Здесь нужны скобки, поскольку приоритет оператора &amp; ниже приоритета оператора ==.</p>
    <p><code>int stat(char *, struct stat *); </code></p>
    <p><code>void dirwalk(char *, void (*fcn)(char *)); </code></p>
    <empty-line/>
    <p><code>/* fsize: печатает размер файла "name" */ </code></p>
    <p><code>void fsize(char *name) </code></p>
    <p><code>{</code></p>
    <p><code> struct stat stbuf;</code></p>
    <empty-line/>
    <p><code> if (stat(name, &amp;stbuf) == -1) {</code></p>
    <p><code>  fprintf(stderr, "fsize: нет доступа к %s\n", name);</code></p>
    <p><code>  return;</code></p>
    <p><code> }</code></p>
    <p><code> if ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)</code></p>
    <p><code>  dirwalk(name, fsize);</code></p>
    <p><code> printf("%8ld%s\n", stbuf.st_size, name);</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>dirwalk</emphasis> - это универсальная программа, применяющая некоторую функцию к каждому файлу каталога. Она открывает каталог, с помощью цикла перебирает содержащиеся в нем файлы, применяя к каждому из них указанную функцию, затем закрывает каталог и осуществляет возврат. Так как <emphasis>fsize</emphasis> вызывает <emphasis>dirwalk</emphasis> на каждом каталоге, в этих двух функциях заложена косвенная рекурсия.</p>
    <p><code>#define MAX_PATH 1024 </code></p>
    <empty-line/>
    <p><code>/* dirwalk: применяет fcn ко всем файлам из dir */ </code></p>
    <p><code>void dirwalk(char *dir, void (*fcn)(char *)) </code></p>
    <p><code>{</code></p>
    <p><code> char name[MAX_PATH];</code></p>
    <p><code> Dirent *dp;</code></p>
    <p><code> DIR *dfd;</code></p>
    <empty-line/>
    <p><code> if ((dfd = opendir(dir)) == NULL) {</code></p>
    <p><code>  fprintf(stderr, "dirwalk: не могу открыть %s\n", dir);</code></p>
    <p><code>  return;</code></p>
    <p><code> }</code></p>
    <p><code> while ((dp = readdir(dfd)) != NULL) {</code></p>
    <p><code>  if (strcmp(dp-›name, ".") == 0 || strcmp(dp-›name, "…") == 0)</code></p>
    <p><code>   continue; /* пропустить себя и родителя */</code></p>
    <p><code>  if (strlen(dir)+strlen(dp-›name) + 2 › sizeof(name))</code></p>
    <p><code>   fprintf(stderr, "dirwalk: слишком длинное имя %s/%s\n", dir, dp-›name);</code></p>
    <p><code>  else {</code></p>
    <p><code>   sprintf(name, "%s/%s", dir, dp-›name);</code></p>
    <p><code>   (*fcn) (name);</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> closedir(dfd);</code></p>
    <p><code>}</code></p>
    <p>Каждый вызов <emphasis>readdir</emphasis> возвращает указатель на информацию о следующем файле или NULL, если все файлы обработаны. Любой каталог всегда хранит в себе информацию о себе самом в файле под именем "." и о своем родителе в файле под именем "…": их нужно пропустить, иначе программа зациклится. Обратите внимание: код программы этого уровня не зависит от того, как форматированы каталоги. Следующий шаг - представить минимальные версии <emphasis>opendir</emphasis>, <emphasis>readdir</emphasis> и <emphasis>closedir</emphasis> для некоторой конкретной системы. Здесь приведены программы для систем Version 7 и System V UNIX. Они используют информацию о каталоге, хранящуюся в заголовочном файле ‹sys/dir.h›, который выглядит следующим образом:</p>
    <p><code>#ifndef DIRSIZ </code></p>
    <p><code>#define DIRSIZ 14 </code></p>
    <p><code>#endif </code></p>
    <p><code>struct direct /* элемент каталога */ </code></p>
    <p><code>{</code></p>
    <p><code> ino_t d_ino; /* номер inode */</code></p>
    <p><code> char d_name[DIRSIZ]; /* длинное имя не имеет '\0' */</code></p>
    <p><code>};</code></p>
    <p>Некоторые версии системы допускают более длинные имена и имеют более сложную структуру каталога.</p>
    <p>Тип <strong>ino_t</strong> задан с помощью <emphasis>typedef</emphasis> и описывает индекс списка узлов <emphasis>node</emphasis>. В системе, которой пользуемся мы, этот тип есть <emphasis>unsigned short</emphasis>, но в других системах он может быть иным, поэтому его лучше определять через <emphasis>typedef</emphasis>. Полный набор "системных" типов находится в ‹sys/types.h›.</p>
    <p>Функция <emphasis>opendir</emphasis> открывает каталог, проверяет, является ли он действительно каталогом (в данном случае это делается с помощью системного вызова <emphasis>fstat</emphasis>, который аналогичен <emphasis>stat</emphasis>, но применяется к дескриптору файла), запрашивает пространство для структуры каталога и записывает информацию.</p>
    <p><code>int fstat(int fd, struct stat *); </code></p>
    <empty-line/>
    <p><code>/* opendir: открывает каталог для вызовов readdir */ </code></p>
    <p><code>DIR *opendir(char *dirname) </code></p>
    <p><code>{</code></p>
    <p><code> int fd;</code></p>
    <p><code> struct stat stbuf;</code></p>
    <p><code> DIR *dp;</code></p>
    <empty-line/>
    <p><code> if ((fd = open(dirname, O_RDONLY, 0)) == -1 || fstat(fd, &amp;stbuf) == -1 || (stbuf.st_mode &amp; S_IFMT) != S_IFDIR || (dp = (DIR *) malloc(sizeof(DIR))) == NULL)</code></p>
    <p><code>  return NULL;</code></p>
    <p><code> dp-›fd = fd;</code></p>
    <p><code> return dp;</code></p>
    <p><code>}</code></p>
    <p>Функция closedir закрывает каталог и освобождает пространство.</p>
    <p><code>/* closedir: закрывает каталог, открытый opendir */ </code></p>
    <p><code>void closedir(DIR *dp) {</code></p>
    <p><code> if (dp) {</code></p>
    <p><code>  close(dp-›fd);</code></p>
    <p><code>  free(dp);</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>Наконец, <emphasis>readdir</emphasis> с помощью <emphasis>read</emphasis> читает каждый элемент каталога. Если некий элемент каталога в данный момент не используется (соответствующий ему файл был удален), то номер узла <emphasis>inode</emphasis> у него равен нулю, и данная позиция пропускается. В противном случае номер <emphasis>inode</emphasis> и имя размещаются в статической (<emphasis>static</emphasis>) структуре, и указатель на нее выдается в качестве результата. При каждом следующем обращении новая информация занимает место предыдущей.</p>
    <p><code>#include ‹sys/dir.h› /* место расположения структуры каталога */ </code></p>
    <empty-line/>
    <p><code>/* readdir: последовательно читает элементы каталога */ </code></p>
    <p><code>Dirent *readdir(DIR *dp) {</code></p>
    <p><code> struct direct dirbuf; /* структура каталога на данной системе */</code></p>
    <p><code> static Dirent d; /* возвращает унифицированную структуру */</code></p>
    <empty-line/>
    <p><code> while (read(dp-›fd, (char *)&amp;dirbuf, sizeof (dirbuf)) == sizeof(dirbuf)) {</code></p>
    <p><code>  if (dirbuf.d_ino == 0) /* пустой элемент, не используется */</code></p>
    <p><code>   continue;</code></p>
    <p><code>  d.ino = dirbuf.d_ino;</code></p>
    <p><code>  strncpy(d.name, dirbuf.d_name, DIRSIZ);</code></p>
    <p><code>  d.name[DIRSIZ] = '\0'; /* завершающий символ '\0' */</code></p>
    <p><code>  return &amp;d;</code></p>
    <p><code> }</code></p>
    <p><code> return NULL;</code></p>
    <p><code>}</code></p>
    <p>Хотя программа <emphasis>fsize</emphasis> - довольно специализированная, она иллюстрирует два важных факта. Первый: многие программы не являются "системными"; они просто используют информацию, которую хранит операционная система. Для таких программ существенно то, что представление информации сосредоточено исключительно в стандартных заголовочных файлах. Программы включают эти файлы, а не держат объявления в себе. Второе наблюдение заключается в том, что при старании системно-зависимым объектам можно создать интерфейсы, которые сами не будут системно-зависимыми. Хорошие тому примеры ~ функции стандартной библиотеки.</p>
    <p><strong>Упражнение 8.5</strong>. Модифицируйте <emphasis>fsize</emphasis> таким образом, чтобы можно было печатать остальную информацию, содержащуюся в узле <emphasis>inode</emphasis>.</p>
   </section>
   <section>
    <title>
     <p>8.7 Пример. Распределитель памяти</p>
    </title>
    <p>В главе 5 был описан простой распределитель памяти, основанный на принципе стека. Версия, которую мы напишем здесь, не имеет ограничений: вызовы <strong>malloc</strong> и <strong>free</strong> могут выполняться в любом порядке: <emphasis>malloc</emphasis> делает запрос в операционную систему на выделение памяти тогда, когда она требуется. Эти программы иллюстрируют приемы, позволяющие получать машинно-зависимый код сравнительно машинно-независимым способом, и, кроме того, они могут служить примером применения таких средств языка, как структуры, объединения и typedef.</p>
    <p>Никакого ранее скомпилированного массива фиксированного размера, из которого выделяются куски памяти, не будет. Функция <emphasis>malloc</emphasis> запрашивает память у операционной системы по мере надобности. Поскольку и другие действия программы могут вызывать запросы памяти, которые удовлетворяются независимо от этого распределителя памяти, пространство, которым заведует <emphasis>malloc</emphasis>, необязательно представляет собой связный кусок памяти. Поэтому свободная память хранится в виде списка блоков. Каждый блок содержит размер, указатель на следующий блок и само пространство. Блоки в списке хранятся в порядке возрастания адресов памяти, при этом последний блок (с самым большим адресом) указывает на первый.</p>
    <empty-line/>
    <image l:href="#fig8_1.png"/>
    <p>При возникновении запроса на память просматривается список свободных блоков, пока не обнаружится достаточно большой блок. Такой алгоритм называется "поиском первого подходящего" в отличие от алгоритма "поиска наилучшего подходящего", который ищет наименьший блок из числа удовлетворяющих запросу. Если размер блока в точности соответствует требованиям, то такой блок исключается из списка и отдается в пользование. Если размер блока больше, чем требуется, от него отрезается нужная часть - она отдается пользователю, а ненужная оставляется в списке свободных блоков. Если блока достаточного размера не оказалось, то у операционной системы запрашивается еще один большой кусок памяти, который присоединяется к списку свободных блоков.</p>
    <p>Процедура освобождения сопряжена с прохождением по списку свободных блоков, поскольку нужно найти подходящее место для освобождаемого блока. Если подлежащий освобождению блок примыкает с какой-то стороны к одному из свободных блоков, то он объединяется с ним в один блок большего размера, чтобы по возможности уменьшить раздробленность (фрагментацию) памяти. Выполнение проверки, примыкают ли блоки друг к другу, не составляет труда, поскольку список свободных блоков всегда упорядочен по возрастанию адресов.</p>
    <p>Существует проблема, о которой мы уже упоминали в главе 5, состоящая в том, что память, выдаваемая функцией <emphasis>malloc</emphasis>, должна быть соответствующим образом выровнена с учетом объектов, которые будут в ней храниться. Хотя машины и отличаются друг от друга, но для каждой из них существует тип, предъявляющий самые большие требования на выравнивание, и, если по некоему адресу допускается размещение объекта этого типа, то по нему можно разместить и объекты всех других типов. На некоторых машинах таким самым "требовательным" типом является <emphasis>double</emphasis>, на других это может быть <emphasis>int</emphasis> или <emphasis>long</emphasis>.</p>
    <p>Свободный блок содержит указатель на следующий блок в списке, свой размер и собственно свободное пространство. Указатель и размер представляют собой управляющую информацию и образуют так называемый "заголовок". Чтобы упростить выравнивание, все блоки создаются кратными размеру заголовка, а заголовок соответствующим образом выравнивается. Этого можно достичь, сконструировав объединение, которое будет содержать соответствующую заголовку структуру и самый требовательный в отношении выравнивания тип. Для конкретности мы выбрали тип <emphasis>long</emphasis>.</p>
    <p><code>typedef long Align; /* для выравнивания по границе long */ </code></p>
    <p><code>union header { /* заголовок блока: */</code></p>
    <p><code> struct {</code></p>
    <p><code>  union header *ptr; /* след. блок в списке свободных */</code></p>
    <p><code>  unsigned size; /* размер этого блока */</code></p>
    <p><code> } s;</code></p>
    <p><code> Align x; /* принудительное выравнивание блока */</code></p>
    <p><code>}; </code></p>
    <p><code>typedef union header Header;</code></p>
    <p>Поле <emphasis>Align</emphasis> нигде не используется: оно необходимо только для того, чтобы каждый заголовок был выровнен по самому "худшему" варианту границы.</p>
    <p>Затребованное число символов округляется в <emphasis>malloc</emphasis> до целого числа единиц памяти размером в заголовок (именно это число и записывается в поле <emphasis>size</emphasis> (размер) в заголовке); кроме того, в блок входит еще одна единица памяти - сам заголовок. Указатель, возвращаемый функцией <emphasis>malloc</emphasis>, указывает на свободное пространство, а не на заголовок. Со свободным пространством пользователь может делать что угодно, но, если он будет писать что-либо за его пределами, то, вероятно, список разрушится.</p>
    <image l:href="#fig8_2.png"/>
    <p>Поскольку память, управляемая функцией <emphasis>malloc</emphasis>, не обладает связностью, размеры блоков нельзя вычислить по указателям, и поэтому без поля, хранящего размер, нам не обойтись.</p>
    <p>Для организации начала работы используется переменная <emphasis>base</emphasis>. Если <emphasis>freep</emphasis> есть NULL (как это бывает при первом обращении к <emphasis>malloc</emphasis>), создается "вырожденный" список свободного пространства; он содержит один блок нулевого размера с указателем на самого себя. Поиск свободного блока подходящего размера начинается с этого указателя (<emphasis>freep</emphasis>), т. е. с последнего найденного блока; такая стратегия помогает поддерживать список однородным. Если найденный блок окажется слишком большим, пользователю будет отдана его хвостовая часть; при этом потребуется только уточнить его размер в заголовке найденного свободного блока. В любом случае возвращаемый пользователю указатель является адресом свободного пространства, размещающегося в блоке непосредственно за заголовком.</p>
    <p><code>static Header base; /* пустой список для нач. запуска */ </code></p>
    <p><code>static Header *freep = NULL; /* начало в списке своб. блоков */ </code></p>
    <empty-line/>
    <p><code>/* malloc: универсальный распределитель памяти */ </code></p>
    <p><code>void *malloc(unsigned nbytes) {</code></p>
    <p><code> Header *p, *prevp;</code></p>
    <p><code> Header *morecore(unsigned);</code></p>
    <p><code> unsigned nunits;</code></p>
    <empty-line/>
    <p><code> nunits = (nbytes + sizeof(Header) - 1) / sizeof (Header) + 1;</code></p>
    <p><code> if ((prevp = freep) == NULL) { /* списка своб. памяти еще нет */</code></p>
    <p><code>  base.s.ptr = freep = prevp = &amp;base;</code></p>
    <p><code>  base.s.size = 0;</code></p>
    <p><code> }</code></p>
    <p><code> for (p = prevp-›s.ptr; ; prevp = p, p = p-›s.ptr) {</code></p>
    <p><code>  if (p-›s.size ›= nunits) { /* достаточно большой */</code></p>
    <p><code>   if (p-›s.size == nunits) /* точно нужного размера */</code></p>
    <p><code>    prevp-›s.ptr = p-›s.ptr;</code></p>
    <p><code>   else { /* отрезаем хвостовую часть */</code></p>
    <p><code>    p-›s.size -= nunits;</code></p>
    <p><code>    p += p-›s.size;</code></p>
    <p><code>    p-›s.size = nunits;</code></p>
    <p><code>   }</code></p>
    <p><code>   freep = prevp;</code></p>
    <p><code>   return (void *)(p+1);</code></p>
    <p><code>  }</code></p>
    <p><code>  if (p == freep) /* прошли полный цикл по списку */</code></p>
    <p><code>   if ((p = morecore(nunits)) == NULL) return NULL; /* больше памяти нет */</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <p>Функция <emphasis>morecore</emphasis> получает память от операционной системы. Детали того, как это делается, могут не совпадать в различных системах. Так как запрос памяти у системы - сравнительно дорогая операция, мы бы не хотели для этого каждый раз обращаться к <emphasis>malloc</emphasis>. Поэтому используется функция <emphasis>morecore</emphasis>, которая запрашивает не менее NALLOC единиц памяти; этот больший кусок памяти будет "нарезаться" потом по мере надобности. После установки в поле размера соответствующего значения функция <emphasis>morecore</emphasis> вызывает функцию <emphasis>free</emphasis> и тем самым включает полученный кусок в список свободных областей памяти.</p>
    <p><code>#define NALLOC 1024 /* миним. число единиц памяти для запроса */</code></p>
    <empty-line/>
    <p><code>/* morecore: запрашивает у системы дополнительную память */ </code></p>
    <p><code>static Header * morecore(unsigned nu)</code></p>
    <p><code>{</code></p>
    <p><code> char *cp, *sbrk(int);</code></p>
    <p><code> Header *up;</code></p>
    <empty-line/>
    <p><code> if (nu &lt; NALLOC)</code></p>
    <p><code>  nu = NALLOC;</code></p>
    <p><code> cp = sbrk(nu * sizeof(Header));</code></p>
    <p><code> if (cp == (char *) -1) /* больше памяти нет. */</code></p>
    <p><code>  return NULL;</code></p>
    <p><code> up = (Header *) cp;</code></p>
    <p><code> up-&gt;s.size = nu;</code></p>
    <p><code> free((void *)(up+1));</code></p>
    <p><code> return freep;</code></p>
    <p><code>}</code></p>
    <p>Системный вызов <strong>sbrk</strong>(n) в UNIXе возвращает указатель на <emphasis>n</emphasis> байт памяти или -1, если требуемого пространства не оказалось, хотя было бы лучше, если бы в последнем случае он возвращал NULL. Константу -1 необходимо привести к типу char *, чтобы ее можно было сравнить с возвращаемым значением. Это еще один пример того, как операция приведения типа делает функцию относительно независимой от конкретного представления указателей на различных машинах. Есть, однако, одна "некорректность", состоящая а том, что сравниваются указатели на различные блоки, выдаваемые функцией <emphasis>sbrk</emphasis>. Такое сравнение не гарантировано стандартом, который позволяет сравнивать указатели лишь в пределах одного и того же массива. Таким образом, эта версия <emphasis>malloc</emphasis> верна только на тех машинах, в которых допускается сравнение любых указателей.</p>
    <p>В заключение рассмотрим функцию <emphasis>free</emphasis>. Она просматривает список свободной памяти, начиная с <emphasis>freep</emphasis>, чтобы подыскать место для вставляемого блока. Искомое место может оказаться или между блоками, или в начале списка, или в его конце. В любом случае, если подлежащий освобождению блок примыкает к соседнему блоку, он объединяется с ним в один блок. О чем еще осталось позаботиться, - так это о том, чтобы указатели указывали в нужные места и размеры блоков были правильными.</p>
    <p><code>/* free: включает блок в список свободной памяти */ </code></p>
    <p><code>void free(void *ар) {</code></p>
    <p><code> Header *bp, *p;</code></p>
    <empty-line/>
    <p><code> bp = (Header *)ap -1; /* указатель на заголовок блока */ </code></p>
    <p><code> for (p = freep; !(bp › p &amp;&amp; bp s.ptr); p = p-›s.ptr)</code></p>
    <p><code>  if (p ›= p-›s.ptr &amp;&amp; (bp › p || bp s.ptr)) break; /* освобождаем блок в начале или в конце */ </code></p>
    <p><code> if (bp + bp-›s.size - p-›s.ptr) { /* слить с верхним */</code></p>
    <p><code>  bp-›s.size += p-›s.ptr-›s.size; /* соседом */</code></p>
    <p><code>  bp-›s.ptr = p-›s.ptr-›s.ptr;</code></p>
    <p><code> } else bp-›s.ptr = p-›s.ptr;</code></p>
    <p><code> if (p + p-›s.size == bp) { /* слить с нижним соседом */</code></p>
    <p><code>  p-›s.size += bp-›s.size;</code></p>
    <p><code>  p-›s.ptr = bp-›s.ptr;</code></p>
    <p><code> } else p-›s.ptr = bp;</code></p>
    <p><code> freep = p;</code></p>
    <p><code>}</code></p>
    <p>Хотя выделение памяти по своей сути - машинно-зависимая проблема, с ней можно справиться, что и иллюстрирует приведенная программа, в которой машинная зависимость упрятана в очень маленькой ее части. Что касается проблемы выравнивания, то мы разрешили ее с помощью <emphasis>typedef</emphasis> и <emphasis>union</emphasis> (предполагается, что <emphasis>sbrk</emphasis> дает подходящий в смысле выравнивания указатель). Операции приведения типов позволяют нам сделать явными преобразования типов и даже справиться с плохо спроектированным интерфейсом системы. Несмотря на то, что наши рассуждения касались распределения памяти, этот общий подход применим и в других ситуациях.</p>
    <p><strong>Упражнение 8.6</strong>. Стандартная функция <emphasis>calloc(n, size)</emphasis> возвращает указатель на <emphasis>n</emphasis> элементов памяти размера <emphasis>size</emphasis>, заполненных нулями. Напишите свой вариант <emphasis>calloc</emphasis>, пользуясь функцией <emphasis>malloc</emphasis> или модифицируя последнюю.</p>
    <p><strong>Упражнение 8.7</strong>. Функция <emphasis>malloc</emphasis> допускает любой размер, никак не проверяя его на правдоподобие: <emphasis>free</emphasis> предполагает, что размер освобождаемого блока - правильный. Усовершенствуйте эти программы таким образом, чтобы они более тщательно контролировали ошибки.</p>
    <p><strong>Упражнение 8.8</strong>. Напишите программу <emphasis>bfree(p, n)</emphasis>, освобождающую произвольный блок <emphasis>p</emphasis>, состоящий из <emphasis>n</emphasis> символов, путем включения его в список свободной памяти, поддерживаемый функциями <emphasis>malloc</emphasis> и <emphasis>free</emphasis>. C помощью <emphasis>bfree</emphasis> пользователь должен иметь возможность в любое время добавить в список свободной памяти статический или внешний массив.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Приложение A. Справочное руководство</p>
   </title>
   <section>
    <title>
     <p>A1. Введение</p>
    </title>
    <p>Данное руководство описывает язык программирования Си, определенный 31 октября 1989 г. в соответствии с проектом, утвержденным в ANSI в качестве Американского национального стандарта для информационных систем: Язык программирования Си, X3.159-1989 (<strong>"American National Standard for Information Systems - Programming Language C, X3.159-1989"</strong>). Это описание - лишь один из вариантов предлагаемого стандарта, а не сам стандарт, однако мы специально заботились о том, чтобы сделать его надежным руководством по языку.</p>
    <p>Настоящий документ в основном следует общей схеме описания, принятой в стандарте (публикация которого в свою очередь основывалась на первом издании этой книги), однако в организационном плане есть различия. Если не считать отклонений в названиях нескольких продуктов и отсутствия формальных определений лексем и препроцессора, грамматика языка здесь и грамматика в стандарте эквивалентны.</p>
    <cite>
     <p>Далее примечания (как и это) набираются с отступом от левого края страницы. В основном эти примечания касаются отличий стандарта от версии языка, описанной в первом издании этой книги, и от последующих нововведений в различных компиляторах.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>A2. Соглашения о лексике</p>
    </title>
    <section>
     <p>Программа состоит из одной или нескольких <emphasis>единиц трансляции</emphasis>, хранящихся в виде файлов. Каждая такая единица проходит несколько фаз трансляции, описанных в A12. Начальные фазы осуществляют лексические преобразования нижнего уровня, выполняют директивы, заданные в программе строками, начинающимися со знака #, обрабатывают макроопределения и производят макрорасширения. По завершении работы препроцессора (A12) программа представляется к виде последовательности лексем. </p>
    </section>
    <section>
     <title>
      <p>A2.1. Лексемы (tokens) </p>
     </title>
     <p>Существуют шесть классов лексем (или токенов): идентификаторы, ключевые слона, константы, строковые литералы, операторы и прочие разделители. Пробелы, горизонтальные и вертикальные табуляции, новые строки, переводы страницы и комментарии (имеющие общее название символы-разделители) рассматриваются компилятором только как разделители лексем и в остальном на результат трансляции влияние не оказывают. Любой из символов-разделителей годится, чтобы отделить друг от друга соседние идентификаторы, ключевые слова и константы.</p>
     <p>Если входной поток уже до некоторого символа разбит на лексемы, то следующей лексемой будет самая длинная строка, которая может быть лексемой.</p>
    </section>
    <section>
     <title>
      <p>A2.2. Комментарий</p>
     </title>
     <p>Символы <strong>/*</strong> открывают комментарий, а символы <strong>*/</strong> закрывают его. Комментарии нельзя вкладывать друг в друга, их нельзя помещать внутрь строк или текстовых литералов.</p>
    </section>
    <section>
     <title>
      <p>A2.3. Идентификаторы</p>
     </title>
     <p><emphasis>Идентификатор</emphasis> - это последовательность букв и цифр. Первым символом должна быть буква; знак подчеркивания _ считается буквой. Буквы нижнего и верхнего регистров различаются. Идентификаторы могут иметь любую длину; для внутренних идентификаторов значимыми являются первые 31 символ; в некоторых реализациях принято большее число значимых символов. К внутренним идентификаторам относятся имена макросов и все другие имена, не имеющие внешних связей (<a l:href="#a11_2" type="note">A11.2</a>). На идентификаторы с внешними связями могут накладываться большие ограничения: иногда воспринимаются не более шести первых символов и могут не различаться буквы верхнего и нижнего регистров.</p>
    </section>
    <section>
     <title>
      <p>A2.4. Ключевые слова</p>
     </title>
     <p>Следующие идентификаторы зарезервированы в качестве ключевых слов и в другом смысле использоваться не могут:</p>
     <p><strong><code><strong>auto</strong></code></strong></p>
     <p><strong><code><strong>break</strong></code></strong></p>
     <p><strong><code><strong>char</strong></code></strong></p>
     <p><strong><code><strong>case</strong></code></strong></p>
     <p><strong><code><strong>char</strong></code></strong></p>
     <p><strong><code><strong>const</strong></code></strong></p>
     <p><strong><code><strong>continue</strong></code></strong></p>
     <p><strong><code><strong>default</strong></code></strong></p>
     <p><strong><code><strong>do</strong></code></strong></p>
     <p><strong><code><strong>double</strong></code></strong></p>
     <p><strong><code><strong>else</strong></code></strong></p>
     <p><strong><code><strong>enum</strong></code></strong></p>
     <p><strong><code><strong>extern</strong></code></strong></p>
     <p><strong><code><strong>float</strong></code></strong></p>
     <p><strong><code><strong>for</strong></code></strong></p>
     <p><strong><code><strong>goto</strong></code></strong></p>
     <p><strong><code><strong>if</strong></code></strong></p>
     <p><strong><code><strong>int</strong></code></strong></p>
     <p><strong><code><strong>long</strong></code></strong></p>
     <p><strong><code><strong>register</strong></code></strong></p>
     <p><strong><code><strong>return</strong></code></strong></p>
     <p><strong><code><strong>short</strong></code></strong></p>
     <p><strong><code><strong>signed</strong></code></strong></p>
     <p><strong><code><strong>sizeof</strong></code></strong></p>
     <p><strong><code><strong>static</strong></code></strong></p>
     <p><strong><code><strong>struct</strong></code></strong></p>
     <p><strong><code><strong>switch</strong></code></strong></p>
     <p><strong><code><strong>typedef</strong></code></strong></p>
     <p><strong><code><strong>union</strong></code></strong></p>
     <p><strong><code><strong>unsigned</strong></code></strong></p>
     <p><strong><code><strong>void</strong></code></strong></p>
     <p><strong><code><strong>volatile</strong></code></strong></p>
     <p><strong><code><strong>while</strong></code></strong></p>
     <p>В некоторых реализациях резервируются также слова <strong>fortran</strong> и <strong>asm</strong>.</p>
     <cite>
      <p>Ключевые слова const, signed и volatile впервые появились в стандарте ANSI; enum и void - новые по отношению к первому изданию книги, но уже использовались; ранее зарезервированное entry нигде не использовалось и поэтому более не резервируется.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>A2.5. Константы </p>
     </title>
     <section>
      <p>Существует несколько видов констант. Каждая имеет свой тип данных; базовые типы рассматриваются в A4.2.</p>
      <p><emphasis><code><emphasis>константа:</emphasis></code></emphasis></p>
      <p><emphasis><code><emphasis>    целая-константа</emphasis></code></emphasis></p>
      <p><emphasis><code><emphasis>    символьная-константа</emphasis></code></emphasis></p>
      <p><emphasis><code><emphasis>    константа-с-плавающей-точкой</emphasis></code></emphasis></p>
      <p><emphasis><code><emphasis>    константа-перечисление</emphasis></code></emphasis></p>
     </section>
     <section>
      <title>
       <p>A2.5.1. Целые константы</p>
      </title>
      <p>Целая константа, состоящая из последовательности цифр, воспринимается как восьмеричная, если она начинается с 0 (цифры нуль), и как десятичная в противном случае. Восьмеричная константа не содержит цифр 8 и 9. Последовательность цифр, перед которой стоят 0x или 0X, рассматривается как шестнадцатеричное целое. В шестнадцатеричные цифры включены буквы от a (или A) до f (или F) co значениями от 10 до 15.</p>
      <p>Целая константа может быть записана с буквой-суффиксом <emphasis>u</emphasis> (или <emphasis>U</emphasis>) для спецификации ее как беззнаковой константы. Она также может быть с буквой- суффиксом <emphasis>l</emphasis> (или <emphasis>L</emphasis>) для указания, что она имеет тип <emphasis>long</emphasis>.</p>
      <p>Тип целой константы зависит от ее вида, значения и суффикса (о типах см. A4). Если константа - десятичная и не имеет суффикса, то она принимает первый из следующих типов, который годится для представления ее значения: <emphasis>int</emphasis>, <emphasis>long int</emphasis>, <emphasis>unsigned long int</emphasis>. Восьмеричная или шестнадцатеричная константа без суффикса принимает первый возможный из типов: <emphasis>int</emphasis>, <emphasis>unsigned int</emphasis>, <emphasis>long int</emphasis>, <emphasis>unsigned long int</emphasis>. Если константа имеет суффикс <emphasis>u</emphasis> или <emphasis>U</emphasis>, то она принимает первый возможный из типов: <emphasis>unsigned int</emphasis>, <emphasis>unsigned long int</emphasis>. Если константа имеет суффикс <emphasis>l</emphasis> или <emphasis>L</emphasis>, то она принимает первый возможный из типов: <emphasis>long int</emphasis>, <emphasis>unsigned long int</emphasis>. Если константа имеет суффикс <emphasis>ul</emphasis> или <emphasis>UL</emphasis>, то она принимает тип <emphasis>unsigned long int</emphasis>.</p>
      <p>Типы целых констант получили существенное развитие в сравнении с первой редакцией языка, в которой большие целые имели просто тип long. Суффиксы U и u введены впервые.</p>
     </section>
     <section>
      <title>
       <p>A2.5.2. Символьные константы</p>
      </title>
      <p>Символьная константа - это последовательность из одной или нескольких символов, заключенная в одиночные кавычки (например <emphasis>'x'</emphasis>). Если внутри одиночных кавычек расположен один символ, значением константы является числовое значение этого символа в кодировке, принятой на данной машине. Значение константы с несколькими символами зависит от реализации.</p>
      <p>Символьная константа не может содержать в себе одиночную кавычку ' или символ новой строки; чтобы изобразить их и некоторые другие символы, могут быть использованы <emphasis>эскейп-последовательности</emphasis>:</p>
      <table>
       <tr align="left">
        <td align="left" valign="top">новая строка (newline, linefeed) </td>
        <td align="left" valign="top"><strong>NL (LF) </strong></td>
        <td align="left" valign="top"><strong>\n</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">горизонтальная табуляция (horizontal tab) </td>
        <td align="left" valign="top"><strong>HT </strong></td>
        <td align="left" valign="top"><strong>\t</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">вертикальная табуляция (vertical tab) </td>
        <td align="left" valign="top"><strong>VT </strong></td>
        <td align="left" valign="top"><strong>\v</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">возврат на шаг (backspace) </td>
        <td align="left" valign="top"><strong>BS </strong></td>
        <td align="left" valign="top"><strong>\b</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">возврат каретки (carriage return) </td>
        <td align="left" valign="top"><strong>CR </strong></td>
        <td align="left" valign="top"><strong>\r</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">перевод страницы (formfeed) </td>
        <td align="left" valign="top"><strong>FF </strong></td>
        <td align="left" valign="top"><strong>\f</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">сигнал звонок (audible alert, bell) </td>
        <td align="left" valign="top"><strong>BEL </strong></td>
        <td align="left" valign="top"><strong>\a</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">обратная наклонная черта (backslash) </td>
        <td align="left" valign="top"><strong>\ </strong></td>
        <td align="left" valign="top"><strong>\\</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">знак вопроса (question mark) </td>
        <td align="left" valign="top"><strong>? </strong></td>
        <td align="left" valign="top"><strong>\?</strong></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">одиночная кавычка (single quote) </td>
        <td align="left" valign="top"><strong>' </strong></td>
        <td align="left" valign="top"><strong>\'</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">двойная кавычка (double quote) </td>
        <td align="left" valign="top"><strong>" </strong></td>
        <td align="left" valign="top"><strong>\"</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">восьмеричный код (octal number) </td>
        <td align="left" valign="top"><strong>ooo </strong></td>
        <td align="left" valign="top"><strong>\ooo</strong> </td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">шестнадцатеричный код (hex number) </td>
        <td align="left" valign="top"><strong>hh </strong></td>
        <td align="left" valign="top"><strong>\xhh</strong> </td>
       </tr>
      </table>
      <p>Эскейп-последовательность <emphasis>\ooo</emphasis> состоит из обратной наклонной черты, за которой следуют одна, две или три восьмеричные цифры, специфицирующие значение желаемого символа. Наиболее частым примером такой конструкции является \0 (за которой не следует цифра); она специфицирует NULL-символ. Эскейп-последовательность <emphasis>\xhh</emphasis> состоит из обратной наклонной черты с буквой <emphasis>x</emphasis>, за которыми следуют шестнадцатеричные цифры, специфицирующие значение желаемого символа. На количество цифр нет ограничений, но результат будет не определен, если значение полученного символа превысит значение самого "большого" из допустимых символов. Если в данной реализации тип <emphasis>char</emphasis> трактуется как число со знаком, то значение и в восьмеричной, и в шестнадцатеричной эскейп-последовательности получается с помощью "распространения знака", как если бы выполнялась операция приведения к типу <emphasis>char</emphasis>. Если за \ не следует ни один из перечисленных выше символов, результат не определен.</p>
      <p>В некоторых реализациях имеется расширенный набор символов, который не может быть охвачен типом <emphasis>char</emphasis>. Константа для такого набора пишется с буквой <emphasis>L</emphasis> впереди (например L'x') и называется расширенной символьной константой. Такая константа имеет тип <emphasis>wchar_t</emphasis> (целочисленный тип, определенный в стандартном заголовочном файле <strong>‹stddef.h›</strong>). Как и в случае обычных символьных констант, здесь также возможны восьмеричные и шестнадцатеричные эскейп- последовательности; если специфицированное значение превысит тип <emphasis>wchar_t</emphasis>, результат будет не определен.</p>
      <cite>
       <p>Некоторые из приведенных эскейп-последовательностей новые (шестнадцатеричные в частности). Новым является и расширенный тип для символов. Наборам символов, обычно используемым в Америке и Западной Европе, подходит тип char, а тип wchar_t был добавлен главным образом для азиатских языков.</p>
      </cite>
     </section>
     <section>
      <title>
       <p>А2.5.3. Константы с плавающей точкой</p>
      </title>
      <p>Константа с плавающей точкой состоит из целой части, десятичной точки, дробной части, <strong>e</strong> или <strong>E</strong> и целого (возможно, со знаком), представляющего порядок, и, возможно, суффикса типа, задаваемого одной из букв: <strong>f</strong>, <strong>F</strong>, <strong>l</strong> или <strong>L</strong>. И целая, и дробная часть представляют собой последовательность цифр. Либо целая часть, либо дробная часть (но не обе вместе) могут отсутствовать; также могут отсутствовать десятичная точка или <emphasis>E</emphasis> с порядком (но не обе одновременно). Тип определяется суффиксом: <emphasis>F</emphasis> или <emphasis>f</emphasis> определяют тип <emphasis>float</emphasis>, <emphasis>L</emphasis> или <emphasis>l</emphasis> - тип <emphasis>long double</emphasis>; при отсутствии суффикса подразумевается тип <emphasis>double</emphasis>.</p>
      <cite>
       <p>Суффиксы для констант с плавающей точкой являются нововведением.</p>
      </cite>
     </section>
     <section>
      <title>
       <p>A2.5.4. Константы-перечисления </p>
      </title>
      <p>Идентификаторы, объявленные как элементы перечисления (A8.4), являются константами типа <emphasis>int</emphasis>.</p>
     </section>
    </section>
    <section>
     <title>
      <p>A2.6. Строковые литералы</p>
     </title>
     <p>Строковый литерал, который также называют строковой константой, - это последовательность символов, заключенная в двойные кавычки (Например, "…"). Строка имеет тип "массив символов" и память класса <strong>static</strong> (A4), которая инициализируется заданными символами. Представляются ли одинаковые строковые литералы одной копией или несколькими, зависит от реализации. Поведение программы, пытающейся изменить строковый литерал, не определено.</p>
     <p>Написанные рядам строковые литералы объединяются (конкатенируются) в одну строку. После любой конкатенации к строке добавляется NULL-байт (\0), что позволяет программе, просматривающей строку, найти ее конец. Строковые литералы не могут содержать в себе символ новой строки или двойную кавычку; в них нужно использовать те же эскейп-последовательности, что и в символьных константах.</p>
     <p>Как и в случае с символьными константами, строковый литерал с символами из расширенного набора должен начинаться с буквы <strong>L</strong> (например L"…"). Строковый литерал из расширенного набора имеет тип "массив из <emphasis>wchar_t</emphasis>". Конкатенация друг с другом обычных и "расширенных" строковых литералов не определена.</p>
     <cite>
      <p>То, что строковые литералы не обязательно представляются разными копиями, запрет на их модификацию, а также конкатенация соседних строковых литералов - нововведения ANSI-стандарта. "Расширенные" строковые литералы также объявлены впервые.</p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>A3. Нотация синтаксиса </p>
    </title>
    <p>В нотации синтаксиса, используемой в этом руководстве, синтаксические понятия набираются курсивом, а слова и символы, воспринимаемые буквально, обычным шрифтом. Альтернативные конструкции обычно перечисляются в столбик (каждая альтернатива на отдельной строке); в редких случаях длинные списки небольших по размеру альтернатив располагаются в одной строке, помеченной словами "один из". Необязательное слово-термин или не термин снабжается индексом "<emphasis>необ</emphasis>.". Так, запись</p>
    <p>{ <emphasis>выражение<sub>необ </sub></emphasis>}</p>
    <p>обозначает выражение, заключенное в фигурные скобки, которое в общем случае может отсутствовать. Полный перечень синтаксических конструкций приведен в A13.</p>
    <cite>
     <p>В отличие от грамматики, данной в первом издании этой книги, приведенная здесь грамматика старшинство и порядок выполнения операций в выражениях описывает явно.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>A4. Что обозначают идентификаторы</p>
    </title>
    <section>
     <p>Идентификаторы, или имена, ссылаются на разные объекты (в оригинале - <emphasis>things</emphasis>. - Примеч. ред.): функции; теги структур, объединений и перечислений; элементы структур или объединений; <emphasis>typedef</emphasis>-имена; метки и объекты. Объектом (называемым иногда переменной) является часть памяти, интерпретация которой зависит от двух главных характеристик: <emphasis>класса памяти</emphasis> н ее <emphasis>типа</emphasis>. Класс памяти сообщает о времени жизни памяти, связанной с идентифицируемым объектом, тип определяет, какого рода значения находятся в объекте. С любым именем ассоциируются своя область видимости (т. е. тот участок программы, где это имя известно) и атрибут связи, определяющий, обозначает ли это имя в другом файле тот же самый объект или функцию. Область видимости и атрибут связи обсуждаются в A11.</p>
    </section>
    <section>
     <title>
      <p>A4.1. Класс памяти</p>
     </title>
     <p>Существуют два класса памяти: <emphasis>автоматический</emphasis> и <emphasis>статический</emphasis>. Несколько ключевых слов в совокупности с контекстом объявлений объектов специфицируют класс памяти для этих объектов.</p>
     <p>Автоматические объекты локальны в блоке (A9.3), при выходе из него они "исчезают". Объявление, заданное внутри блока, если в нем отсутствует спецификация класса памяти или указан спецификатор auto, создаст автоматический объект. Объект, помеченный в объявлении словом <strong>register</strong>, является автоматическим и размещается по возможности в регистре машины.</p>
     <p>Статические объекты могут быть локальными в блоке или располагаться вне блоков, но в обоих случаях их значения сохраняются после выхода из блока (или функции) до повторного в него входа. Внутри блока (в том числе и в блоке, образующем тело функции) статические объекты в объявлениях помечаются словом <strong>static</strong>. Объекты, объявляемые вне всех блоков на одном уровне с определениями функций, всегда статические. С помощью ключевого слова <strong>static</strong> их можно сделать локальными в пределах транслируемой единицы (в этом случае они получают атрибут <emphasis>внутренней связи</emphasis>), и они становятся глобальными для всей программы, если опустить явное указание класса памяти или использовать ключевое слово <strong>extern</strong> (в этом случае они получают атрибут <emphasis>внешней связи</emphasis>).</p>
    </section>
    <section>
     <title>
      <p>A4.2. Базовые типы</p>
     </title>
     <p>Существует несколько базовых типов. Стандартный заголовочный файл ‹limits.h›, описанный в приложении B, определяет самое большое и самое малое значения для каждого типа в данной конкретной реализации. В приложении B приведены минимально возможные величины.</p>
     <p>Размер объектов, объявляемых как символы, позволяет хранить любой символ из набора символов, принятого в машине. Если объект типа <emphasis>char</emphasis> действительно хранит символ из данного набора, то его значением является код этого символа, т. е. некоторое неотрицательное целое. Переменные типа <emphasis>char</emphasis> могут хранить и другие значения, но тогда диапазон их значений и особенно вопрос о том, знаковые эти значения или беззнаковые, зависит от реализации.</p>
     <p>Беззнаковые символы, объявленные с помощью слов <emphasis>unsigned char</emphasis>, имеют ту же разрядность, что и обычные символы, но представляют неотрицательные значения; с помощью слов <emphasis>signed char</emphasis> можно явно объявить символы со знаком, которые занимают столько же места, как и обычные символы.</p>
     <cite>
      <p>Тип unsigned char не упоминался в первой редакции языка, но всеми использовался. Тип signed char - новый.</p>
     </cite>
     <p>Помимо <emphasis>char</emphasis> среди целочисленных типов могут быть целые трех размеров: <emphasis>short int</emphasis>, <emphasis>int</emphasis> и <emphasis>long int</emphasis>. Обычные объекты типа <emphasis>int</emphasis> имеют естественный размер, принятый в архитектуре данной машины, другие размеры предназначены для специальных нужд. Более длинные целые по крайней мере покрывают все значения более коротких целых, однако в некоторых реализациях обычные целые могут быть эквивалентны коротким (<emphasis>short</emphasis>) или длинным (<emphasis>long</emphasis>) целым. Все типы <emphasis>int</emphasis> представляют значения со знаком, если не оговорено противное.</p>
     <p>Для беззнаковых целых в объявлениях используется ключевое слово <emphasis>unsigned</emphasis>. Такие целые подчиняются арифметике по модулю 2 в степени <emphasis>n</emphasis>, где <emphasis>n</emphasis> - число битов в представлении числа, и, следовательно, в арифметике с беззнаковыми целыми никогда не бывает переполнения. Множество неотрицательных значений, которые могут храниться в объектах со знаком, является подмножеством значений, которые могут храниться в соответствующих объектах без знака; знаковое и беззнаковое представления каждого такого значения совпадают. Любые два из типов с плавающей точкой: с одинарной точностью (<emphasis>float</emphasis>), с двойной точностью (<emphasis>double</emphasis>) и с повышенной точностью (<emphasis>long double</emphasis>) могут быть синонимами, но каждый следующий тип этого списка должен по крайней мере обеспечивать точность предыдущего.</p>
     <cite>
      <p>long double - новый тип. В первой редакции языка синонимом для double был long float, теперь последний изъят из обращения.</p>
     </cite>
     <p><emphasis>Перечисления</emphasis> - единственные в своем роде типы, которым дается полный перечень значений; с каждым перечислением связывается множество именованных констант (A8.4). Перечисления ведут себя наподобие целых, но компилятор обычно выдает предупреждающее сообщение, если объекту некоторого перечислимого типа присваивается нечто, отличное от его константы, или выражение не из этого перечисления.</p>
     <p>Поскольку объекты перечислений можно рассматривать как числа, перечисление относится к арифметическому типу. Типы <emphasis>char</emphasis> и <emphasis>int</emphasis> всех размеров, каждый из которых может быть со знаком или без знака, а также перечисления называют <emphasis>целочисленными</emphasis> (<emphasis>integral</emphasis>) типами. Типы <emphasis>float</emphasis>, <emphasis>double</emphasis> и <emphasis>long double</emphasis> называются типами с <emphasis>плавающей точкой</emphasis>.</p>
     <p>Тип <emphasis>void</emphasis> специфицирует пустое множество значений. Он используется как "тип возвращаемого функцией значения" в том случае, когда она не генерирует никакого результирующего значения.</p>
    </section>
    <section>
     <title>
      <p>A4.3. Производные типы</p>
     </title>
     <p>Помимо базовых типов существует практически бесконечный класс производных типов, которые формируются из уже существующих и описывают следующие конструкции:</p>
     <p>• массивы объектов заданного типа;</p>
     <p>• функции, возвращающие объекты заданного типа;</p>
     <p>• указатели на объекты заданного типа;</p>
     <p>• структуры, содержащие последовательность объектов, возможно, различных заданных типов;</p>
     <p>• объединения, каждое из которых может содержать любой из нескольких объектов различных заданных типов.</p>
     <p>В общем случае приведенные методы конструирования объектов могут применяться рекурсивно.</p>
    </section>
    <section>
     <title>
      <p>A4.4. Квалификаторы типов</p>
     </title>
     <p>Тип объекта может снабжаться квалификатором. Объявление объекта с квалификатором <strong>const</strong> указывает на то, что его значение далее не будет изменяться; объявляя объект как <strong>volatile</strong> (изменчивый, непостоянный (<emphasis>англ.</emphasis>)), мы указываем на его особые свойства для выполняемой компилятором оптимизации. Ни один из квалификаторов на диапазоны значений и арифметические свойства объектов не влияет. Квалификаторы обсуждаются в A8.2.</p>
    </section>
   </section>
   <section>
    <title>
     <p>A5. Объекты и Lvalues</p>
    </title>
    <p><emphasis>Объект</emphasis> - это некоторая именованная область памяти; <strong>lvalue</strong> - это выражение, обозначающее объект. Очевидным примером <emphasis>lvalue</emphasis> является идентификатор с соответствующим типом и классом памяти. Существуют операции, порождающие <emphasis>lvalue</emphasis>. Например, если <emphasis>E</emphasis> - выражение типа указатель, то <emphasis>*E</emphasis> есть выражение для <emphasis>lvalue</emphasis>, обозначающего объект, на который указывает <emphasis>E</emphasis>. Термин "<emphasis>lvalue</emphasis>" произошел от записи присваивания E1 = E2, в которой левый (<emphasis>left</emphasis> - левый (<emphasis>англ.</emphasis>), отсюда буква <emphasis>l</emphasis>, <emphasis>value</emphasis> - значение) операнд E1 должен быть выражением <emphasis>lvalue</emphasis>. Описывая каждый оператор, мы сообщаем, ожидает ли он <emphasis>lvalue</emphasis> в качестве операндов и выдает ли <emphasis>lvalue</emphasis> в качестве результата.</p>
   </section>
   <section>
    <title>
     <p>A6. Преобразования</p>
    </title>
    <section>
     <p>Некоторые операторы в зависимости от своих операндов мoгут вызывать преобразование их значений из одного типа в другой. В этом параграфе объясняется, что следует ожидать от таких преобразований. В A6.5 формулируются правила, по которым выполняются преобразования для большинства обычных операторов. При рассмотрении каждого отдельного оператора эти правила могут уточняться.</p>
    </section>
    <section>
     <title>
      <p>A6.1. Целочисленное повышение</p>
     </title>
     <p>Объект типа перечисление, символ, короткое целое, целое в битовом поле - все они со знаком или без могут использоваться в выражении там, где возможно применение целого. Если тип <emphasis>int</emphasis> позволяет "охватить" все значения исходного типа операнда, то операнд приводится к <emphasis>int</emphasis>, в противном случае он приводится к <emphasis>unsigned int</emphasis>. Эта процедура называется целочисленным повышением (<emphasis>Integral promotion</emphasis> - целочисленное повышение - иногда также переводят как "интегральное продвижение" - <emphasis>Примеч. ред.</emphasis>).</p>
    </section>
    <section>
     <title>
      <p>A6.2. Целочисленные преобразования</p>
     </title>
     <p>Любое целое приводится к некоторому заданному беззнаковому типу путем поиска конгруэнтного (т. е. имеющего то же двоичное представление) наименьшего неотрицательного значения и получения остатка от деления его на <emphasis>nmax + 1</emphasis>, где <emphasis>nmax</emphasis> - наибольшее число в этом беззнаковом типе. Для двоичного представления в дополнительном коде это означает либо выбрасывание лишних старших разрядов, если беззнаковый тип "уже" исходного типа, либо заполнение недостающих старших разрядов нулями (для значения без знака) или значением знака (для значения со знаком), если беззнаковый тип "шире" исходного.</p>
     <p>В результате приведения любого целого к знаковому типу преобразуемое значение не меняется, если оно представимо в этом новом типе, и противном случае результат зависит от реализации.</p>
    </section>
    <section>
     <title>
      <p>A6.3. Целые и числа с плавающей точкой</p>
     </title>
     <p>При преобразовании из типа с плавающей точкой в целочисленный дробная часть значения отбрасывается; если полученное при этом значение нельзя представить в заданном целочисленном типе, то результат не определен. В частности, не определен результат преобразования отрицательных значений с плавающей точкой в беззнаковые целые.</p>
     <p>Если значение преобразуется из целого в величину с плавающей точкой и она находится в допустимом диапазоне, но представляется в новом типе неточно, то результатом будет одно из двух значений нового типа, ближайших к исходному. Если результат выходит за границы диапазона допустимых значений, поведение программы не определено.</p>
    </section>
    <section>
     <title>
      <p>A6.4. Типы с плавающей точкой</p>
     </title>
     <p>При преобразовании из типа с плавающей точкой меньшей точности в тип с плавающей точкой большей точности значение не изменяется. Если, наоборот, переход осуществляется от большей точности к меньшей и значение остается в допустимых пределах нового типа, то результатом будет одно из двух ближайших значений нового типа. Если результат выходит за границы диапазона допустимых значений, поведение программы не определено.</p>
    </section>
    <section>
     <title>
      <p>А6.5. Арифметические преобразования</p>
     </title>
     <p>Во многих операциях преобразование типов операндов и определение типа результата осуществляются по одним и тем же правилам. Они состоят в том, что операнды приводятся к некоторому общему типу, который также является и типом результата. Эти правила называются <emphasis>обычными арифметическими преобразованиями</emphasis>.</p>
     <p>• Если какой-либо из операндов имеет тип long double, то другой приводится к long double.</p>
     <p>• В противном случае, если какой-либо из операндов имеет тип double, то другой приводится к double.</p>
     <p>• В противном случае, если какой-либо из операндов имеет тип float, то другой приводится к float.</p>
     <p>• В противном случае для обоих операндов осуществляется целочисленное повышение: затем, если один из операндов имеет тип unsigned long int, то и другой преобразуется в unsigned long int.</p>
     <p>• В противном случае, если один из операндов принадлежит типу long int, а другой - unsigned int, то результат зависит от того, покрывает ли long int все значения unsigned int, и если это так, то unsigned int приводится к long int; если нет, то оба операнда преобразуются в unsigned long int.</p>
     <p>• В противном случае, если один из операндов имеет тип long int, то другой приводится к long int.</p>
     <p>• В противном случае, если один из операндов - unsigned int, то другой приводится к unsigned int.</p>
     <p>• В противном случае оба операнда имеют тип int.</p>
     <cite>
      <p>Здесь есть два изменения. Во-первых, арифметика с операндами с плавающей точкой теперь может производиться с одинарной точностью, а не только с двойной; в первой редакции языка вся арифметика с плавающей точкой производилась с двойной точностью. Во-вторых, более короткий беззнаковый тип в комбинации с более длинным знаковым типом не распространяет свойство беззнаковости на тип результата; в первой редакции беззнаковый тип всегда доминировал. Новые правила немного сложнее, но до некоторой степени уменьшают вероятность появления неожиданных эффектов в комбинациях знаковых и беззнаковых величин. При сравнении беззнакового выражения со знаковым того же размера все же может возникнуть неожиданный результат.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>A6.6. Указатели и целые </p>
     </title>
     <p>К указателю можно прибавлять (и вычитать из него) выражение целочисленного типа; последнее в этом случае подвергается преобразованию, описанному в A7.7 при рассмотрении оператора сложения.</p>
     <p>К двум указателям на объекты одного типа, принадлежащие одному массиву, может применяться операция вычитания; результат приводится к целому посредством преобразования, описанного в A7.7 при рассмотрении оператора вычитания.</p>
     <p>Целочисленное константное выражение со значением 0 или оно же, но приведенное к типу <emphasis>void *</emphasis>, может быть преобразовано в указатель любого типа операторами приведения, присваивания и сравнения. Результатом будет NULL-указатель, который равен любому другому NULL-указателю того же типа, но не равен никакому указателю на реальный объект или функцию.</p>
     <p>Для указателей допускаются и другие преобразования, но в связи с ними возникает проблема зависимости результата от реализации. Эти преобразования должны быть специфицированы явным оператором преобразования типа или оператором приведения (A7.5 и A8.8).</p>
     <p>Указатель можно привести к целочисленному типу, достаточно большому для его хранения; требуемый размер зависит от реализации. Функция преобразования также зависит от реализации.</p>
     <p>Объект целочисленного типа можно явно преобразовать в указатель. Если целое получено из указателя и имеет достаточно большой размер, это преобразование даст тот же указатель; в противном случае результат зависит от реализации.</p>
     <p>Указатель на один тип можно преобразовать в указатель на другой тип. Если исходный указатель ссылается на объект, должным образом не выровненный по границам слов памяти, то в результате может произойти ошибка адресации. Если требования на выравнивание у нового типа меньше или совпадают с требованиями на выравнивание первоначального типа, то гарантируется, что преобразование указателя в другой тип и обратно его не изменит; понятие "выравнивание" зависит от реализации, однако в любой реализации объекты типа <emphasis>char</emphasis> предъявляют минимальные требования на выравнивание. Как описано в A6.8, указатель может также преобразовываться в <emphasis>void *</emphasis> и обратно, значение указателя при этом не изменяется.</p>
     <p>Указатель может быть преобразован в другой указатель того же типа с добавлением или удалением квалификаторов (A4.4, A8.2) того типа объекта, на который этот указатель показывает. Новый указатель, полученный добавлением квалификатора, имеет то же значение, но с дополнительными ограничениями, внесенными новыми квалификаторами. Операция по удалению квалификатора у объекта приводит к тому, что восстанавливается действие его начальных квалификаторов, заданных в объявлении этого объекта.</p>
     <p>Наконец, указатель на функцию может быть преобразован в указатель на функцию другого типа. Вызов функции по преобразованному указателю зависит от реализации; однако, если указатель еще раз преобразовать к его исходному типу, результат будет идентичен вызову по первоначальному указателю.</p>
    </section>
    <section>
     <title>
      <p>A6.7. Тип void</p>
     </title>
     <p>Значение (несуществующее) объекта типа <emphasis>void</emphasis> никак нельзя использовать, его также нельзя явно или неявно привести к типу, отличному от <emphasis>void</emphasis>. Поскольку выражение типа <emphasis>void</emphasis> обозначает отсутствие значения, его можно применять только там, где не требуется значения. Например, в качестве выражения- инструкции (A9.2) или левого операнда у оператора "запятая" (A7.18). Выражение можно привести к тину <emphasis>void</emphasis> операцией приведения типа. Например, применительно к вызову функции, используемому в роли выражения-инструкции, операция приведения к <emphasis>void</emphasis> явным образом подчеркивает тот факт, что результат функции отбрасывается.</p>
     <p>Тип void не фигурировал в первом издании этой книги, однако за прошедшее время стал общеупотребительным.</p>
    </section>
    <section>
     <title>
      <p>А6.8. Указатели на void</p>
     </title>
     <p>Любой указатель на объект можно привести к типу <emphasis>void *</emphasis> без потери информации. Если результат подвергнуть обратному преобразованию, то мы получим прежний указатель. В отличие от преобразований указатель-в-указатель (рассмотренных в A6.6), которые требуют явных операторов приведения к типу, в присваиваниях и сравнениях указатель любого типа может выступать в паре с указателем типа <emphasis>void *</emphasis> без каких-либо предварительных преобразований типа.</p>
     <cite>
      <p>Такая интерпретация указателей void * - новая; ранее роль обобщенного указателя отводилась указателю типа char *. Стандарт ANSI официально разрешает использование указателей void * совместно с указателями других типов в присваиваниях и сравнениях; в иных комбинациях указателей стандарт требует явных преобразований типа.</p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>A7. Выражения</p>
    </title>
    <section>
     <p>Приоритеты описываемых операторов имеют тот же порядок, что и пункты данного параграфа (от высших к низшим). Например, для оператора <strong>+</strong>, описанного в A7.7, термин "операнды" означает "выражения, определенные в A7.1-A7.6". В каждом пункте описываются операторы, имеющие одинаковый приоритет, и указывается их ассоциативность (левая или правая). Приоритеты и ассоциативность всех операторов отражены в грамматике, приведенной в A13.</p>
     <p>Приоритеты и ассоциативность полностью определены, а вот порядок вычисления выражения не определен за некоторым исключением даже для подвыражений с побочным эффектом. Это значит, что если в определении оператора последовательность вычисления его операндов специально не оговаривается, то в реализации можно свободно выбирать любой порядок вычислений и даже чередовать правый и левый порядок. Однако любой оператор использует значения своих операндов в точном соответствии с грамматическим разбором выражения, в котором он встречается.</p>
     <cite>
      <p>Это правило отменяет ранее предоставлявшуюся свободу в выборе порядка выполнения операций, которые математически коммутативны и ассоциативны, но которые в процессе вычислений могут таковыми не оказаться. Это изменение затрагивает только вычисления с плавающей точкой, выполняющиеся "на грани точности", и ситуации, когда возможно переполнение.</p>
     </cite>
     <p>В языке не определен контроль за переполнением, делением на нуль и другими исключительными ситуациями, возникающими при вычислении выражения. В большинстве существующих реализаций Си при вычислении знаковых целочисленных выражений и присваивании переполнение игнорируется, но результат таких вычислений не определен. Трактовки деления на нуль и всех исключительных ситуаций, связанных с плавающей точкой, могут не совпадать в разных реализациях; иногда для обработки исключительных ситуаций предоставляется нестандартная библиотечная функция.</p>
    </section>
    <section>
     <title>
      <p>A7.1. Генерация указателя </p>
     </title>
     <p>Если тип выражения или подвыражения есть "массив из <emphasis>T</emphasis>", где <emphasis>T</emphasis> - некоторый тип, то значением этого выражения является указатель на первый элемент массива, и тип такого выражения заменяется на тип "указатель на <emphasis>T</emphasis>". Такая замена не делается, если выражение является операндом унарного оператора <strong>amp;</strong>, или операндом операций <strong>++</strong>, -<strong>-</strong>, <strong>sizeof</strong>, или левым операндом присваивания, или операндом оператора <strong>.</strong> (точка). Аналогично, выражение типа "функция, возвращающая <emphasis>Т</emphasis>", кроме случая, когда оно является операндом для&amp;, преобразуется в тип "указатель на функцию, возвращающую <emphasis>T</emphasis>".</p>
    </section>
    <section>
     <title>
      <p>A7.2. Первичные выражения</p>
     </title>
     <p>Первичные выражения это идентификаторы, константы, строки и выражения в скобках.</p>
     <p><code><emphasis>первичное - выражение</emphasis>:</code></p>
     <p><code>    <emphasis>идентификатор</emphasis></code></p>
     <p><code>    <emphasis>константа</emphasis></code></p>
     <p><code>    <emphasis>строка</emphasis></code></p>
     <p><code>    (<emphasis>выражение</emphasis>)</code></p>
     <p>Идентификатор, если он был должным образом объявлен (о том, как это делается, речь пойдет ниже), - первичное выражение. Тип идентификатора специфицируется в его объявлении. Идентификатор есть <emphasis>lvalue</emphasis>, если он обозначает объект (A5) арифметического типа, либо объект типа "структура", "объединение" или "указатель".</p>
     <p>Константа - первичное выражение. Ее тип зависит от формы записи, которая была рассмотрена в A2.5.</p>
     <p>Строковый литерал - первичное выражение. Изначально его тип - "массив из <emphasis>char</emphasis>" ("массив из <emphasis>wchar_t</emphasis>" для строки символов расширенного набора), но в соответствии с правилом, приведенным в A7.1, указанный тип обычно превращается в "указатель на <emphasis>char</emphasis>" ("указатель на <emphasis>wchar_t</emphasis>") с результирующим значением "указатель на первый символ строки". Для некоторых инициализаторов такая замена типа не делается. (см. A8.7)</p>
     <p>Выражение в скобках - первичное выражение, тип и значение которого идентичны типу и значению этого же выражения без скобок. Наличие или отсутствие скобок не влияет на то, является ли данное выражение <emphasis>lvalue</emphasis> или нет.</p>
    </section>
    <section>
     <title>
      <p>A7.3. Постфиксные выражения</p>
     </title>
     <section>
      <p>В постфиксных выражениях операторы выполняются слева направо.</p>
      <p><code><emphasis>постфиксное-выражение</emphasis>:</code></p>
      <p><code>    <emphasis>первичное-выражение</emphasis></code></p>
      <p><code>    <emphasis>постфиксное-выражение</emphasis> [<emphasis>выражение</emphasis>]</code></p>
      <p><code>    <emphasis>постфиксное-выражение</emphasis> (<emphasis>список-аргументов-выражений<sub>необ</sub></emphasis>)</code></p>
      <p><code>    <emphasis>постфиксное-выражение.идентификатор</emphasis></code></p>
      <p><code>    <emphasis>постфиксное-выражение-&gt;идентификатор</emphasis></code></p>
      <p><code>    <emphasis>постфиксное-выражение</emphasis> ++</code></p>
      <p><code>    <emphasis>постфиксное-выражение</emphasis> --</code></p>
      <p><code><emphasis>список-аргументов-выражений</emphasis>:</code></p>
      <p><code>    <emphasis>выражение-присваивание</emphasis></code></p>
      <p><code>    <emphasis>список-аргументов-выражений</emphasis> , <emphasis>выражение-присваивание</emphasis></code></p>
     </section>
     <section>
      <title>
       <p>A7.3.1. Обращение к элементам массива</p>
      </title>
      <p>Постфиксное выражение, за которым следует выражение в квадратных скобках, есть постфиксное выражение, обозначающее обращение к индексируемому массиву. Одно из этих двух выражений должно принадлежать типу "указатель на T", где T - некоторый тип, а другое - целочисленному типу; тип результата индексирования есть T. Выражение E1[E2] по определению идентично выражению *((E1)+(E2)). Подробности см. в A8.6. </p>
     </section>
     <section>
      <title>
       <p>A7.3.2. Вызов функции</p>
      </title>
      <p>Вызов функции есть постфиксное выражение (оно называется именующим выражением функции - <emphasis>function designator</emphasis>), за которым следуют скобки, содержащие (возможно пустой) список разделенных запятыми выражений-присваиваний (A7.17), представляющих собой аргументы этой функции. Если постфиксное выражение - идентификатор, не объявленный в текущей области видимости, то считается, что этот идентификатор как бы неявно описан объявлением </p>
      <p><code>extern int <emphasis>identifier</emphasis>();</code></p>
      <p>помещенным в самом внутреннем блоке, содержащем вызов соответствующей функции. Постфиксное выражение (после, возможно неявного, описания и генерации указателя, см. A7.1) должно иметь тип "указатель на функцию, возвращающую <emphasis>T</emphasis>", где <emphasis>T</emphasis> - тип возвращаемого значения. </p>
      <cite>
       <p>В первой версии языка для именующего выражения функции допускался только тип "функция", и чтобы вызвать функцию через указатель, требовался явный оператор *. ANSI-стандарт поощряет практику некоторых существующих компиляторов, разрешающих иметь одинаковый синтаксис для обращения просто к функции и обращения к функции, специфицированной указателем. Возможность применения старого синтаксиса остается. </p>
      </cite>
      <p>Термин <emphasis>аргумент</emphasis> используется для выражения, задаваемого в вызове функции; термин <emphasis>параметр</emphasis> - для обозначения получаемого ею объекта (или его идентификатора) в определении или объявлении функции. Вместо этих понятий иногда встречаются термины "фактический аргумент (параметр)" и "формальный аргумент (параметр)", имеющие те же смысловые различия. </p>
      <p>При вызове функции каждый ее аргумент копируется; передача аргументов осуществляется строго через их значения. Функции разрешается изменять значения своих параметров, которые являются лишь копиями аргументов- выражений, но эти изменения не могут повлиять на значения самих аргументов. Однако можно передать указатель, чтобы позволить функции изменить значение объекта, на который указывает этот указатель.</p>
      <p>Имеются два способа объявления функции. В новом способе типы параметров задаются явно и являются частью типа функции; такое объявление называется прототипом функции. При старом способе типы параметров не указываются. Способы объявления функций обсуждаются в A8.6.3 и A10.1. </p>
      <p>Если вызов находится в области видимости объявления, написанного по-старому, каждый его аргумент подвергается операции повышения типа: для целочисленных аргументов осуществляется целочисленное повышение (A6.1), а для аргументов типа <emphasis>float</emphasis> - преобразование в <emphasis>double</emphasis>. Если число аргументов не соответствует количеству параметров в определении функции или если типы аргументов после повышения не согласуются с типами соответствующих параметров, результат вызова не определен. Критерий согласованности типов зависит от способа определения функции (старого или нового). При старом способе сравниваются повышенный тип аргумента в вызове и повышенный тип соответствующего параметра; при новом способе повышенный тип аргумента и тип параметра (без его повышения) должны быть одинаковыми. </p>
      <p>Если вызов находится в области видимости объявления, написанного по-новому, аргументы преобразуются, как если бы они присваивались переменным, имеющим типы соответствующих параметров прототипа. Число аргументов должно совпадать с числом явно описанных параметров, если только список параметров не заканчивается многоточием (, ...). В противном случае число аргументов должно быть больше числа параметров или равно ему; "скрывающиеся" под многоточием аргументы подвергаются операции повышения типа (так, как это было описано в предыдущем абзаце). Если определение функции задано по-старому, то типы параметров в прототипе, которые неявно присутствуют в вызове, должны соответствовать типам параметров в определении функции после их повышения. </p>
      <cite>
       <p>Эти правила особенно усложнились из-за того, что они призваны обслуживать смешанный способ (старого с новым) задания функций. По возможности его следует избегать. </p>
      </cite>
      <p>Очередность вычисления аргументов не определяется, в разных компиляторах она различна. Однако гарантируется, что аргументы и именующее выражение функции вычисляются полностью (включая и побочные эффекты) до входа в нее. Любая функция допускает рекурсивное обращение.  </p>
     </section>
     <section>
      <title>
       <p>A7.3.3. Обращение к структурам</p>
      </title>
      <p>Постфиксное выражение, за которым стоит точка с последующим идентификатором, является постфиксным выражением. Выражение первого операнда должно быть структурой или объединением, а идентификатор - именем элемента структуры или объединения. Значение - именованный элемент структуры или объединения, а тип значения - тип элемента структуры или объединения. Выражение является <emphasis>lvalue</emphasis>, если первое выражение - <emphasis>lvalue</emphasis> и если тип второго выражения - не "массив". </p>
      <p>Постфиксное выражение, за которым стоит стрелка (составленная из знаков - и &gt;) с последующим идентификатором, является постфиксным выражением. Выражение первого операнда должно быть указателем на структуру (объединение), а идентификатор - именем элемента структуры (объединения). Результат - именованный элемент структуры (объединения), на которую указывает указатель, а тип значения - тип элемента структуры (объединения); результат - <emphasis>lvalue</emphasis>, если тип не есть "массив".</p>
      <p>Таким образом, выражение E1-&gt;MOS означает то же самое, что и выражение (*E1).MOS. Структуры и объединения рассматриваются в A8.3.</p>
      <p>В первом издании книги уже было приведено правило, по которому имя элемента должно принадлежать структуре или объединению, упомянутому в постфиксном выражении. Там, однако, оговаривалось, что оно не является строго обязательным. Последние компиляторы и ANSI делают его обязательным. </p>
     </section>
     <section>
      <title>
       <p>A7.3.4. Постфиксные операторы инкремента и декремента</p>
      </title>
      <p>Постфиксное выражение, за которым следует <strong>++</strong> или <strong>--</strong>, есть постфиксное выражение. Значением такого выражения является значение его операнда. После того как значение было взято, операнд увеличивается (++) или уменьшается (--) на 1. Операнд должен быть <emphasis>lvalue</emphasis>; информация об ограничениях, накладываемых на операнд, и деталях операций содержится в A7.7, где обсуждаются аддитивные операторы, и в A7.17, где рассматривается присваивание. Результат инкрементирования или декрементирования не есть <emphasis>lvalue</emphasis>.</p>
     </section>
    </section>
    <section>
     <title>
      <p>А7.4. Унарные операторы</p>
     </title>
     <section>
      <p>Выражения с унарными операторами выполняются справа налево.</p>
      <p><code><emphasis>унарное-выражение</emphasis>:</code></p>
      <p><code>    <emphasis>постфиксное-выражение</emphasis></code></p>
      <p><code>    ++ <emphasis>унарное-выражение</emphasis></code></p>
      <p><code>    -- <emphasis>унарное-выражение</emphasis></code></p>
      <p><code>    <emphasis>унарный-оператор выражение-приведенное-к-типу</emphasis></code></p>
      <p><code>    sizeof <emphasis>унарное-выражение</emphasis></code></p>
      <p><code>    sizeof (<emphasis>имя-типа</emphasis>)</code></p>
      <p><code><emphasis>унарный-оператор</emphasis>: один из </code></p>
      <p><code>    &amp;   *   +   -   ~   !</code></p>
     </section>
     <section>
      <title>
       <p>А7.4.1. Префиксные операторы инкремента и декремента</p>
      </title>
      <p>Унарное выражение, перед которым стоит <strong>++</strong> или <strong>--</strong>, есть унарное выражение. Операнд увеличивается (++) или уменьшается (--) на 1.</p>
      <p>Значением выражения является значение его операнда после увеличения (уменьшения). Операнд всегда должен быть <emphasis>lvalue</emphasis>; информация об ограничениях на операнд и о деталях операции содержится в A7.7, где обсуждаются аддитивные операторы, и в A7.17, где рассматривается присваивание. Результат инкрементирования и декрементирования не есть <emphasis>lvalue</emphasis>. </p>
     </section>
     <section>
      <title>
       <p>A7.4.2. Оператор получения адреса</p>
      </title>
      <p>Унарный оператор <strong>&amp;</strong> обозначает операцию получения адреса своего операнда. Операнд должен быть либо <emphasis>lvalue</emphasis>, не ссылающимся ни на битовое поле, ни на объект, объявленный как <emphasis>register</emphasis>, либо иметь тип "функция". Результат - указатель на объект (или функцию), адресуемый этим <emphasis>lvalue</emphasis>. Если тип операнда есть <emphasis>T</emphasis>, то типом результата является "указатель на <emphasis>T</emphasis>". </p>
     </section>
     <section>
      <title>
       <p>A7.4.3. Оператор косвенного доступа</p>
      </title>
      <p>Унарный оператор <strong>*</strong> обозначает операцию косвенного доступа (раскрытия указателя), возвращающую объект (или функцию), на который указывает ее операнд. Результат есть <emphasis>lvalue</emphasis>, если операнд - указатель на объект арифметического типа или на объект типа "структура", "объединение" или "указатель". Если тип выражения - "указатель на <emphasis>T</emphasis>", то тип результата - <emphasis>T</emphasis>. </p>
     </section>
     <section>
      <title>
       <p>A7.4.4. Оператор унарный плюс</p>
      </title>
      <p>Операнд унарного <strong>+</strong> должен иметь арифметический тип, результат - значение операнда. Целочисленный операнд подвергается целочисленному повышению. Типом результата является повышенный тип операнда. </p>
      <cite>
       <p>Унарный + был добавлен для симметрии с унарным -.</p>
      </cite>
     </section>
     <section>
      <title>
       <p>A7.4.5. Оператор унарный минус</p>
      </title>
      <p>Операнд для унарного минуса должен иметь арифметический тип, результат - значение операнда с противоположным знаком. Целочисленный операнд подвергается целочисленному повышению. Отрицательное значение от беззнаковой величины вычисляется вычитанием из <emphasis>nmax+1</emphasis> приведенного к повышенному типу операнда, где <emphasis>nmax</emphasis> - максимальное число повышенного типа; однако минус нуль есть нуль. Типом результата будет повышенный тип операнда. </p>
     </section>
     <section>
      <title>
       <p>A7.4.6. Оператор побитового отрицания</p>
      </title>
      <p>Операнд оператора <strong>~</strong> должен иметь целочисленный тип, результат - дополнение операнда до единиц по всем разрядам. Выполняется целочисленное повышение типа операнда. Если операнд беззнаковый, то результат получается вычитанием его значения из самого большого числа повышенного типа. Если операнд знаковый, то результат вычисляется посредством приведения "повышенного операнда" к беззнаковому типу, выполнения операции ~ и обратного приведения его к знаковому типу. Тип результата - повышенный тип операнда. </p>
     </section>
     <section>
      <title>
       <p>A7.4.7. Оператор логического отрицания</p>
      </title>
      <p>Операнд оператора <strong>!</strong> должен иметь арифметический тип или быть указателем. Результат равен 1, если сравнение операнда с 0 дает истину, и равен 0 в противном случае. Тип результата - <emphasis>int</emphasis>.  </p>
     </section>
     <section>
      <title>
       <p>A7.4.8. Оператор определения размера sizeof </p>
      </title>
      <p>Оператор <strong>sizeof</strong> дает число байтов, требуемое для хранения объекта того типа, который имеет его операнд. Операнд - либо выражение (которое не вычисляется), либо имя типа, записанное в скобках. Примененный к <emphasis>char</emphasis> оператор <emphasis>sizeof</emphasis> дает 1. Для массива результат равняется общему количеству байтов в массиве, для структуры или объединения - числу байтов в объекте, включая и байты- заполнители, которые понадобились бы, если бы из элементов составлялся массив. Размер массива из <emphasis>n</emphasis> элементов всегда равняется <emphasis>n</emphasis>, помноженному на размер отдельного его элемента. Данный оператор нельзя применять к операнду типа "функция", к незавершенному типу и к битовому полю. Результат - беззнаковая целочисленная константа: конкретный ее тип зависит от реализации. В стандартном заголовочном файле <strong>&lt;stddef.h&gt;</strong>(см. приложение B) этот тип определяется под именем <strong>size_t</strong>. </p>
     </section>
    </section>
    <section>
     <title>
      <p>A7.5. Оператор приведения типа</p>
     </title>
     <p>Имя типа, записанное перед унарным выражением н скобках, вызывает приведение значения этого выражения к указанному типу. </p>
     <p><code><emphasis>выражение-приведенное-к-типу</emphasis>:</code></p>
     <p><code>    <emphasis>унарное-выражение</emphasis> </code></p>
     <p><code>    (<emphasis>имя-типа</emphasis>) <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
     <p>Данная конструкция называется <emphasis>приведением</emphasis>. Имена типов даны в A8.8. Результат преобразований описан в A6. Выражение с приведением типа не является <emphasis>lvalue</emphasis>. </p>
    </section>
    <section>
     <title>
      <p>A7.6. Мультипликативные операторы</p>
     </title>
     <p>Мультипликативные операторы <strong>*</strong>, <strong>/</strong> и <strong>%</strong> выполняются слева направо. </p>
     <p><code><emphasis>мультипликативное-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
     <p><code>    <emphasis>мультипликативное-выражение</emphasis> * <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
     <p><code>    <emphasis>мультипликативное-выражение</emphasis> / <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
     <p><code>    <emphasis>мультипликативное-выражение</emphasis> % <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
     <p>Операнды операторов * и / должны быть арифметического типа, оператора % - целочисленного типа. Над операндами осуществляются обычные арифметические преобразования, которые приводят их значения к типу результата.</p>
     <p>Бинарный оператор * обозначает умножение.</p>
     <p>Бинарный оператор / получает частное, а % - остаток от деления первого операнда на второй; если второй операнд есть 0, то результат не определен. В противном случае всегда выполняется соотношение: (a / b) * b + a % b равняется a. Если оба операнда не отрицательные, то остаток не отрицательный и меньше делителя; в противном случае стандарт гарантирует только одно: что абсолютное значение остатка меньше абсолютного значения делителя. </p>
    </section>
    <section>
     <title>
      <p>A7.7. Аддитивные операторы</p>
     </title>
     <p>Аддитивные операторы <strong>+</strong> и <strong>-</strong> выполняются слева направо. Если операнды имеют арифметический тип, то осуществляются обычные арифметические преобразования. Для каждого оператора существует еще несколько дополнительных сочетаний типов. </p>
     <p><code><emphasis>аддитивное-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>мультипликативное-выражение</emphasis></code></p>
     <p><code>    <emphasis>аддитивное-выражение</emphasis> + <emphasis>мультипликативное-выражение</emphasis></code></p>
     <p><code>    <emphasis>аддитивное-выражение</emphasis> - <emphasis>мультипликативное-выражение</emphasis></code></p>
     <p>Результат выполнения оператора + есть сумма его операндов. Указатель на объект в массиве можно складывать с целочисленным значением. При этом последнее преобразуется в адресное смещение посредством умножения его на размер объекта, на который ссылается указатель. Сумма является указателем на объект того же типа; только ссылается этот указатель на другой объект того же массива, отстоящий от первоначального соответственно вычисленному смещению. Так, если <emphasis>p</emphasis> - указатель на объект в массиве, то <emphasis>p+1</emphasis> - указатель на следующий объект того же массива. Если полученный в результате суммирования указатель указывает за границы массива, то, кроме случая, когда он указывает на место, находящееся непосредственно за концом массива, результат будет неопределенным. </p>
     <cite>
      <p>Возможность для указателя указывать на элемент, расположенный сразу за концом массива, является новой. Тем самым узаконена общепринятая практика организации циклического перебора элементов массива. </p>
     </cite>
     <p>Результат выполнения оператора - (минус) есть разность операндов. Из указателя можно вычитать значение любого целочисленного типа с теми же преобразованиями и при тех же условиях, что и в сложении.</p>
     <p>Если к двум указателям на объекты одного и того же типа применить оператор вычитания, то в результате получится целочисленное значение со знаком, представляющее собой расстояние между объектами, на которые указывают эти указатели: указатель на следующий объект на 1 больше указателя на предыдущий объект. Тип результата зависит от реализации: в стандартном заголовочном файле <strong>&lt;stddef.h&gt;</strong> он определен под именем <strong>ptrdiff_t</strong>. Значение не определено, если указатели указывают на объекты не одного и того же массива; однако если <emphasis>p</emphasis> указывает на последний элемент массива, то <emphasis>p+1-p</emphasis> имеет значение, равное 1.</p>
    </section>
    <section>
     <title>
      <p>A7.8. Операторы сдвига</p>
     </title>
     <p>Операторы сдвига <strong>&lt;&lt;</strong> и <strong>&gt;&gt;</strong> выполняются слева направо. Для обоих операторов каждый операнд должен иметь целочисленный тип, и каждый из них подвергается целочисленному повышению. Тип результата совпадает с повышенным типом левого операнда. Результат не определен, если правый операнд отрицателен или его значение превышает число битов в типе левого выражения или равно ему.</p>
     <p><code><emphasis>сдвиговое-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>аддитивное-выражение</emphasis></code></p>
     <p><code>    <emphasis>сдвиговое-выражение</emphasis> &gt;&gt; <emphasis>аддитивное-выражение</emphasis></code></p>
     <p><code>    <emphasis>сдвиговое-выражение &lt;&lt; аддитивное-выражение</emphasis></code></p>
     <p>Значение E1&lt;&lt;E2 равно значению E1 (рассматриваемому как цепочка битов), сдвинутому влево на E2 битов; при отсутствии переполнения такая операция эквивалентна умножению на 2<sup>E2</sup>. Значение E1&gt;&gt;E2 равно значению E1, сдвинутому вправо на E2 битовые позиции. Если E1 - беззнаковое или имеет неотрицательное значение, то правый сдвиг эквивалентен делению на 2<sup>E2</sup>, в противном случае результат зависит от реализации. </p>
    </section>
    <section>
     <title>
      <p>A7.9. Операторы отношения</p>
     </title>
     <empty-line/>
     <p>Операторы отношения выполняются слева направо, однако это свойство едва ли может оказаться полезным: согласно грамматике языка выражение a &lt; b &lt; c трактуется так же, как (a &lt; b) &lt; c, а результат вычисления a &lt; b может быть только 0 или 1.</p>
     <p><code><emphasis>выражение-отношения</emphasis>:</code></p>
     <p><code>    <emphasis>сдвиговое-выражение</emphasis></code></p>
     <p><code>    <emphasis>выражение-отношения</emphasis> &lt; <emphasis>сдвиговое-выражение</emphasis></code></p>
     <p><code>    <emphasis>выражение-отношения</emphasis> &gt; <emphasis>сдвиговое-выражение</emphasis></code></p>
     <p><code>    <emphasis>выражение-отношения</emphasis> &lt;= <emphasis>сдвиговое-выражение</emphasis></code></p>
     <p><code>    <emphasis>выражение-отношения</emphasis> &gt;= <emphasis>сдвиговое-выражение</emphasis></code></p>
     <p>Операторы: <strong>&lt;</strong> (меньше), <strong>&gt;</strong> (больше), <strong>&lt;=</strong> (меньше или равно) и <strong>&gt;=</strong> (больше или равно) - все выдают 0, если специфицируемое отношение ложно, и 1, если оно истинно. Тип результата - <emphasis>int</emphasis>. Над арифметическими операндами выполняются обычные арифметические преобразования. Можно сравнивать указатели на объекты одного и того же типа (без учета квалификаторов); результат будет зависеть от относительного расположения в памяти. Допускается, однако, сравнение указателей на разные части одного и того же объекта: если два указателя указывают на один и тот же простой объект, то они равны; если они указывают на элементы одной структуры, то указатель на элемент с более поздним объявлением в структуре больше; если указатели указывают на элементы одного и того же объединения, то они равны; если указатели указывают на элементы некоторого массива, то сравнение этих указателей эквивалентно сравнению их индексов. Если <emphasis>p</emphasis> указывает на последний элемент массива, то <emphasis>p+1</emphasis> больше, чем <emphasis>p</emphasis>, хотя <emphasis>p+1</emphasis> указывает за границы массива. В остальных случаях результат сравнения не определен. </p>
     <cite>
      <p>Эти правила несколько ослабили ограничения, установленные в первой редакции языка. Они позволяют сравнивать указатели на различные элементы структуры и объединения и легализуют сравнение с указателем на место, которое расположено непосредственно за концом массива. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>A7.10. Операторы равенства</p>
     </title>
     <p><code><emphasis>выражение-равенства</emphasis>:</code></p>
     <p><code>    <emphasis>выражение-отношения</emphasis></code></p>
     <p><code>    <emphasis>выражение-равенства</emphasis> == <emphasis>выражение-отношения</emphasis></code></p>
     <p><code>    <emphasis>выражение-равенства</emphasis> != <emphasis>выражение-отношения</emphasis></code></p>
     <p>Операторы <strong>==</strong> (равно) и <strong>!=</strong> (не равно) аналогичны операторам отношения с той лишь разницей, что имеют более низкий приоритет. (Таким образом, a &lt; b == c &lt; d есть 1 тогда и только тогда, когда отношения a &lt; b и c &lt; d или оба истинны, или оба ложны.)</p>
     <p>Операторы равенства подчиняются тем же правилам, что и операторы отношения. Кроме того, они дают возможность сравнивать указатель с целочисленным константным выражением, значение которого равно нулю, и с указателем на <emphasis>void</emphasis> (см. A6.6.). </p>
    </section>
    <section>
     <title>
      <p>A7.11. Оператор побитового И</p>
     </title>
     <p><code><emphasis>И-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>выражение-равенства</emphasis></code></p>
     <p><code>    <emphasis>И-выражение</emphasis> &amp; <emphasis>выражение-равенства</emphasis></code></p>
     <p>Выполняются обычные арифметические преобразования: результат - побитовое <strong>AND</strong> операндов. Оператор применяется только к целочисленным операндам. </p>
    </section>
    <section>
     <title>
      <p>A7.12. Оператор побитового исключающего ИЛИ</p>
     </title>
     <p><code><emphasis>исключающее-ИЛИ-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>И-выражение</emphasis></code></p>
     <p><code>    <emphasis>исключающее-ИЛИ-выражение</emphasis> ^ <emphasis>И-выражение</emphasis></code></p>
     <p>Выполняются обычные арифметические преобразования; результат - побитовое <strong>XOR</strong> операндов. Оператор применяется только к целочисленным операндам.</p>
    </section>
    <section>
     <title>
      <p>A7.13. Оператор побитового ИЛИ</p>
     </title>
     <p><code><emphasis>ИЛИ выражение</emphasis>:</code></p>
     <p><code>    <emphasis>исключающее-ИЛИ-выражение</emphasis></code></p>
     <p><code>    <emphasis>ИЛИ-выражение</emphasis> | <emphasis>исключающее-ИЛИ-выражение</emphasis></code></p>
     <p>Выполняются обычные арифметические преобразования; результат - побитовое <strong>OR</strong> операндов. Оператор применяется только к целочисленным операндам. </p>
    </section>
    <section>
     <title>
      <p>A7.14. Оператор логического И</p>
     </title>
     <p><code><emphasis>логическое-И-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>ИЛИ-выражение</emphasis></code></p>
     <p><code>    <emphasis>логическое-И-выражение</emphasis> &amp;&amp; <emphasis>ИЛИ-выражение</emphasis></code></p>
     <p>Операторы <strong>&amp;&amp;</strong> выполняются слева направо. Оператор &amp;&amp; выдает 1, если оба операнда не равны нулю, и 0 в противном случае. В отличие от &amp;, &amp;&amp; гарантирует, что вычисления будут проводиться слева направо: вычисляется первый операнд со всеми побочными эффектами; если он равен 0, то значение выражения есть 0. В противном случае вычисляется правый операнд, и, если он ранен 0, то значение выражения есть 0, в противном случае оно равно 1.</p>
     <p>Операнды могут принадлежать к разным типам, но при этом каждый из них должен иметь либо арифметический тип, либо быть указателем. Тип результата - <emphasis>int</emphasis>. </p>
    </section>
    <section>
     <title>
      <p>A7.15. Оператор логического ИЛИ</p>
     </title>
     <p><code><emphasis>логическое-ИЛИ-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>логическое-И-выражение</emphasis></code></p>
     <p><code>    <emphasis>логическое-ИЛИ-выражение</emphasis> || <emphasis>логическое-И-выражение</emphasis></code></p>
     <p>Операторы <strong>||</strong> выполняются слева направо. Оператор || выдает 1, если по крайней мере один из операндов не равен нулю, и 0 в противном случае. В отличие от |, оператор || гарантирует, что вычисления будут проводиться слева направо: вычисляется первый операнд, включая все побочные эффекты; если он не равен 0, то значение выражения есть 1. В противном случае вычисляется правый операнд, и если он не равен 0, то значение выражения есть 1, в противном случае оно равно 0.</p>
     <p>Операнды могут принадлежать разным типам, но операнд должен иметь либо арифметический тип, либо быть указателем. Тип результата - <emphasis>int</emphasis>. </p>
    </section>
    <section>
     <title>
      <p>А7.16. Условный оператор</p>
     </title>
     <p><code><emphasis>условное-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>логическое-ИЛИ-выражение</emphasis></code></p>
     <p><code>    <emphasis>логическое-ИЛИ-выражение</emphasis> ? <emphasis>выражение</emphasis> : <emphasis>условное-выражение</emphasis></code></p>
     <p>Вычисляется первое выражение, включая все побочные эффекты; если оно не равно 0, то результат есть значение второго выражения, в противном случае - значение третьего выражения. Вычисляется только один из двух последних операндов: второй или третий. Если второй и третий операнды арифметические, то выполняются обычные арифметические преобразования, приводящие к некоторому общему типу, который и будет типом результата. Если оба операнда имеют тип <emphasis>void</emphasis>, или являются структурами или объединениями одного и того же типа, или представляют собой указатели на объекты одного и того же типа, то результат будет иметь тот же тип, что и операнды. Если один из операндов имеет тип "указатель", а другой является константой 0, то 0 приводится к типу "указатель", этот же тип будет иметь и результат. Если один операнд является указателем на <emphasis>void</emphasis>, а второй - указателем другого типа, то последний преобразуется в указатель на <emphasis>void</emphasis>, который и будет типом результата. </p>
     <p>При сравнении типов указателей квалификаторы типов (A8.2) объектов, на которые указатели ссылаются, во внимание не принимаются, но тип результата наследует квалификаторы обеих ветвей условного выражения</p>
    </section>
    <section>
     <title>
      <p>A7.17. Выражения присваивания</p>
     </title>
     <p>Существует несколько операторов присваивания; они выполняются справа налево. </p>
     <p><code><emphasis>выражение-присваивания</emphasis>:</code></p>
     <p><code>    <emphasis>условное-выражение</emphasis></code></p>
     <p><code>    <emphasis>унарное-выражение оператор-присваивания выражение-присваивания</emphasis></code></p>
     <p><code><emphasis>оператор-присваивания</emphasis>: один из</code></p>
     <p><code>    =</code></p>
     <p><code>    *=</code></p>
     <p><code>    /=</code></p>
     <p><code>    %=</code></p>
     <p><code>    +=</code></p>
     <p><code>    -=</code></p>
     <p><code>    &lt;&lt;=</code></p>
     <p><code>    &gt;&gt;=</code></p>
     <p><code>    &amp;=</code></p>
     <p><code>    ^=</code></p>
     <p><code>    |=</code></p>
     <p>Операторы присваивания в качестве левого операнда требуют <emphasis>lvalue</emphasis>, причем модифицируемого; это значит, что оно не может быть массивом, или иметь незавершенный тип, или быть функцией. Тип левого операнда, кроме того, не может иметь квалификатора <emphasis>const</emphasis>; и, если он является структурой или объединением, в них не должно быть элементов или подэлементов (для вложенных структур или объединений) с квалификаторами <emphasis>const.</emphasis></p>
     <p>Тип выражения присваивания соответствует типу его левого операнда, а значение равно значению его левого операнда после завершения присваивания.</p>
     <p>В простом присваивании с оператором = значение выражения замещает объект, к которому обращается <emphasis>lvalue</emphasis>. При этом должно выполняться одно из следующих условий: оба операнда имеют арифметический тип (если типы операндов разные, правый операнд приводится к типу левого операнда); оба операнда есть структуры или объединения одного и того же типа; один операнд есть указатель, а другой - указатель на <emphasis>void</emphasis>; левый операнд - указатель, а правый - константное выражение со значением 0; оба операнда - указатели на функции или объекты, имеющие одинаковый тип (за исключением возможного отсутствия <emphasis>const</emphasis> или <emphasis>volatile</emphasis> у правого операнда).</p>
     <p>Выражение E1 <emphasis>op</emphasis>= E2 эквивалентно выражению E1 = E1 <emphasis>op</emphasis>(E2) с одним исключением: E1 вычисляется только один раз.</p>
    </section>
    <section>
     <title>
      <p>A7.18. Оператор запятая</p>
     </title>
     <p><code><emphasis>выражение</emphasis>:</code></p>
     <p><code>    <emphasis>выражение-присваивания</emphasis></code></p>
     <p><code>    <emphasis>выражение</emphasis> , <emphasis>выражение-присваивания</emphasis></code></p>
     <p>Два выражения, разделенные запятой, вычисляются слева направо, и значение левого выражения отбрасывается. Тип и значение результата совпадают с типом и значением правого операнда. Вычисление всех побочных эффектов левого операнда завершается перед началом вычисления правого операнда. В контексте, в котором запятая имеет специальное значение, например в списках аргументов функций (A7.3.2) или в списках инициализаторов (A8.7) (здесь в качестве синтаксических единиц фигурируют выражения присваивания), оператор запятая может появиться только в группирующих скобках. Например, в</p>
     <p><code>f(a, (t=3, t+2), c)</code></p>
     <p>три аргумента, из которых второй имеет значение 5.</p>
    </section>
    <section>
     <title>
      <p>A7.19. Константные выражения</p>
     </title>
     <p>Синтаксически, константное выражение - это выражение с ограниченным подмножеством операторов:</p>
     <p><code><emphasis>константное-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>условное-выражение</emphasis></code></p>
     <p>При указании <emphasis>case</emphasis>-меток в переключателе, задании границ массивов и длин полей битов, на месте значений перечислимых констант и инициализаторов, а также в некоторых выражениях для препроцессора требуются выражения, вычисление которых приводит к константе.</p>
     <p>Константные выражения не могут содержать присваиваний, операторов инкрементирования и декрементирования, вызовов функций и операторов-запятых; перечисленные ограничения не распространяются на операнд оператора <emphasis>sizeof</emphasis>. Если требуется получить целочисленное константное выражение, то его операнды должны состоять из целых, перечислимых (<emphasis>enum</emphasis>), символьных констант и констант с плавающей точкой; операции приведения должны специфицировать целочисленный тип, а любая константа с плавающей точкой - приводиться к целому. Из этого следует, что в константном выражении не может быть массивов, операций косвенного обращения (раскрытия указателя), получения адреса и доступа к полям структуры. (Однако для <emphasis>sizeof</emphasis> возможны операнды любого вида.) </p>
     <p>Для константных выражений в инициализаторах допускается большая свобода; операндами могут быть константы любого типа, а к внешним или статическим объектам и внешним и статическим массивам, индексируемым константными выражениями, возможно применять унарный оператор <emphasis>&amp;</emphasis>. Унарный оператор <emphasis>&amp;</emphasis> может также неявно присутствовать при использовании массива без индекса или функции без списка аргументов. Вычисление инициализатора должно давать константу или адрес ранее объявленного внешнего или статического объекта плюс-минус константа.</p>
     <p>Меньшая свобода допускается для целочисленных константных выражений, используемых после <emphasis>#if</emphasis>: не разрешаются <emphasis>sizeof</emphasis>-выражения, константы типа <emphasis>enum</emphasis> и операции приведения типа. (см. A12.5.) </p>
    </section>
   </section>
   <section>
    <title>
     <p>A8. Объявления</p>
    </title>
    <section>
     <p>То, каким образом интерпретируется каждый идентификатор, специфицируется объявлениями; они не всегда резервируют память для описываемых ими идентификаторов. Объявления, резервирующие память, называются определениями и имеют следующий вид:</p>
     <p><code><emphasis>объявление</emphasis>:</code></p>
     <p><code>    <emphasis>спецификаторы-объявления список-инициализаторов-объявителей<sub>необ</sub></emphasis></code></p>
     <p>Объявители в <emphasis>списке-инициализаторов-объявителей</emphasis> содержат объявляемые идентификаторы; <emphasis>спецификаторы-объявления</emphasis> представляют собой последовательности, состоящие из спецификаторов типа и класса памяти.</p>
     <p><code><emphasis>спецификаторы-объявления</emphasis>:</code></p>
     <p><code>    <emphasis>спецификатор-класса-памяти спецификаторы-объявления<sub>необ</sub></emphasis></code></p>
     <p><code>    <emphasis>спецификатор-типа спецификаторы-объявления<sub>необ</sub></emphasis></code></p>
     <p><code>    <emphasis>квалификатор-типа спецификаторы-объявления<sub>необ</sub></emphasis></code></p>
     <p><code><emphasis>список-инициализаторов-объявителей</emphasis>:</code></p>
     <p><code>    <emphasis>инициализатор-объявитель</emphasis></code></p>
     <p><code>    <emphasis>список-инициализаторов-объявителей</emphasis> , <emphasis>инициализатор-объявитель</emphasis></code></p>
     <p><code><emphasis>инициализатор-объявитель</emphasis>:</code></p>
     <p><code>    <emphasis>объявитель</emphasis></code></p>
     <p><code>    <emphasis>объявитель</emphasis> = <emphasis>инициализатор</emphasis></code></p>
     <p>Объявители содержат подлежащие объявлению имена. Мы рассмотрим их позже, в A8.5. Объявление должно либо иметь по крайней мере один объявитель, либо его спецификатор типа должен определять тег структуры или объединения, либо - задавать элементы перечисления; пустое объявление недопустимо. </p>
    </section>
    <section>
     <title>
      <p>A8.1. Спецификаторы класса памяти</p>
     </title>
     <empty-line/>
     <p>Класс памяти специфицируется следующим образом:</p>
     <p><code><emphasis>спецификатор-класса-памяти</emphasis>:</code></p>
     <p><code>    auto</code></p>
     <p><code>    register</code></p>
     <p><code>    static</code></p>
     <p><code>    extern</code></p>
     <p><code>    typedef</code></p>
     <p>Смысл классов памяти обсуждался в A4. </p>
     <p>Спецификаторы <emphasis>auto</emphasis> и <emphasis>register</emphasis> дают объявляемым объектам класс автоматической памяти, и эти спецификаторы можно применять только внутри функции. Объявления с <emphasis>auto</emphasis> и <emphasis>register</emphasis> одновременно являются определениями и резервируют намять. Спецификатор <emphasis>register</emphasis> эквивалентен <emphasis>auto</emphasis>, но содержит подсказку, сообщающую, что в программе объявленные им объекты используются интенсивно. На регистрах может быть размещено лишь небольшое число объектов, причем определенного типа: указанные ограничения зависят от реализации. В любом случае к <emphasis>register</emphasis>- объекту нельзя применять (явно или неявно) унарный оператор <emphasis>&amp;</emphasis>. </p>
     <cite>
      <p>Новым является правило, согласно которому вычислять адрес объекта класса <emphasis>register</emphasis> нельзя, а класса <emphasis>auto</emphasis> можно. </p>
     </cite>
     <p>Спецификатор <emphasis>static</emphasis> дает объявляемым объектам класс статической памяти, он может использоваться и внутри, и вне функций. Внутри функции этот спецификатор вызывает выделение памяти и служит определением; его роль вне функций будет объяснена в A11.2.</p>
     <p>Объявление со спецификатором <emphasis>extern</emphasis>, используемое внутри функции, объявляет, что для объявляемого объекта где-то выделена память; о ее роли вне функций будет сказано в A11.2.</p>
     <p>Спецификатор <emphasis>typedef</emphasis> не резервирует никакой памяти и назван спецификатором класса памяти из соображений стандартности синтаксиса; речь об этом спецификаторе пойдет в A8.9.</p>
     <p>Объявление может содержать не более одного спецификатора класса памяти. Если он в объявлении отсутствует, то действуют следующие правила: считается, что объекты, объявляемые внутри функций, имеют класс <emphasis>auto</emphasis>; функции, объявляемые внутри функций, - класс <emphasis>extern</emphasis>; объекты и функции, объявляемые вне функций, - статические и имеют <emphasis>внешние связи</emphasis> (см. A10, A11).</p>
    </section>
    <section>
     <title>
      <p>А8.2. Спецификаторы типа</p>
     </title>
     <p>Спецификаторы типа определяются следующим образом: </p>
     <p><code><emphasis>спецификатор-типа</emphasis>:</code></p>
     <p><code>    void</code></p>
     <p><code>    char</code></p>
     <p><code>    short</code></p>
     <p><code>    int</code></p>
     <p><code>    long</code></p>
     <p><code>    float</code></p>
     <p><code>    double</code></p>
     <p><code>    signed</code></p>
     <p><code>    unsigned</code></p>
     <p><code>  <emphasis>структуры-или-объединения-спецификатор</emphasis></code></p>
     <p><code>  <emphasis>спецификатор-перечисления</emphasis></code></p>
     <p><code>  <emphasis>typedef-имя</emphasis></code></p>
     <p>Вместе с <emphasis>int</emphasis> допускается использование еще какого-то одного слова - <emphasis>long</emphasis> или <emphasis>short</emphasis>; причем сочетание <emphasis>long int</emphasis> имеет тот же смысл, что и просто <emphasis>long</emphasis>: аналогично <emphasis>short int</emphasis> - то же самое, что и <emphasis>short</emphasis>. Слово <emphasis>long</emphasis> может употребляться вместе с <emphasis>double</emphasis>. С <emphasis>int</emphasis> и другими его модификациями (<emphasis>short</emphasis>, <emphasis>long</emphasis> или <emphasis>char</emphasis>) разрешается употреблять одно из слов <emphasis>signed</emphasis> или <emphasis>unsigned</emphasis>. Любое из последних может использоваться самостоятельно, в этом случае подразумевается <emphasis>int</emphasis>. </p>
     <p>Спецификатор <emphasis>signed</emphasis> бывает полезен, когда требуется обеспечить, чтобы объекты типа <emphasis>char</emphasis> имели знак; его можно применять и к другим целочисленным типам, но в этих случаях он избыточен.</p>
     <p>За исключением описанных выше случаев объявление не может содержать более одного спецификатора типа. Если в объявлении нет ни одного спецификатора типа, то имеется в виду тип <emphasis>int</emphasis>.</p>
     <p>Для указания особых свойств объявляемых объектов предназначаются квалификаторы:</p>
     <p><code><emphasis>квалификатор-типа</emphasis>:</code></p>
     <p><code>    const</code></p>
     <p><code>    volatile</code></p>
     <p>Квалификаторы типа могут употребляться с любым спецификатором типа. Разрешается инициализировать <emphasis>const</emphasis>-объект, однако присваивать ему что-либо в дальнейшем запрещается. Смысл квалификатора <emphasis>volatile</emphasis> зависит от реализации. </p>
     <cite>
      <p>Средства <emphasis>const</emphasis> и <emphasis>volatile</emphasis> (изменчивый) введены стандартом ANSI. Квалификатор <emphasis>const</emphasis> применяется, чтобы разместить объекты в памяти, открытой только на чтение (ПЗУ), или чтобы способствовать возможной оптимизации. Назначение квалификатора <emphasis>volatile</emphasis> - подавить оптимизацию, которая без этого указания могла бы быть проведена. Например, в машинах, где адреса регистров ввода-вывода отображены на адресное пространство памяти, указатель на регистр некоторого устройства мог бы быть объявлен как <emphasis>volatile</emphasis>, чтобы запретить компилятору экономить очевидно избыточную ссылку через указатель. Компилятор может игнорировать указанные квалификаторы, однако обязан сигнализировать о явных попытках изменить значение <emphasis>const</emphasis>-объектов. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>A8.3. Объявления структур и объединений</p>
     </title>
     <p><emphasis>Структура</emphasis> - это объект, состоящий из последовательности именованных элементов различных типов. <emphasis>Объединение</emphasis> - объект, который в каждый момент времени содержит один из нескольких элементов различных типов. Объявления структур и объединений имеют один и тот же вид. </p>
     <p><code><emphasis>спецификатор структуры-или-объединения</emphasis>:</code></p>
     <p><code>    <emphasis>структуры-или-объединения идентификатор<sub>необ</sub></emphasis> { <emphasis>список-объявлений-структуры </emphasis>}</code></p>
     <p><code>    <emphasis>структуры-или-объединения идентификатор</emphasis></code></p>
     <p><code><emphasis>структура-или-объединение</emphasis>:</code></p>
     <p><code>    struct</code></p>
     <p><code>    union</code></p>
     <p>Список-объявлений-структуры является последовательностью объявлений элементов структуры или объединения: </p>
     <p><code><emphasis>список-объявлений-структуры</emphasis>:</code></p>
     <p><code>    <emphasis>объявление-структуры</emphasis></code></p>
     <p><code>    <emphasis>список-объявлений-структуры объявление-структуры</emphasis></code></p>
     <p><code><emphasis>объявление-структуры</emphasis>:</code></p>
     <p><code>    <emphasis>список-спецификаторов-квалификаторов список-структуры-объявителей</emphasis>;</code></p>
     <p><code><emphasis>список-спецификаторов-квалификаторов</emphasis>:</code></p>
     <p><code>    <emphasis>спецификатор-типа список-спецификаторов-квалификаторов<sub>необ</sub></emphasis></code></p>
     <p><code>    <emphasis>квалификатор-типа список-спецификаторов-квалификаторов<sub>необ</sub></emphasis></code></p>
     <p><code><emphasis>список-структуры-объявителей</emphasis>:</code></p>
     <p><code>    <emphasis>структуры-объявитель</emphasis></code></p>
     <p><code>    <emphasis>список-структуры-объявителей</emphasis> , <emphasis>структуры-объявитель</emphasis></code></p>
     <p>Обычно <emphasis>объявление-структуры</emphasis> является просто объявлением для элементов структуры или объединения. Элементы структуры, в свою очередь, могут состоять из заданного числа разрядов (битов). Такой элемент называется <emphasis>битовым полем</emphasis> или просто полем. Его размер отделяется от имени поля двоеточием: </p>
     <p><code><emphasis>структуры-объявитель</emphasis>:</code></p>
     <p><code>    <emphasis>объявитель</emphasis></code></p>
     <p><code>    <emphasis>объявитель<sub>необ</sub></emphasis> : <emphasis>константное-выражение</emphasis></code></p>
     <p>Спецификатор типа, имеющий вид </p>
     <p><code><emphasis>структуры-или-объединения идентификатор</emphasis> { <emphasis>список-объявлений-структуры</emphasis> }</code></p>
     <p>объявляет идентификатор <emphasis>тегом</emphasis> структуры или объединения, специфицированных списком. Последующее объявление в той же или внутренней области видимости может обращаться к тому же типу, используя в спецификаторе тег без списка: </p>
     <p><emphasis><code><emphasis>структуры-или-объединения идентификатор</emphasis></code></emphasis> </p>
     <p>Если спецификатор с тегом, но без списка появляется там, где тег не объявлен, специфицируется <emphasis>незавершенный тип</emphasis>. Объекты с незавершенным типом структуры или объединения могут упоминаться в контексте, где не требуется знать их размер - например в объявлениях (но не определениях) для описания указателя или создания <emphasis>typedef</emphasis>, но не в иных случаях. Тип становится завершенным при появлении последующего спецификатора с этим тегом, содержащего список объявлений. Даже в спецификаторах со списком объявляемый тип структуры или объединения является незавершенным внутри списка и становится завершенным только после появления символа }, заканчивающего спецификатор. </p>
     <p>Структура не может содержать элементов незавершенного типа. Следовательно, невозможно объявить структуру или объединение, которые содержат сами себя. Однако, кроме придания имени типу структуры или объединения, тег позволяет определять структуры, обращающиеся сами к себе; структура или объединение могут содержать указатели на самих себя, поскольку указатели на незавершенные типы объявлять можно.</p>
     <p>Особое правило применяется к объявлениям вида </p>
     <p><code><emphasis>структуры-или-объединения идентификатор </emphasis>;</code></p>
     <p>которые объявляют структуру или объединение, но не имеют списка объявления и объявителя. Даже если идентификатор имеет тег структуры или объединения во внешней области видимости (A11.1), это объявление делает идентификатор тегом новой структуры или объединения незавершенного типа во внутренней области видимости. </p>
     <cite>
      <p>Это невразумительное правило - новое в ANSI. Оно предназначено для взаимно рекурсивных структур, объявленных во внутренней области видимости, но теги которых могут быть уже объявлены во внешней области видимости. </p>
     </cite>
     <p>Спецификатор структуры или объединения со списком, но без тега создает уникальный тип, к которому можно обращаться непосредственно только в объявлении, частью которого он является.</p>
     <p>Имена элементов и тегов не конфликтуют друг с другом или обычными переменными. Имя элемента не может появляться дважды в одной и той же структуре или объединении, но тот же элемент можно использовать в разных структурах или объединениях.</p>
     <cite>
      <p>В первой редакции этой книги имена элементов структуры и объединения не связывались со своими родителями. Однако в компиляторах эта связь стала обычной задолго до появления стандарта ANSI. </p>
     </cite>
     <p>Элемент структуры или объединения, не являющийся полем, может иметь любой тип объекта. Поле (которое не имеет объявителя и, следовательно, может быть безымянным) имеет тип <emphasis>int</emphasis>, <emphasis>unsigned int</emphasis> или <emphasis>signed int</emphasis> и интерпретируется как объект целочисленного типа указанной в битах длины. Считается ли поле <emphasis>int</emphasis> знаковым или беззнаковым, зависит от реализации. Соседний элемент-поле упаковывается в ячейки памяти в зависимости от реализации в зависящем от реализации направлении. Когда следующее за полем другое поле не влезает в частично заполненную ячейку памяти, оно может оказаться разделенным между двумя ячейками, или ячейка может быть забита балластом. Безымянное поле нулевой ширины обязательно приводит к такой забивке, так что следующее поле начнется с края следующей ячейки памяти. </p>
     <cite>
      <p>Стандарт ANSI делает поля еще более зависимыми от реализации, чем в первой редакции книги. Чтобы хранить битовые поля в "зависящем от реализации" виде без квалификации, желательно прочитать правила языка. Структуры с битовыми полями могут служить переносимым способом для попытки уменьшить размеры памяти под структуру (вероятно, ценой увеличения кода программы и времени на доступ к полям) или непереносимым способом для описания распределения памяти на битовом уровне. Во втором случае необходимо понимать правила местной реализации. </p>
     </cite>
     <p>Элементы структуры имеют возрастающие по мере объявления элементов адреса. Элементы структуры, не являющиеся полями, выравниваются по границам адресов в зависимости от своего типа; таким образом, в структуре могут быть безымянные дыры. Если указатель на структуру приводится к типу указателя на ее первый элемент, результат указывает на первый элемент.</p>
     <p>Объединение можно представить себе как структуру, все элементы которой начинаются со смещением 0 и размеры которой достаточны для хранения любого из элементов. В любой момент времени в объединении хранится не больше одного элемента. Если указатель на объединение приводится к типу указателя на один из элементов, результат указывает на этот элемент.</p>
     <p>Вот простой пример объявления структуры:</p>
     <p><code>struct tnode {</code></p>
     <p><code>    char tword[20];</code></p>
     <p><code>    int count;</code></p>
     <p><code>    struct tnode *left;</code></p>
     <p><code>    struct tnode *right;</code></p>
     <p><code>};</code></p>
     <p>Эта структура содержит массив из 20 символов, число типа <emphasis>int</emphasis> и два указателя на подобную структуру. Если дано такое объявление, то </p>
     <p><code>struct tnode s, *sp;</code></p>
     <p>объявит <emphasis>s</emphasis> как структуру заданного вида, a <emphasis>sp</emphasis> - как указатель на такую структуру. Согласно приведенным определениям выражение </p>
     <p><code>sp-&gt;count</code></p>
     <p>обращается к элементу <emphasis>count</emphasis> в структуре, на которую указывает <emphasis>sp</emphasis>; </p>
     <p><code>s.left </code></p>
     <p>- указатель на левое поддерево в структуре <emphasis>s</emphasis>, а</p>
     <p><code>s.right-&gt;tword[0] </code></p>
     <p>- это первый символ из <emphasis>tword</emphasis> - элемента правого поддерева <emphasis>s</emphasis>.</p>
     <p>Вообще говоря, невозможно проконтролировать, тот ли используется элемент объединения, которому последний раз присваивалось значение. Однако гарантируется выполнение правила, облегчающего работу с элементами объединения: если объединение содержит несколько структур, начинающихся с общей для них последовательности данных, и если объединение в текущий момент содержит одну из этих структур, то к общей части данных разрешается обращаться через любую из указанных структур. Так, правомерен следующий фрагмент программы:</p>
     <p><code>union {</code></p>
     <p><code>    struct {</code></p>
     <p><code>        int type;</code></p>
     <p><code>    } n;</code></p>
     <empty-line/>
     <p><code>    struct {</code></p>
     <p><code>        int type;</code></p>
     <p><code>        int intnode;</code></p>
     <p><code>    } ni;</code></p>
     <empty-line/>
     <p><code>    struct {</code></p>
     <p><code>        int type;</code></p>
     <p><code>        float floatnode;</code></p>
     <p><code>    } nf;</code></p>
     <p><code>} u;</code></p>
     <empty-line/>
     <p><code>...</code></p>
     <empty-line/>
     <p><code>u.nf.type = FLOAT;</code></p>
     <p><code>u.nf.floatnode = 3.14;</code></p>
     <p><code>...</code></p>
     <empty-line/>
     <p><code>if (u.n.type == FLOAT)</code></p>
     <p><code>... sin(u.nf.floatnode) ...</code></p>
    </section>
    <section>
     <title>
      <p>A8.4. Перечисления</p>
     </title>
     <p><emphasis>Перечисления</emphasis> - это уникальный тип, значения которого покрываются множеством именованных констант, называемых перечислителями. Вид спецификатора перечисления заимствован у структур и объединений. </p>
     <p><code><emphasis>спецификатор-перечисления</emphasis>:</code></p>
     <p><code>    enum <emphasis>идентификатор<sub>необ</sub></emphasis> {<emphasis>список-перечислителей</emphasis>}</code></p>
     <p><code>    enum <emphasis>идентификатор</emphasis></code></p>
     <p><code><emphasis>список-перечислителей</emphasis>:</code></p>
     <p><code>    <emphasis>перечислитель</emphasis></code></p>
     <p><code>    <emphasis>список-перечислителей</emphasis> , <emphasis>перечислитель</emphasis></code></p>
     <p><code><emphasis>перечислитель</emphasis>:</code></p>
     <p><code>    <emphasis>идентификатор</emphasis> </code></p>
     <p><code>    <emphasis>идентификатор</emphasis> = <emphasis>константное-выражение</emphasis></code></p>
     <p>Идентификаторы, входящие в список перечислителей, объявляются константами типа <emphasis>int</emphasis> и могут употребляться везде, где требуется константа. Если в этом списке нет ни одного перечислителя со знаком =, то значения констант начинаются с 0 и увеличиваются на 1 по мере чтения объявления слева направо. Перечислитель со знаком = дает соответствующему идентификатору значение; последующие идентификаторы продолжают прогрессию от заданного значения.</p>
     <p>Имена перечислителей, используемые в одной области видимости, должны отличаться друг от друга и от имен обычных переменных, однако их значения могут и совпадать.</p>
     <p>Роль идентификатора в <emphasis>переч-спецификаторе</emphasis> аналогична роли тега структуры в <emphasis>структ-спецификаторе</emphasis>: он является именем некоторого конкретного перечисления. Правила для списков и переч-спецификаторов (с тегами и без) те же, что и для спецификаторов структур или объединений, с той лишь оговоркой, что элементы перечислений не бывают незавершенного типа; тег переч-спецификатора без списка перечислителей должен иметь в пределах области видимости спецификатор со списком.   </p>
     <cite>
      <p>В первой версии языка перечислений не было, но они уже несколько лет применяются. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>А8.5. Объявители</p>
     </title>
     <p>Объявители имеют следующий синтаксис: </p>
     <p><code><emphasis>объявитель</emphasis>:</code></p>
     <p><code>    <emphasis>указатель<sub>необ</sub> собственно-объявитель</emphasis></code></p>
     <p><code><emphasis>собственно-объявитель</emphasis>:</code></p>
     <p><code>    <emphasis>идентификатор</emphasis></code></p>
     <p><code>    (<emphasis>объявитель</emphasis>)</code></p>
     <p><code>    <emphasis>собственно-объявитель</emphasis> [<emphasis>константное-выражение<sub>необ</sub></emphasis>]</code></p>
     <p><code>    <emphasis>собственно-объявитель</emphasis> (<emphasis>список-типов-параметров</emphasis>)</code></p>
     <p><code>    <emphasis>собственно-объявитель</emphasis> (<emphasis>список-идентификаторов<sub>необ</sub></emphasis>)</code></p>
     <p><code><emphasis>указатель</emphasis>:</code></p>
     <p><code>    * <emphasis>список-квалификаторов-типа<sub>необ</sub></emphasis></code></p>
     <p><code>    * <emphasis>список-квалификаторов-типа<sub>необ</sub> указатель</emphasis></code></p>
     <p><code><emphasis>список-квалификаторов-типа</emphasis>:</code></p>
     <p><code>    <emphasis>квалификатор-типа</emphasis></code></p>
     <p><code>    <emphasis>список-квалификаторов-типа квалификатор-типа</emphasis></code></p>
     <p>У структуры объявителя много сходных черт со структурой подвыражений, поскольку в объявителе, как и в подвыражении, допускаются операции косвенного обращения, обращения к функции и получения элемента массива (с тем же порядком применения). </p>
    </section>
    <section>
     <title>
      <p>A8.6. Что означают объявители</p>
     </title>
     <section>
      <p>Список объявителей располагается сразу после спецификаторов типа и указателя класса памяти. Главный элемент любого объявителя - это объявляемый им идентификатор; в простейшем случае объявитель из него одного и состоит, что отражено в первой строке продукции грамматики с именем <emphasis>собственно- объявитель</emphasis>. Спецификаторы класса памяти относятся непосредственно к идентификатору, а его тип зависит от вида объявителя. Объявитель следует воспринимать как утверждение: если в выражении идентификатор появляется в том же контексте, что и в объявителе, то он обозначает объект специфицируемого типа.</p>
      <p>Если соединить спецификаторы объявления, относящиеся к типу (A8.2), и некоторый конкретный объявитель, то объявление примет вид "T D", где <emphasis>T</emphasis> - тип, a <emphasis>D</emphasis> - объявитель. Эта запись индуктивно придает тип идентификатору любого объявителя.</p>
      <p>В объявлении T D, где <emphasis>D</emphasis> - просто идентификатор, тип идентификатора есть <emphasis>T</emphasis>. </p>
      <p>В объявлении T D, где <emphasis>D</emphasis> имеет вид</p>
      <p><code>( D1 )</code></p>
      <p>тип идентификатора в <emphasis>D1</emphasis> тот же, что и в <emphasis>D</emphasis>. Скобки не изменяют тип, но могут повлиять на результаты его "привязки" к идентификаторам в сложных объявителях. </p>
     </section>
     <section>
      <title>
       <p>A8.6.1. Объявители указателей</p>
      </title>
      <p>В объявления T D, где <emphasis>D</emphasis> имеет вид</p>
      <p><code>* <emphasis>список-квалификаторов-типа</emphasis><sub><emphasis>необ</emphasis></sub> D1</code></p>
      <p>а тип идентификатора объявления T D1 есть "<emphasis>модификатор-типа T</emphasis>", тип идентификатора <emphasis>D</emphasis> есть "<emphasis>модификатор-типа список-квалификаторов-типа указатель на T</emphasis>". Квалификаторы, следующие за *, относятся к самому указателю, а не к объекту, на который он указывает. Рассмотрим, например, объявление </p>
      <p><code>int *ap[];</code></p>
      <p>Здесь <emphasis>ap[]</emphasis> играет роль <emphasis>D1</emphasis>; объявление <emphasis>int ap[]</emphasis> следует расшифровать (см. ниже) как "массив из <emphasis>int</emphasis>": список квалификаторов типа здесь пуст, а модификатор типа есть "<emphasis>массив из</emphasis>". Следовательно, на самом деле объявление <emphasis>ap</emphasis> гласит: "массив из указателей на <emphasis>int</emphasis>". Вот еще примеры объявлений: </p>
      <p><code>int i, *pi, *const cpi = &amp;i;</code></p>
      <p><code>const int ci = 3, *pci;</code></p>
      <p>В них объявляются целое <emphasis>i</emphasis> и указатель на целое <emphasis>pi</emphasis>. Значение указателя <emphasis>cpi</emphasis> неизменно; <emphasis>cpi</emphasis> всегда будет указывать в одно и то же место, даже если значение, на которое он указывает, станет иным. Целое <emphasis>ci</emphasis> есть константа, оно измениться не может (хотя может инициализироваться, как в данном случае). Тип указателя <emphasis>pci</emphasis> произносится как "указатель на <emphasis>const int</emphasis>"; сам указатель можно изменить; при этом он будет указывать на другое место, но значение, на которое он будет указывать, с помощью <emphasis>pci</emphasis> изменить нельзя.</p>
     </section>
     <section>
      <title>
       <p>А8.6.2. Объявители массивов</p>
      </title>
      <p>В объявления T D, где D имеет вид </p>
      <p><code>D1 [<emphasis>константное-выражение</emphasis><sub><emphasis>необ </emphasis></sub>]</code></p>
      <p>и где тип идентификатора объявления T D1 есть "<emphasis>модификатор-типа Т</emphasis>", тип идентификатора D есть "<emphasis>модификатор-типа</emphasis> массив из T". Если константное выражение присутствует, то оно должно быть целочисленным и больше 0. Если константное выражение, специфицирующее количество элементов в массиве, отсутствует, то массив имеет незавершенный тип. </p>
      <p>Массив можно конструировать из объектов арифметического типа, указателей, структур и объединений, а также других массивов (генерируя при этом многомерные массивы). Любой тип, из которого конструируется массив, должен быть завершенным, он не может быть, например, структурой или массивом незавершенного типа. Это значит, что для многомерного массива пустой может быть только первая размерность. Незавершенный тип массива получает свое завершение либо в другом объявлении этого массива (A10.2), либо при его инициализации (A8.7). Например, запись </p>
      <p><code>float fa[17], *afp[17];</code></p>
      <p>объявляет массив из чисел типа <emphasis>float</emphasis> и массив из указателей на числа типа <emphasis>float</emphasis>. Аналогично </p>
      <p><code>static int x3d[3][5][7];</code></p>
      <p>объявляет статический трехмерный массив целых размера 3 x 5 x 7. На самом деле, если быть точными, <emphasis>x3d</emphasis> является массивом из трех элементов, каждый из которых есть массив из пяти элементов, содержащих по 7 значений типа <emphasis>int</emphasis>.</p>
      <p>Операция индексирования E1[E2] определена так, что она идентична операции *(E1+E2). Следовательно, несмотря на асимметричность записи, индексирование - коммутативная операция. Учитывая правила преобразования, применяемые для оператора + и массивов (A6.6, A7.1, A7.7), можно сказать, что если E1 - массив, а E2 - целое, то E1[E2] обозначает E2-й элемент массива E1.</p>
      <p>Так, x3d[i][j][k] означает то же самое, что и *(x3d[i][j]+k). Первое подвыражение, x3d[i][j], согласно A7.1, приводится к типу "указатель на массив целых"; по A7.7 сложение включает умножение на размер объекта типа <emphasis>int</emphasis>. Из этих же правил следует, что массивы запоминаются "построчно" (последние индексы меняются чаще) и что первая размерность в объявлении помогает определить количество памяти, занимаемой массивом, однако в вычислении адреса элемента массива участия не принимает. </p>
     </section>
     <section>
      <title>
       <p>А8.6.3. Объявители функций</p>
      </title>
      <empty-line/>
      <p>В новом способе объявление функции T D, где D имеет вид </p>
      <p><code>D1 ( <emphasis>список-типов-параметров </emphasis>)</code></p>
      <p>и тип идентификатора объявления T D1 есть "<emphasis>модификатор-типа</emphasis> T", тип идентификатора в D есть "<emphasis>модификатор-типа</emphasis> функция с аргументами <emphasis>список-типов- параметров</emphasis>, возвращающая T". Параметры имеют следующий синтаксис: </p>
      <p><code><emphasis>список-типов-параметров</emphasis>:</code></p>
      <p><code>    <emphasis>список-параметров</emphasis></code></p>
      <p><code>    <emphasis>список-параметров</emphasis> , ...</code></p>
      <p><code><emphasis>список-параметров</emphasis>:</code></p>
      <p><code>    <emphasis>объявление-параметра</emphasis></code></p>
      <p><code>    <emphasis>список-параметров</emphasis>, <emphasis>объявление-параметра</emphasis></code></p>
      <p><code><emphasis>объявление-параметра</emphasis>:</code></p>
      <p><code>    <emphasis>спецификаторы-объявления объявитель</emphasis></code></p>
      <p><code>    <emphasis>спецификатор-объявления абстрактный-объявитель<sub>необ</sub></emphasis></code></p>
      <p>При новом способе объявления функций список параметров специфицирует их типы, а если функция вообще не имеет параметров, на месте списка типов указывается одно слово - <emphasis>void</emphasis>. Если список типов параметров заканчивается многоточием ",...", то функция может иметь больше аргументов, чем число явно описанных параметров. (См. A7.3.2.)</p>
      <p>Типы параметров, являющихся массивами и функциями, заменяются на указатели в соответствии с правилами преобразования параметров (A10.1). Единственный спецификатор класса памяти, который разрешается использовать в объявлении параметра, - это <emphasis>register</emphasis>, однако он игнорируется, если объявитель функции не является заголовком ее определения. Аналогично, если объявители в объявлениях параметров содержат идентификаторы, а объявитель функции не является заголовком определения функции, то эти идентификаторы тотчас же выводятся из текущей области видимости. </p>
      <p>При старом способе объявление функции T D, где D имеет вид</p>
      <p><code>D1 ( <emphasis>список-идентификаторов</emphasis><sub><emphasis>необ </emphasis></sub>)</code></p>
      <p>и тип идентификатора объявления T D1 есть "<emphasis>модификатор-типа</emphasis> Т", тип идентификатора в D есть "<emphasis>модификатор-типа</emphasis> функция от неспецифицированных аргументов, возвращающая Т". Параметры, если они есть, имеют следующий вид: </p>
      <p><code><emphasis>список-идентификаторов</emphasis>:</code></p>
      <p><code>    <emphasis>идентификатор</emphasis></code></p>
      <p><code>    <emphasis>список-идентификаторов </emphasis>, <emphasis>идентификатор</emphasis></code></p>
      <p>При старом способе, если объявитель функции не используется в качестве заголовка определения функции (A10.1), список идентификаторов должен отсутствовать. Никакой информации о типах параметров в объявлениях не содержится.</p>
      <p>Например, объявление</p>
      <p><code>int f(), *fpi(), (*pfi)();</code></p>
      <p>объявляет функцию <emphasis>f</emphasis>, возвращающую число типа <emphasis>int</emphasis>, функцию <emphasis>fpi</emphasis>, возвращающую указатель на число типа <emphasis>int</emphasis>, и указатель <emphasis>pfi</emphasis> на функцию, возвращающую число типа <emphasis>int</emphasis>. Ни для одной функции в объявлении не указаны типы параметров; все функции описаны старым способом. </p>
      <p>Вот как выглядит объявление в новой записи:</p>
      <p><code>int strcpy(char *dest, const char *source), rand(void);</code></p>
      <p>Здесь <emphasis>strcpy</emphasis> - функция с двумя аргументами, возвращающая значение типа <emphasis>int</emphasis>; первый аргумент - указатель на значение типа <emphasis>char</emphasis>, а второй - указатель на неизменяющееся значение типа <emphasis>char</emphasis>. Имена параметров играют роль хороших комментариев. Вторая функция, <emphasis>rand</emphasis>, аргументов не имеет и возвращает <emphasis>int</emphasis>.</p>
      <cite>
       <p>Объявители функций с прототипами параметров - наиболее важное нововведение ANSI-стандарта. В сравнении со старым способом, принятым в первой редакции языка, они позволяют проверять и приводить к нужному типу аргументы во всех вызовах. Следует однако отметить, что их введение привнесло в язык некоторую сумятицу и необходимость согласования обеих форм. Чтобы обеспечить совместимость, потребовались некоторые "синтаксические уродства", а именно <emphasis>void</emphasis>, для явного указания на отсутствие параметров.</p>
       <p>Многоточие ", ..." применительно к функциям с варьируемым числом аргументов - также новинка, которая вместе со стандартным заголовочным файлом макросов <strong>&lt;stdarg.h&gt;</strong> формализует неофициально используемый, но официально запрещенный в первой редакции механизм. Указанные способы записи заимствованы из языка C++. </p>
      </cite>
     </section>
    </section>
    <section>
     <title>
      <p>A8.7. Инициализация</p>
     </title>
     <p>С помощью иниц-объявителя можно указать начальное значение объявляемого объекта. Инициализатору, представляющему собой выражение или список инициализаторов, заключенный в фигурные скобки, предшествует знак =. Этот список может завершаться запятой; ее назначение сделать форматирование более четким. </p>
     <p><code><emphasis>инициализатор</emphasis>:</code></p>
     <p><code>    <emphasis>выражение-присваивания</emphasis></code></p>
     <p><code>    { <emphasis>список-инициализаторов</emphasis> }</code></p>
     <p><code>    { <emphasis>список-инициализаторов</emphasis>, }</code></p>
     <p><code><emphasis>список-инициализаторов</emphasis>:</code></p>
     <p><code>    <emphasis>инициализатор</emphasis></code></p>
     <p><code>    <emphasis>список-инициализаторов</emphasis> , <emphasis>инициализатор</emphasis></code></p>
     <p>В инициализаторе статического объекта или массива все выражения должны быть константными (A7.19). Если инициализатор <emphasis>auto</emphasis>- и <emphasis>register</emphasis>-объекта или массива находится в списке, заключенном в фигурных скобки, то входящие в него выражения также должны быть константными. Однако в случае автоматического объекта с одним выражением инициализатор не обязан быть константным выражением, он просто должки иметь соответствующий объекту тип.</p>
     <cite>
      <p>В первой редакции не разрешалась инициализация автоматических структур, объединений и массивов. ANSI-стандарт позволяет это; однако, если инициализатор не может быть представлен одним простым выражением, инициализация может быть выполнена только с помощью константных конструкций. </p>
     </cite>
     <p>Статический объект, инициализация которого явно не указана, инициализируется так, как если бы ему (или его элементам) присваивалась константа 0. Начальное значение автоматического объекта, явным образом не инициализированного, не определено.</p>
     <p>Инициализатор указателя или объекта арифметического типа - это одно выражение (возможно, заключенное в фигурные скобки), которое присваивается объекту.</p>
     <p>Инициализатор структуры - это либо выражение того же структурного типа, либо заключенные в фигурные скобки инициализаторы ее элементов, заданные по порядку. Безымянные битовые поля игнорируются и не инициализируются. Если инициализаторов в списке меньше, чем элементов, то оставшиеся элементы инициализируются нулем. Инициализаторов не должно быть больше числа элементов.</p>
     <p>Инициализатор массива - это список инициализаторов его элементов, заключенный в фигурные скобки. Если размер массива не известен, то он считается равным числу инициализаторов, при этом тип его становится завершенным. Если размер массива известен, то число инициализаторов не должно превышать числа его элементов; если инициализаторов меньше, оставшиеся элементы обнуляются.</p>
     <p>Как особый выделен случай инициализации массива символов. Последний можно инициализировать с помощью строкового литерала; символы инициализируют элементы массива в том порядке, как они заданы в строковом литерале. Точно так же, с помощью литерала из расширенного набора символов (A2.6), можно инициализировать массив типа <emphasis>wchar_t</emphasis>. Если размер массива не известен, то он определяется числом символов в строке, включая и завершающий NULL-символ; если размер массива известен, то число символов в строке, не считая завершающего NULL-символа, не должно превышать его размера. </p>
     <p>Инициализатором объединения может быть либо выражение того же типа, либо заключенный в фигурные скобки инициализатор его первого элемента. </p>
     <cite>
      <p>В первой версии языка не позволялось инициализировать объединения. Правило "первого элемента" не отличается изяществом, однако не требует нового синтаксиса. Стандарт ANSI проясняет еще и семантику не инициализируемых явно объединений. </p>
     </cite>
     <p>Введем для структуры и массива обобщенное имя: <emphasis>агрегат</emphasis>. Если агрегат содержит элементы агрегатного типа, то правила инициализации применяются рекурсивно. Фигурные скобки в некоторых случаях инициализации можно опускать. Если инициализатор элемента агрегата, который сам является агрегатом, начинается с левой фигурной скобки, то этот подагрегат инициализируется последующим списком разделенных запятыми инициализаторов; считается ошибкой, если количество инициализаторов подагрегата превышает число его элементов. Если, однако, инициализатор подагрегата не начинается с левой фигурной скобки, то чтобы его инициализировать, нужно отсчитать соответствующее число элементов из списка; при этом остальные элементы инициализируются следующими инициализаторами агрегата, для которого данный подагрегат является частью. </p>
     <p>Например</p>
     <p><code>int x[] = { 1, 3, 5 };</code></p>
     <p>объявляет и инициализирует <emphasis>x</emphasis> как одномерный массив с тремя элементами, поскольку размер не был указан, а список состоит из трех инициализаторов. </p>
     <p><code>float y[4][3] = {</code></p>
     <p><code>    { 1, 3, 5 },</code></p>
     <p><code>    { 2, 4, 6 },</code></p>
     <p><code>    { 3, 5, 7 },</code></p>
     <p><code>};</code></p>
     <p>представляет собой инициализацию с полным набором фигурных скобок: 1, 3 и 5 инициализируют первую строку в массиве у[0], т. е. y[0][0], у[0][1] и y[0][2]. Аналогично инициализируются следующие две строки: y[1] и y[2]. Инициализаторов не хватило на весь массив, поэтому элементы строки y[3] будут нулевыми. В точности тот же результат был бы достигнут с помощью следующего объявления:</p>
     <p><code>float у[4][3] = { 1, 3, 5, 2, 4, 6, 3, 5, 7 };</code></p>
     <p>Инициализатор для <emphasis>y</emphasis> начинается с левой фигурной скобки, но для y[0] скобки нет, поэтому из списка будут взяты три элемента. Аналогично по три элемента будут взяты для y[1], а затем и для y[2]. В</p>
     <p><code>float у[4][3] = {</code></p>
     <p><code>    { 1 }, { 2 }, { 3 }, { 4 }</code></p>
     <p><code>};</code></p>
     <p>инициализируется первый столбец матрицы <emphasis>y</emphasis>, все же другие элементы остаются нулевыми.</p>
     <p>Наконец, </p>
     <p><code>char msg[] = "Синтаксическая ошибка в строке %s\n";</code></p>
     <p>представляет собой пример массива символов, элементы которого инициализируются с помощью строки; в его размере учитывается и завершающий NULL-символ. </p>
    </section>
    <section>
     <title>
      <p>A8.8. Имена типов</p>
     </title>
     <p>В ряде случаев возникает потребность в применении имени типа данных (например при явном приведении к типу, в указании типов параметров внутри объявлений функций, в аргументе оператора <emphasis>sizeof</emphasis>). Эта потребность реализуется с помощью <emphasis>имени типа</emphasis>, определение которого синтаксически почти совпадает с объявлением объекта того же типа. Оно отличается от объявления лишь тем, что не содержит имени объекта.</p>
     <p><code><emphasis>имя-типа</emphasis>:</code></p>
     <p><code>    <emphasis>список-спецификаторов-квалификаторов абстрактный-объявитель<sub>необ</sub></emphasis></code></p>
     <p><code><emphasis>абстрактный-объявитель</emphasis>:</code></p>
     <p><code>    <emphasis>указатель</emphasis></code></p>
     <p><code>    <emphasis>указатель<sub>необ</sub></emphasis> собственно-абстрактный-объявитель</code></p>
     <p><code><emphasis>собственно-абстрактный-объявитель</emphasis>:</code></p>
     <p><code>    ( <emphasis>абстрактный-объявитель</emphasis> )</code></p>
     <p><code>    <emphasis>собственно-абстрактный-объявитель<sub>необ </sub></emphasis>[ <emphasis>константное-выражение<sub>необ </sub></emphasis>]</code></p>
     <p><code>    <emphasis>собственно-абстрактный-объявитель<sub>необ </sub></emphasis>( <emphasis>список-типов-параметров<sub>необ </sub></emphasis>)</code></p>
     <p>Можно указать одно-единственное место в абстрактном объявителе, где мог бы оказаться идентификатор, если бы данная конструкция была полноценным объявителем. Именованный тип совпадает с типом этого "невидимого идентификатора". Например</p>
     <p><code>intint *int *[3]int (*)[]int *()int (*[])(void)</code></p>
     <p>соответственно обозначают типы <emphasis>int</emphasis>, "указатель на <emphasis>int</emphasis>", "массив из трех указателей на <emphasis>int</emphasis>", "указатель на массив из неизвестного количества <emphasis>int</emphasis>", "функция неизвестного количества параметров, возвращающая указатель на <emphasis>int</emphasis>", "массив неизвестного количества указателей на функции без параметров, каждая из которых возвращает <emphasis>int</emphasis>". </p>
    </section>
    <section>
     <title>
      <p>А8.9. Объявление <emphasis>typedef</emphasis></p>
     </title>
     <p>Объявления, в которых спецификатор класса памяти есть <emphasis>typedef</emphasis>, не объявляют объектов - они определяют идентификаторы, представляющие собой имена типов. Эти идентификаторы называются <emphasis>typedef</emphasis>-именами.</p>
     <p><code><emphasis>typedef-имя</emphasis>:</code></p>
     <p><code>    <emphasis>идентификатор</emphasis></code></p>
     <p>Объявление <emphasis>typedef</emphasis> приписывает тип каждому имени своего объявителя обычным способом (см. A8.6.). С этого момента <emphasis>typedef</emphasis>-имя синтаксически эквивалентно ключевому слову спецификатора типа, обозначающему связанный с ним тип. Например, после</p>
     <p><code>typedef long Blockno, *Blockptr;</code></p>
     <p><code>typedef struct { double r, theta; } Complex;</code></p>
     <p>допустимы следующие объявления: </p>
     <p><code>Blockno b;</code></p>
     <p><code>extern Blockptr bp;</code></p>
     <p><code>Complex z, *zp;</code></p>
     <p><emphasis>b</emphasis> принадлежит типу <emphasis>long</emphasis>, <emphasis>bp</emphasis> - типу "указатель на <emphasis>long</emphasis>"; <emphasis>z</emphasis> - это структура заданного вида, a <emphasis>zp</emphasis> - принадлежит типу "указатель на такую структуру".</p>
     <p>Объявление <emphasis>typedef</emphasis> не вводит новых типов, оно только дает имена типам, которые могли бы быть специфицированы и другим способом. Например, <emphasis>b</emphasis> имеет тот же тип, что и любой другой объект типа <emphasis>long</emphasis>.</p>
     <p><emphasis>typedef</emphasis>-имена могут быть перекрыты другими определениями во внутренней области видимости, но при условии, что в них присутствует указание типа. Например</p>
     <p><code>extern Blockno;</code></p>
     <p>не переобъявляет Blockno, а вот</p>
     <p><code>extern int Blockno;</code></p>
     <p>переобъявляет.</p>
    </section>
    <section>
     <title>
      <p>A8.10. Эквивалентность типов</p>
     </title>
     <p>Два списка спецификаторов типа эквивалентны, если они содержат одинаковый набор спецификаторов типа с учетом синонимичности названий (например, <emphasis>long</emphasis> и <emphasis>int long</emphasis> считаются одинаковыми типами). Структуры, объединения и перечисления с разными тегами считаются разными, а каждое безтеговое объединение, структура или перечисление представляет собой уникальный тип.</p>
     <p>Два типа считаются совпадающими, если их абстрактные объявители (A8.8) после замены всех <emphasis>typedef</emphasis>-имен их типами и выбрасывания имен параметров функций составят эквивалентные списки спецификаторов типов. При сравнении учитываются размеры массивов и типы параметров функция. </p>
    </section>
   </section>
   <section>
    <title>
     <p>A9. Инструкции</p>
    </title>
    <section>
     <p>За исключением оговоренных случаев инструкции выполняются том порядке, как они написаны. Инструкции не имеют значений и выполняются, чтобы произвести определенные действия. Все виды инструкций можно разбить на несколько групп: </p>
     <p><code><emphasis>инструкция</emphasis>:</code></p>
     <p><code>    <emphasis>помеченная-инструкция</emphasis></code></p>
     <p><code>    <emphasis>инструкция-выражение</emphasis></code></p>
     <p><code>    <emphasis>составная-инструкция</emphasis></code></p>
     <p><code>    <emphasis>инструкция-выбора</emphasis></code></p>
     <p><code>    <emphasis>циклическая-инструкция</emphasis></code></p>
     <p><code>    <emphasis>инструкция-перехода</emphasis></code></p>
    </section>
    <section>
     <title>
      <p>A9.1. Помеченные инструкции</p>
     </title>
     <p>Инструкции может предшествовать метка.</p>
     <p><code><emphasis>помеченная-инструкция</emphasis>:</code></p>
     <p><code>    <emphasis>идентификатор</emphasis> : <emphasis>инструкция</emphasis></code></p>
     <p><code>    case <emphasis>константное-выражение</emphasis> : <emphasis>инструкция</emphasis></code></p>
     <p><code>    default : <emphasis>инструкция</emphasis></code></p>
     <p>Метка, состоящая из идентификатора, одновременно служит и объявлением этого идентификатора. Единственное назначение идентификатора-метки - указать место перехода для <emphasis>goto</emphasis>. Областью видимости идентификатора-метки является текущая функция. Так как метки имеют свое собственное пространство имен, они не "конфликтуют" с другими идентификаторами и не могут быть перекрыты (см. A11.1.).</p>
     <p><emphasis>case</emphasis>-метки и <emphasis>default</emphasis>-метки используются в инструкции <emphasis>switch</emphasis> (A9.4). Константное выражение в <emphasis>case</emphasis> должно быть целочисленным.</p>
     <p>Сами по себе метки не изменяют порядка вычислений.</p>
    </section>
    <section>
     <title>
      <p>A9.2. Инструкция-выражение</p>
     </title>
     <p>Наиболее употребительный вид инструкции - это инструкция-выражение.</p>
     <p><code><emphasis>инструкция-выражение</emphasis>:</code></p>
     <p><code>    <emphasis>выражение<sub>необ</sub></emphasis> ;</code></p>
     <p>Чаще всего инструкция-выражение - это присваивание или вызов функции. Все действия, реализующие побочный эффект выражения, завершаются, прежде чем начинает выполняться следующая инструкция. Если выражение в инструкции опущено, то она называется пустой; пустая инструкция часто используется для обозначения пустого тела циклической инструкции или в качестве места для метки.</p>
    </section>
    <section>
     <title>
      <p>A9.3. Составная инструкция</p>
     </title>
     <p>Так как в местах, где по синтаксису полагается одна инструкция, иногда возникает необходимость выполнить несколько, предусматривается возможность задания составной инструкции (которую также называют блоком). Тело определения функции есть составная инструкция; </p>
     <p><code><emphasis>составная-инструкция</emphasis>:</code></p>
     <p><code>    { <emphasis>список-объявлений список-инструкций<sub>необ</sub></emphasis> }</code></p>
     <p><code><emphasis>список-объявлений</emphasis>:</code></p>
     <p><code>    <emphasis>объявление</emphasis></code></p>
     <p><code>    <emphasis>список-объявлений объявление</emphasis></code></p>
     <p><code><emphasis>список-инструкций</emphasis>:</code></p>
     <p><code>    <emphasis>инструкция</emphasis></code></p>
     <p><code>    <emphasis>список-инструкций инструкция</emphasis></code></p>
     <p>Если идентификатор из списка объявлений находился в области видимости объемлющего блока, то действие внешнего объявления при входе внутрь данного блока приостанавливается (A11.1), а после выхода из него возобновляется. Внутри блока идентификатор может быть объявлен только один раз. Для каждого отдельного пространства имен эти правила действуют независимо (A11); идентификаторы из разных пространств имен всегда различны.</p>
     <p>Инициализация автоматических объектов осуществляется при каждом входе в блок и продолжается по мере продвижения по объявителям. При передаче управления внутрь блока никакие инициализации не выполняются. Инициализации статических объектов осуществляются только один раз перед запуском программы.  </p>
    </section>
    <section>
     <title>
      <p>A9.4. Инструкции выбора</p>
     </title>
     <p>Инструкции выбора осуществляют отбор одной из нескольких альтернатив, определяющих порядок выполнения инструкций. </p>
     <p><code><emphasis>инструкция-выбора</emphasis>:</code></p>
     <p><code>    if ( <emphasis>выражение</emphasis> ) <emphasis>инструкция</emphasis></code></p>
     <p><code>    if ( <emphasis>выражение</emphasis> ) <emphasis>инструкция</emphasis> else <emphasis>инструкция</emphasis></code></p>
     <p><code>    switch ( <emphasis>выражение</emphasis> ) <emphasis>инструкция</emphasis></code></p>
     <p>Оба вида <emphasis>if</emphasis>-инструкций содержат выражение, которое должно иметь арифметический тип или тип указателя. Сначала вычисляется выражение со всеми его побочными эффектами, результат сравнивается с 0. В случае несовпадения с 0 выполняется первая подинструкция. В случае совпадения с 0 для второго типа <emphasis>if</emphasis> выполняется вторая подинструкция. Связанная со словом <emphasis>else</emphasis> неоднозначность разрешается тем, что слово <emphasis>else</emphasis> соотносят с последней еще не имеющей <emphasis>else if</emphasis>-инструкцией, расположенной в одном с этим <emphasis>else</emphasis> блоке и на одном уровне вложенности блоков.</p>
     <p>Инструкция <emphasis>switch</emphasis> вызывает передачу управления на одну из нескольких инструкций в зависимости от значения выражения, которое должен иметь целочисленный тип.</p>
     <p>Управляемая с помощью <emphasis>switch</emphasis> подинструкция обычно составная. Любая инструкция внутри этой подинструкции может быть помечена одной или несколькими <emphasis>case</emphasis>-метками (A9.1). Управляющее выражение подвергается целочисленному повышению (A6.1), а <emphasis>case</emphasis>-константы приводятся к повышенному типу. После такого преобразования никакие две <emphasis>case</emphasis>-константы в одной инструкции <emphasis>switch</emphasis> не должны иметь одинаковых значений. Co <emphasis>switch</emphasis>-инструкцией может быть связано не более одной <emphasis>default</emphasis>-метки. Конструкции <emphasis>switch</emphasis> допускается вкладывать друг в друга; <emphasis>case</emphasis> и <emphasis>default</emphasis>-метки относятся к самой внутренней <emphasis>switch</emphasis>-инструкции из тех, которые их содержат.</p>
     <p>Инструкция <emphasis>switch</emphasis> выполняется следующим образом. Вычисляется выражение со всеми побочными эффектами, и результат сравнивается с каждой <emphasis>case</emphasis>-константой. Если одна из <emphasis>case</emphasis>-констант равна значению выражения, управление переходит на инструкцию с соответствующей <emphasis>case</emphasis>-меткой. Если ни с одной из <emphasis>case</emphasis>-констант нет совпадения, управление передается на инструкцию с <emphasis>default</emphasis>-меткой, если такая имеется, в противном случае ни одна из подинструкций <emphasis>switch</emphasis> не выполняется.</p>
     <cite>
      <p>В первой версии языка требовалось, чтобы выражение и <emphasis>case</emphasis>-константы в <emphasis>switch</emphasis> были типа <emphasis>int</emphasis>. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>A9.5. Циклические инструкции</p>
     </title>
     <p>Циклические инструкции специфицируют циклы.</p>
     <p><code><emphasis>циклическая-инструкция</emphasis>:</code></p>
     <p><code>    while (<emphasis>выражение</emphasis>) <emphasis>инструкция</emphasis></code></p>
     <p><code>    do <emphasis>инструкция</emphasis> while (<emphasis>выражение</emphasis>)</code></p>
     <p><code>    for (<emphasis>выражение<sub>необ</sub></emphasis> ; <emphasis>выражение<sub>необ</sub></emphasis> ; <emphasis>выражение<sub>необ</sub></emphasis> ) <emphasis>инструкция</emphasis></code></p>
     <p>В инструкциях <emphasis>while</emphasis> и <emphasis>do</emphasis> выполнение подинструкций повторяется до тех пор, пока значение выражения не станет нулем. Выражение должно иметь арифметический тип или тип указателя. В <emphasis>while</emphasis> вычисление выражения со всеми побочными эффектами и проверка осуществляются перед каждым выполнением инструкции, a в <emphasis>do</emphasis> - после.</p>
     <p>В инструкции <emphasis>for</emphasis> первое выражение вычисляется один раз, тем самым осуществляется инициализация цикла. На тип этого выражения никакие ограничения не накладываются. Второе выражение должно иметь арифметический тип или тип указателя; оно вычисляется перед каждой итерацией. Как только его значение становится равным 0, <emphasis>for</emphasis> прекращает свою работу. Третье выражение вычисляется после каждой итерации и, следовательно, выполняет повторную инициализацию цикла. Никаких ограничений на его тип нет. Побочные эффекты всех трех выражений заканчиваются по завершении их вычислений. Если подинструкция не содержит в себе <emphasis>continue</emphasis>) то </p>
     <p><code>for ( <emphasis>выражение<sub>1</sub></emphasis> ; <emphasis>выражение<sub>2</sub></emphasis> ; <emphasis>выражение<sub>З </sub></emphasis>) <emphasis>инструкция</emphasis></code></p>
     <p>эквивалентно конструкции</p>
     <p><code><emphasis>выражение<sub>1</sub></emphasis>;</code></p>
     <p><code>    while (<emphasis>выражение<sub>2</sub></emphasis>) {</code></p>
     <p><code>        <emphasis>инструкция</emphasis></code></p>
     <p><code>        <emphasis>выражение<sub>З</sub></emphasis>;</code></p>
     <p><code>}</code></p>
     <p>Любое из трех выражений цикла может быть опущено. Считается, что отсутствие второго выражения равносильно сравнению с нулем ненулевой константы. </p>
    </section>
    <section>
     <title>
      <p>A9.6. Инструкции перехода</p>
     </title>
     <p>Инструкции перехода осуществляют безусловную передачу управления.</p>
     <p><code><emphasis>инструкция-перехода</emphasis>:</code></p>
     <p><code>    goto <emphasis>идентификатор </emphasis>;</code></p>
     <p><code>    continue ;</code></p>
     <p><code>    break ;</code></p>
     <p><code>    return <emphasis>выражение<sub>необ </sub></emphasis>;</code></p>
     <p>В <emphasis>goto</emphasis>-инструкции идентификатор должен быть меткой (A9.1), расположенной в текущей функции. Управление передается на помеченную инструкцию.</p>
     <p>Инструкцию <emphasis>continue</emphasis> можно располагать только внутри цикла. Она вызывает переход к следующей итерации самого внутреннего содержащего ее цикла. Говоря более точно, для каждой из конструкций </p>
     <p><code>while (...){</code></p>
     <p><code>    ...</code></p>
     <p><code>contin: ;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>do {</code></p>
     <p><code>    ...</code></p>
     <p><code>contin: ;</code></p>
     <p><code>} while (...);</code></p>
     <empty-line/>
     <p><code>for (...){</code></p>
     <p><code>    ...</code></p>
     <p><code>contin: ;</code></p>
     <p><code>}</code></p>
     <p>инструкция <emphasis>continue</emphasis>, если она не помещена в еще более внутренний цикл, делает то же самое, что и <emphasis>goto contin</emphasis>.</p>
     <p>Инструкция <emphasis>break</emphasis> встречается в циклической или в <emphasis>switch</emphasis>-инструкции, и только в них. Она завершает работу самой внутренней циклической или <emphasis>switch</emphasis>- инструкции, содержащей данную инструкцию <emphasis>break</emphasis>, после чего управление переходит к следующей инструкции.</p>
     <p>С помощью <emphasis>return</emphasis> функция возвращает управление в программу, откуда была вызвана. Если за <emphasis>return</emphasis> следует выражение, то его значение возвращается вызвавшей эту функцию программе. Значение выражения приводится к типу так, как если бы оно присваивалось переменной, имеющей тот же тип, что и функция.</p>
     <p>Ситуация, когда "путь" вычислений приводит в конец функции (т. е. на последнюю закрывающую фигурную скобку), равносильна выполнению <emphasis>return</emphasis>- инструкции без выражения. При этом, а также в случае явного задания <emphasis>return</emphasis> без выражения возвращаемое значение не определено</p>
    </section>
   </section>
   <section>
    <title>
     <p>А10. Внешние объявления </p>
    </title>
    <section>
     <p>То, что подготовлено в качестве ввода для Си-компилятора, называется единицей трансляции. Она состоит из последовательности внешних объявлений, каждое из которых представляет собой либо объявление, либо определение функции.</p>
     <p><code><emphasis>единица-трансляции</emphasis>:</code></p>
     <p><code>    <emphasis>внешнее-объявление</emphasis></code></p>
     <p><code>    <emphasis>единица-трансляции внешнее-объявление</emphasis></code></p>
     <p><code><emphasis>внешнее-объявление</emphasis>:</code></p>
     <p><code>    <emphasis>определение-функции</emphasis></code></p>
     <p><code>    <emphasis>объявление</emphasis></code></p>
     <p>Область видимости внешних объявлений простирается до конца единицы трансляции, в которой они объявлены, точно так же, как область видимости объявлений в блоке распространяется до конца этого блока. Синтаксис внешнего объявления не отличается от синтаксиса любого другого объявления за одним исключением: код функции можно определять только с помощью внешнего объявления.</p>
    </section>
    <section>
     <title>
      <p>A10.1. Определение функции</p>
     </title>
     <empty-line/>
     <p>Определение функции имеет следующий вид:</p>
     <p><code><emphasis>определение-функции</emphasis>:</code></p>
     <p><code>    <emphasis>спецификаторы-объявления<sub>необ</sub> объявитель список-объявлений<sub>необ</sub></emphasis></code></p>
     <p><code>    <emphasis>составная-инструкция</emphasis></code></p>
     <p>Из спецификаторов класса памяти в спецификаторах-объявлениях возможны только <emphasis>extern</emphasis> и <emphasis>static</emphasis>; различия между последними рассматриваются в A11.2.</p>
     <p>Типом возвращаемого функцией значения может быть арифметический тип, структура, объединение, указатель и <emphasis>void</emphasis>, но не "функция" и не "массив". Объявитель в объявлении функции должен явно указывать на то, что описываемый им идентификатор имеет тип "функция", т. е. он должен иметь одну из следующих двух форм (A8.6.3):</p>
     <p><code><emphasis><emphasis>собственно-объявитель</emphasis> ( <emphasis>список-типов-параметров</emphasis> )</emphasis></code></p>
     <p><code><emphasis><emphasis>собственно-объявитель</emphasis> ( <emphasis>список-идентификаторов</emphasis><sub><emphasis>необ </emphasis></sub>) </emphasis></code></p>
     <p>где <emphasis>собственно-объявитель</emphasis> есть идентификатор или идентификатор, заключенный в скобки. Заметим, что тип "функция" посредством <emphasis>typedef</emphasis> получить нельзя.</p>
     <p>Первая форма соответствует определению функции новым способом, для которого характерно объявление параметров в списке-типов-параметров вместе с их типами; за объявителем не должно быть списка-объявлений. Если список-типов-параметров не состоит из одного-единственного слова <emphasis>void</emphasis>, показывающего, что параметров у функции нет, то в каждом объявителе в списке-типов-параметров обязан присутствовать идентификатор. Если список-типов-параметров заканчивается знаками ", ...", то вызов функции может иметь аргументов больше, чем параметров; в таком случае, чтобы обращаться к дополнительным аргументам, следует пользоваться механизмом макроса <emphasis>va_arg</emphasis> из заголовочного файла <strong>&lt;stdarg.h&gt;</strong>, описанного в приложении B. Функции с переменным числом аргументов должны иметь по крайней мере один именованный параметр.</p>
     <p>Вторая форма - определение функции старым способом. Список-идентификаторов содержит имена параметров, а список-объявлений приписывает им типы. В списке- объявлении разрешено объявлять только именованные параметры, инициализация запрещается, и из спецификаторов класса памяти возможен только <emphasis>register</emphasis>.</p>
     <p>И в том и другом способе определения функции мыслится, что все параметры как бы объявлены в самом начале составной инструкции, образующей тело функции, и совпадающие с ними имена здесь объявляться не должны (хотя, как и любые идентификаторы, их можно переобъявить в более внутренних блоках). Объявление параметра "массив из <emphasis>типа</emphasis>" можно трактовать как "указатель на <emphasis>тип</emphasis>", аналогично объявлению параметра объявление "функция, возвращающая <emphasis>тип</emphasis>" можно трактовать как "указатель на функцию, возвращающую <emphasis>тип</emphasis>". В момент вызова функции ее аргументы соответствующим образом преобразуются и присваиваются параметрам (см. A7.3.2).</p>
     <cite>
      <p>Новый способ определения функций введен ANSI-стандартом. Есть также небольшие изменения в операции повышения типа; в первой версии языка параметры типа <emphasis>float</emphasis> следовало читать как <emphasis>double</emphasis>. Различие между <emphasis>float</emphasis> и <emphasis>double</emphasis> становилось заметным, лишь когда внутри функции генерировался указатель на параметр. </p>
     </cite>
     <p>Ниже приведен пример определения функции новым способом:</p>
     <p><code>int max(int a, int b, int c)</code></p>
     <p><code>{</code></p>
     <p><code>    int m;</code></p>
     <empty-line/>
     <p><code>    m = (a &gt; b) ? a: b;</code></p>
     <p><code>    return (m &gt; с) ? m : с;</code></p>
     <p><code>}</code></p>
     <p>Здесь <emphasis>int</emphasis>-спецификаторы-объявления; max(int a, int b, int с) - объявитель функции, a { ... } - блок, задающий ее код. Определение старым способом той же функции выглядит следующим образом: </p>
     <p><code>int max(a, b, с)</code></p>
     <p><code>int а, b, с;</code></p>
     <p><code>{</code></p>
     <p><code>    /* ... */</code></p>
     <p><code>}</code></p>
     <p>где max(a, b, c) – объявитель, а int a, b, c - список-объявлений для параметров.</p>
    </section>
    <section>
     <title>
      <p>A10.2. Внешние объявления</p>
     </title>
     <p>Внешние объявления специфицируют характеристики объектов, функций и других идентификаторов. Термин "внешний" здесь используется, чтобы подчеркнуть тот факт, что объявления расположены вне функций; впрямую с ключевым словом <emphasis>extern</emphasis> ("внешний") он не связан. Класс памяти для объекта с внешним объявлением либо вообще не указывается, либо специфицируется как <emphasis>extern</emphasis> или <emphasis>static</emphasis>. </p>
     <p>В одной единице трансляции для одного идентификатора может содержаться несколько внешних объявлений, если они согласуются друг с другом по типу и способу связи и если для этого идентификатора существует не более одного определения. </p>
     <p>Два объявления объекта или функции считаются согласованными по типу в соответствии с правилами, рассмотренными в A8.10. Кроме того, если объявления отличаются лишь тем, что в одном из них тип структуры, объединения или перечисления незавершен (A8.3), а в другом соответствующий ему тип с тем же тегом завершен, то такие типы считаются согласованными. Если два типа массива (A8.6.2) отличаются лишь тем, что один завершенный, а другой незавершенный, то такие типы также считаются согласованными. Наконец, если один тип специфицирует функцию старым способом, а другой - ту же функцию новым способом (с объявлениями параметров), то такие типы также считаются согласованными. </p>
     <p>Если первое внешнее объявление функции или объекта помечено спецификатором <emphasis>static</emphasis>, то объявленный идентификатор имеет <emphasis>внутреннюю связь</emphasis>; в противном случае - <emphasis>внешнюю связь</emphasis>. Способы связей обсуждаются в A11.2. </p>
     <p>Внешнее объявление объекта считается определением, если оно имеет инициализатор. Внешнее объявление, в котором нет инициализатора и нет спецификатора <emphasis>extern</emphasis>, считается <emphasis>пробным определением</emphasis>. Если в единице трансляции появится определение объекта, то все его пробные определения просто станут избыточными объявлениями. Если никакого определения для этого объекта в единице трансляции не обнаружится, то все его пробные определения будут трактоваться как одно определение с инициализатором 0. </p>
     <p>Каждый объект должен иметь ровно одно определение. Для объекта с внутренней связью это правило относится к каждой отдельной единице трансляции, поскольку объекты с внутренними связями в каждой единице уникальны. В случае объектов с внешними связями указанное правило действует в отношении всей программы в целом.</p>
     <cite>
      <p>Хотя правило одного определения формулируется несколько иначе, чем в первой версии языка, по существу оно совпадает с прежним. Некоторые реализации его ослабляют, более широко трактуя понятие пробного определения. В другом варианте указанного правила, который распространен в системах UNIX и признан как общепринятое расширение стандарта, все пробные определения объектов с внешними связями из всех транслируемых единиц программы рассматриваются вместе, а не отдельно в каждой единице. Если где-то в программе обнаруживается определение, то пробные определения становятся просто объявлениями, но, если никакого определения не встретилось, то все пробные определения становятся одним-единственным определением с инициализатором 0. </p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>A11. Область видимости и связи</p>
    </title>
    <section>
     <p>Каждый раз компилировать всю программу целиком нет необходимости. Исходный текст можно хранить в нескольких файлах, представляющих собой единицы трансляции. Ранее скомпилированные программы могут загружаться из библиотек. Связи между функциями программы могут осуществляться через вызовы и внешние данные. </p>
     <p>Следовательно, существуют два вида областей видимости: первая - это <emphasis>лексическая область</emphasis> идентификатора: т. е. область в тексте программы, где имеют смысл все его характеристики; вторая область - это область, ассоциируемая с объектами и функциями, имеющими внешние связи, устанавливаемые между идентификаторами из раздельно компилируемых единиц трансляции. </p>
    </section>
    <section>
     <title>
      <p>A11.1. Лексическая область видимости</p>
     </title>
     <empty-line/>
     <p>Каждый идентификатор попадает в одно из нескольких пространств имен. Эти пространства никак не связаны друг с другом. Один и тот же идентификатор может использоваться в разных смыслах даже в одной области видимости, если он принадлежит разным пространствам имен. Ниже через точку с запятой перечислены классы объектов, имена которых представляют собой отдельные независимые пространства: объекты, функции, <emphasis>typedef</emphasis>-имена и <emphasis>enum</emphasis>-константы; метки инструкций; теги структур, объединений и перечислений; элементы каждой отдельной структуры или объединения.</p>
     <cite>
      <p>Сформулированные правила несколько отличаются от прежних, описанных в первом издании. Метки инструкций не имели раньше собственного пространства; теги структур и теги объединений (а в некоторых реализациях и теги перечислений) имели отдельные пространства. Размещение тегов структур, объединений и перечислений в одном общем пространстве - это дополнительное ограничение, которого раньше не было. Наиболее существенное отклонение от первой редакции в том, что каждая отдельная структура (или объединение) создает свое собственное пространство имен для своих элементов. Таким образом, одно и то же имя может использоваться в нескольких различных структурах. Это правило широко применяется уже несколько лет. </p>
     </cite>
     <p>Лексическая область видимости идентификатора объекта (или функции), объявленного во внешнем объявлении, начинается с места, где заканчивается его объявитель, и простирается до конца единицы трансляции, в которой он объявлен. Область видимости параметра в определении функции начинается с начала блока, представляющего собой тело функции, и распространяется на всю функцию; область видимости параметра в описании функции заканчивается в конце этого описания. Область видимости идентификатора, объявленного в начале блока, начинается от места, где заканчивается его объявитель, и продолжается до конца этого блока. Областью видимости метки является вся функция, где эта метка встречается. Область видимости тега структуры, объединения или перечисления начинается от его появления в спецификаторе типа и продолжается до конца единицы трансляции для объявления внешнего уровня и до конца блока для объявления внутри функции. </p>
     <p>Если идентификатор явно объявлен в начале блока (в том числе тела функции), то любое объявление того же идентификатора, находящееся снаружи этого блока, временно перестает действовать вплоть до конца блока. </p>
    </section>
    <section>
     <title>
      <p>A11.2. Связи</p>
     </title>
     <p>Если встречается несколько объявлений, имеющих одинаковый идентификатор и описывающих объект (или функцию), то все эти объявления в случае внешней связи относятся к одному объекту (функции) - уникальному для всей программы; если же связь внутренняя, то свойство уникальности распространяется только на единицу трансляции.</p>
     <p>Как говорилось в A10.2, если первое внешнее объявление имеет спецификатор <emphasis>static</emphasis>, то оно описывает идентификатор с внутренней связью, если такого спецификатора нет, то - с внешней связью. Если объявление находится внутри блока и не содержит <emphasis>extern</emphasis>, то соответствующий идентификатор ни с чем не связан и уникален для данной функции. Если объявление содержит <emphasis>extern</emphasis> и блок находится к области видимости внешнего объявления этого идентификатора, то последний имеет ту же связь и относится к тому же объекту (функции). Однако если ни одного внешнего объявления для этого идентификатора нет, то он имеет внешнюю связь. </p>
    </section>
   </section>
   <section>
    <title>
     <p>A12. Препроцессирование</p>
    </title>
    <section>
     <p>Препроцессор выполняет макроподстановку, условную компиляцию, включение именованных файлов. Строки, начинающиеся со знака # (перед которым возможны символы-разделители), устанавливают связь с препроцессором. Их синтаксис не зависит от остальной части языка; они могут появляться где угодно и оказывать влияние (независимо от области видимости) вплоть до конца транслируемой единицы. Границы строк принимаются во внимание: каждая строка анализируется отдельно (однако есть возможность "склеивать" строки, см. A12.2). Лексемами для препроцессора являются все лексемы языка и последовательности символов, задающие имена файлов, как, например, в директиве #include (A12.4). Кроме того, любой символ, неопределенный каким-либо другим способом, воспринимается как лексема. Влияние символов-разделителей, отличающихся от пробелов и горизонтальных табуляций, внутри строк препроцессора не определено. </p>
     <p>Само препроцессирование проистекает в нескольких логически последовательных фазах. В отдельных реализациях некоторые фазы объединены.</p>
     <p>1. Трехзнаковые последовательности, описанные в A12.1, заменяются их эквивалентами. Между строками вставляются символы новой строки, если того требует операционная система.</p>
     <p>2. Выбрасываются пары символов, состоящие из обратной наклонной черты с последующим символом новой строки; тем самым осуществляется "склеивание" строк (A12.2).</p>
     <p>3. Программа разбивается на лексемы, разделенные символами-разделителями. Комментарии заменяются единичными пробелами. Затем выполняются директивы препроцессора и макроподстановки (A12.3-A12.10).</p>
     <p>4. Эскейп-последовательности в символьных константах и строковых литералах (A2.5.2, A2.6) заменяются на символы, которые они обозначают. Соседние строковые литералы конкатенируются.</p>
     <p>5. Результат транслируется. Затем устанавливаются связи с другими программами и библиотеками посредством сбора необходимых программ и данных и соединения ссылок на внешние функции и объекты с их определениями. </p>
    </section>
    <section>
     <title>
      <p>A12.1. Трехзнаковые последовательности</p>
     </title>
     <p>Множество символов, из которых набираются исходные Си-программы, основано на семибитовом ASCII-коде. Однако он шире, чем инвариантный код символов ISO 646-1983 (ISO 646-1983 Invariant Code Set). Чтобы дать возможность пользоваться сокращенным набором символов, все указанные ниже трехзнаковые последовательности заменяются на соответствующие им единичные символы. Замена осуществляется до любой иной обработки. </p>
     <empty-line/>
     <p><code><strong>??=    #</strong></code></p>
     <p><code><strong>??(    [</strong></code></p>
     <p><code><strong>??&lt;    {</strong></code></p>
     <p><code><strong>??/    \</strong></code></p>
     <p><code><strong>??)    ]</strong></code></p>
     <p><code><strong>??&gt;    }</strong></code></p>
     <p><code><strong>??'    ^</strong></code></p>
     <p><code><strong>??!    |</strong></code></p>
     <p><code><strong>??-    ~</strong></code></p>
     <p>Никакие другие замены, кроме указанных, не делаются.</p>
     <cite>
      <p>Трехзнаковые последовательности введены ANSI-стандартом. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>A12.2. Склеивание строк</p>
     </title>
     <p>Строка, заканчивающаяся обратной наклонной чертой, соединяется со следующей, поскольку символ \ и следующий за ним символ новой строки выбрасываются. Это делается перед "разбиением" текста на лексемы. </p>
    </section>
    <section>
     <title>
      <p>А12.3. Макроопределение и макрорасширение</p>
     </title>
     <empty-line/>
     <p>Управляющая строка вида</p>
     <p><code>#define <emphasis>идентификатор последовательность-лексем</emphasis></code></p>
     <p>заставляет препроцессор заменять <emphasis>идентификатор</emphasis> на <emphasis>последовательность-лексем</emphasis>; символы-разделители в начале и в конце последовательности лексем выбрасываются. Повторная строка <emphasis>#define</emphasis> с тем же идентификатором считается ошибкой, если последовательности лексем неидентичны (несовпадения в символах-разделителях при сравнении во внимание не принимаются). Строка вида </p>
     <p><code>#define <emphasis>идентификатор</emphasis>(<emphasis>список-идентификаторов</emphasis>) <emphasis>последовательность-лексем</emphasis></code> </p>
     <p>где между первым идентификатором и знаком ( не должно быть ни одного символа-разделителя, представляет собой макроопределение с параметрами, задаваемыми списком идентификаторов. Как и в первом варианте, символы-разделители в начале и в конце последовательности лексем выбрасываются, и макрос может быть повторно определен только с тем же списком параметров и с той же последовательностью лексем. Управляющая строка вида</p>
     <p><code>#undef <emphasis>идентификатор</emphasis></code></p>
     <p>предписывает препроцессору "забыть" определение, данное идентификатору. Применение <emphasis>#undef</emphasis> к неизвестному идентификатору ошибкой не считается. </p>
     <p>Если макроопределение было задано вторым способом, то текстовая последовательность, состоящая из его идентификатора, возможно, со следующими за ним символами-разделителями, знака (, списка лексем, разделенных запятыми, и знака ), представляет собой вызов макроса. Аргументами вызова макроса являются лексемы, разделенные запятыми (запятые, "закрытые" кавычками или вложенными скобками, в разделении аргументов не участвуют). Аргументы при их выделении макрорасширениям не подвергаются. Количество аргументов в вызове макроса должно соответствовать количеству параметров макроопределения. После выделения аргументов окружающие их символы-разделители выбрасываются. Затем в замещающей последовательности лексем макроса идентификаторы-параметры (если они не закавычены) заменяются на соответствующие им аргументы. Если в замещающей последовательности перед параметром не стоит знак # и ни перед ним, ни после него нет знака ##, то лексемы аргумента проверяются: не содержат ли они в себе макровызова, и если содержат, то прежде чем аргумент будет подставлен, производится соответствующее ему макрорасширение. </p>
     <p>На процесс подстановки влияют два специальных оператора. Первый -это оператор #, который ставится перед параметром. Он требует, чтобы подставляемый вместо параметра и знака # (перед ним) текст был заключен в двойные кавычки. При этом в строковых литералах и символьных константах аргумента перед каждой двойной кавычкой " (включая и обрамляющие строки), а также перед каждой обратной наклонной чертой \ вставляется \. </p>
     <p>Второй оператор записывается как ##. Если последовательность лексем в любого вида макроопределении содержит оператор ##, то сразу после подстановки параметров он вместе с окружающими его символами-разделителями выбрасывается, благодаря чему "склеиваются" соседние лексемы, образуя тем самым новую лексему. Результат не определен при получении неправильных лексем или когда генерируемый текст зависит от порядка применения операторов ##. Кроме того, ## не может стоять ни в начале, ни в конце замещающей последовательности лексем. </p>
     <p>В макросах обоих видов замещающая последовательность лексем повторно просматривается на предмет обнаружения там новых <emphasis>define</emphasis>-имен. Однако, если некоторый идентификатор уже был заменен в данном расширении, повторное появление такого идентификатора не вызовет его замены. </p>
     <p>Если полученное расширение начинается со знака #, оно не будет воспринято как директива препроцессора. </p>
     <cite>
      <p>В ANSI-стандарте процесс макрорасширения описан более точно, чем в первом издании книги. Наиболее важные изменения касаются введения операторов # и ##, которые предоставляют возможность осуществлять расширения внутри строк и конкатенацию лексем. Некоторые из новых правил, особенно касающиеся конкатенации, могут показаться несколько странными. (См. приведенные ниже примеры.) </p>
     </cite>
     <p>Описанные возможности можно использовать для показа смысловой сущности констант, как, например, в </p>
     <p><code>#define TABSIZE 100</code></p>
     <p><code>int table[TABSIZE];</code></p>
     <p>Определение</p>
     <p><code>#define ABSDIFF(a,b) ((a)&gt;(b) ? (a)-(b) : (b)-(a))</code></p>
     <p>задает макрос, возвращающий абсолютное значение разности его аргументов. В отличие от функции, делающей то же самое, аргументы и возвращаемое значение здесь могут иметь любой арифметический тип и даже быть указателями. Кроме того, аргументы, каждый из которых может иметь побочный эффект, вычисляются дважды: один раз - при проверке, другой раз - при вычислении результата.</p>
     <p>Если имеется определение</p>
     <p><code>#define tempfile(dir) #dir "/%s"</code></p>
     <p>то макровызов <emphasis>tempfile(/usr/tmp)</emphasis> даст в результате </p>
     <p><code>"/usr/tmp" "/%s"</code></p>
     <p>Далее эти две строки превратятся в одну строку. По макросу</p>
     <p><code>#define cat(x,y) x ## y</code></p>
     <p>вызов <emphasis>cat(var, 123)</emphasis> сгенерирует <emphasis>var123</emphasis>. Однако <emphasis>cat (cat (1,2),3)</emphasis> не даст желаемого, так как оператор ## воспрепятствует получению правильных аргументов для внешнего вызова <emphasis>cat</emphasis>. В результате будет выдана следующая цепочка лексем:</p>
     <p><code>cat ( 1 , 2 )3</code></p>
     <p>где )3 (результат "склеивания" последней лексемы первого аргумента с первой лексемой второго аргумента) не является правильной лексемой. Если второй уровень макроопределения задан в виде</p>
     <p><code>#define xcat(x,y) cat(x,y)</code></p>
     <p>то никаких коллизий здесь не возникает;</p>
     <p><code>xcat(хсat(1, 2), 3)</code></p>
     <p>в итоге даст 123, поскольку сам <emphasis>xcat</emphasis> не использует оператора ##.</p>
     <p>Аналогично сработает и ABSDIFF(ABSDIFF(a, b), c), и мы получим правильный результат.</p>
    </section>
    <section>
     <title>
      <p>A12.4. Включение файла</p>
     </title>
     <p>Управляющая строка</p>
     <p><code>#include &lt;<emphasis>имя-файла</emphasis>&gt;</code></p>
     <p>заменяется на содержимое файла с именем <emphasis>имя-файла</emphasis>. Среди символов, составляющих <emphasis>имя-файла</emphasis>, не должно быть знака &gt; и символа новой строки. Результат не определен, если <emphasis>имя-файла</emphasis> содержит любой из символов ", ', \ или пару символов /*. Порядок поиска указанного файла зависит от реализации. </p>
     <p>Подобным же образом выполняется управляющая строка</p>
     <p><code>#include "<emphasis>имя-файла</emphasis>"</code></p>
     <p>Сначала поиск осуществляется по тем же правилам, по каким компилятор ищет первоначальный исходный файл (механизм этого поиска зависит от реализации), а в случае неудачи осуществляется методом поиска, принятым в #include первого типа. Результат остается неопределенным, если имя файла содержит ", \ или /*; использование знака &gt; разрешается. </p>
     <p>Наконец, директива</p>
     <p><code>#include <emphasis>последовательность-лексем</emphasis></code></p>
     <p>не совпадающая ни с одной из предыдущих форм, рассматривает <emphasis>последовательность лексем</emphasis> как текст, который в результате всех макроподстановок должен дать <emphasis>#include &lt;...&gt;</emphasis> или <emphasis>#include "..."</emphasis>. Сгенерированная таким образом директива далее будет интерпретироваться в соответствии с полученной формой. </p>
     <p>Файлы, вставляемые с помощью <emphasis>#include</emphasis>, сами могут содержать в себе директивы <emphasis>#include</emphasis>.</p>
    </section>
    <section>
     <title>
      <p>A12.5. Условная компиляция</p>
     </title>
     <p>Части программы могут компилироваться условно, если они оформлены в соответствии со следующим схематично изображенным синтаксисом:</p>
     <p><code><emphasis>условная - конструкция -препроцессора</emphasis>:</code></p>
     <p><code>    <emphasis>if-строка текст elif-части else-часть<sub>необ</sub></emphasis> #endif</code></p>
     <p><code><emphasis>if-строка</emphasis>:</code></p>
     <p><code>    #if <emphasis>константное-выражение</emphasis></code></p>
     <p><code>    #ifdef <emphasis>идентификатор</emphasis></code></p>
     <p><code>    #ifndef <emphasis>идентификатор</emphasis></code></p>
     <p><code><emphasis>elif-части</emphasis>:</code></p>
     <p><code>    <emphasis>elif-строка текст</emphasis></code></p>
     <p><code>    <emphasis>elif-части<sub>необ</sub></emphasis></code></p>
     <p><code><emphasis>elif-строка</emphasis>:</code></p>
     <p><code>    #elif <emphasis>константное-выражение</emphasis></code></p>
     <p><code><emphasis>else-часть</emphasis>:</code></p>
     <p><code>    <emphasis>else-строка текст</emphasis></code></p>
     <p><code><emphasis>else-строка</emphasis>:</code></p>
     <p><code>    #else</code></p>
     <p>Каждая из директив (<emphasis>if</emphasis>-строка, <emphasis>elif</emphasis>-строка, <emphasis>else</emphasis>-строка и <emphasis>#endif</emphasis>) записывается на отдельной строке. Константные выражения в <emphasis>#if</emphasis> и последующих строках <emphasis>#elif</emphasis> вычисляются по порядку, пока не обнаружится выражение с ненулевым (истинным) значением; текст, следующий за строкой с нулевым значением, выбрасывается. Текст, расположенный за директивой с ненулевым значением, обрабатывается обычным образом. Под словом "<emphasis>текст</emphasis>" здесь имеется в виду любая последовательность строк, включая строки препроцессора, которые не являются частью условной структуры; текст может быть и пустым. Если строка <emphasis>#if</emphasis> или <emphasis>#elif</emphasis> с ненулевым значением выражения найдена и ее текст обработан, то последующие строки <emphasis>#elif</emphasis> и <emphasis>#else</emphasis> вместе со своими текстами выбрасываются. Если все выражения имеют нулевые значения и присутствует строка <emphasis>#else</emphasis>, то следующий за ней текст обрабатывается обычным образом. Тексты "неактивных" ветвей условных конструкций, за исключением тех, которые заведуют вложенностью условных конструкций, игнорируются.</p>
     <p>Константные выражения в <emphasis>#if</emphasis> и <emphasis>#elif</emphasis> являются объектами для обычной макроподстановки. Более того, прежде чем просматривать выражения вида </p>
     <p><code>defined <emphasis>идентификатор</emphasis></code></p>
     <p>и</p>
     <p><code>defined ( <emphasis>идентификатор</emphasis> )</code></p>
     <p>на предмет наличия в них макровызова, они заменяются на 1L или 0L в зависимости от того, был или не был определен препроцессором указанный в них идентификатор. Все идентификаторы, оставшиеся после макрорасширения, заменяются на 0L. Наконец, предполагается, что любая целая константа всегда имеет суффикс L, т. е. вся арифметика имеет дело с операндами только типа <emphasis>long</emphasis> или <emphasis>unsigned long</emphasis>. </p>
     <p>Константное выражение (A7.19) здесь используется с ограничениями: оно должно быть целочисленным, не может содержать в себе перечислимых констант, преобразований типа и операторов <emphasis>sizeof</emphasis>.</p>
     <p>Управляющие строки </p>
     <p><code>#ifdef <emphasis>идентификатор</emphasis></code></p>
     <p><code>#ifndef <emphasis>идентификатор</emphasis></code></p>
     <p>эквивалентны соответственно строкам</p>
     <p><code>#if defined <emphasis>идентификатор</emphasis></code></p>
     <p><code>#if !defined <emphasis>идентификатор</emphasis> </code></p>
     <cite>
      <p>Строки <emphasis>#elif</emphasis> не было в первой версии языка, хотя она и использовалась в некоторых препроцессорах. Оператор препроцессора <emphasis>defined</emphasis> - также новый. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>A12.6. Нумерация строк</p>
     </title>
     <p>Для удобства работы с другими препроцессорами, генерирующими Си-программы, можно использовать одну из следующих директив:</p>
     <p><code>#line <emphasis>константа</emphasis> "<emphasis>имя-файла</emphasis>"</code></p>
     <p><code>#line <emphasis>константа</emphasis></code></p>
     <p>Эти директивы предписывают компилятору считать, что указанные десятичное целое и идентификатор являются номером следующей строки и именем текущего файла соответственно. Если имя файла отсутствует, то ранее запомненное имя не изменяется. Расширения макровызовов в директиве <emphasis>#line</emphasis> выполняются до интерпретации последней. </p>
     <empty-line/>
    </section>
    <section>
     <title>
      <p>A12.7. Генерация сообщения об ошибке</p>
     </title>
     <empty-line/>
     <p>Строка препроцессора вида</p>
     <p><code>#error <emphasis>последовательность-лексем</emphasis><sub><emphasis>необ</emphasis></sub></code></p>
     <p>приказывает ему выдать диагностическое сообщение, включающее заданную последовательность лексем.</p>
    </section>
    <section>
     <title>
      <p>A12.8. Прагма</p>
     </title>
     <p>Управляющая строка вида</p>
     <p><code>#pragma <emphasis>последовательность-лексем</emphasis><sub><emphasis>необ</emphasis></sub></code></p>
     <p>призывает препроцессор выполнить зависящие от реализации действия. Неопознанная прагма игнорируется.</p>
    </section>
    <section>
     <title>
      <p>A12.9. Пустая директива</p>
     </title>
     <p>Строка препроцессора вида </p>
     <p><code>#</code></p>
     <p>не вызывает никаких действий.</p>
    </section>
    <section>
     <title>
      <p>A12.10. Заранее определенные имена</p>
     </title>
     <p>Препроцессор "понимает" несколько заранее определенных идентификаторов; их он заменяет специальной информацией. Эти идентификаторы (и оператор препроцессора <emphasis>defined</emphasis> в том числе) нельзя повторно переопределять, к ним нельзя также применять директиву <emphasis>#undef</emphasis>. Это следующие идентификаторы:</p>
     <p><code>__LINE__ Номер текущей строки исходного текста, десятичная константа.</code></p>
     <p><code>__FILE__ Имя компилируемого файла, строка.</code></p>
     <p><code>__DATE__ Дата компиляции в виде "MMM DD YYYY",строка.</code></p>
     <p><code>__TIME__ Время компиляции в виде "hh:mm:ss", строка.</code></p>
     <p><code>__STDC__ Константа 1. Предполагается, что этот идентификатор определен как 1 </code></p>
     <p><code>         только в тех реализациях, которые следуют стандарту.</code></p>
     <p>Строки <emphasis>#error</emphasis> и <emphasis>#pragma</emphasis> впервые введены ANSI-стандартом. Заранее определенные макросы препроцессора также до сих пор не описывались, хотя и использовались в некоторых реализациях. </p>
    </section>
   </section>
   <section>
    <title>
     <p>A13. Грамматика</p>
    </title>
    <p>Ниже приведены грамматические правила, которые мы уже рассматривали в данном приложении. Они имеют то же содержание, но даны в ином порядке. </p>
    <p>Здесь не приводятся определения следующих символов-терминов: <emphasis>целая-константа</emphasis>, <emphasis>символьная-константа</emphasis>, <emphasis>константа-с-плавающей-точкой</emphasis>, <emphasis>идентификатор</emphasis>, <emphasis>строка</emphasis> и <emphasis>константа-перечисление</emphasis>. Слова, набранные обычным латинским шрифтом (не курсивом), и знаки рассматриваются как символы-термины и используются точно в том виде, как записаны. Данную грамматику можно механически трансформировать в текст, понятный системе автоматической генерации грамматического распознавателя. Для этого помимо добавления некоторых синтаксических пометок, предназначенных для указания альтернативных продукций, потребуется расшифровка конструкции со словами "один из" и дублирование каждой продукции, использующей символ с индексом <emphasis>необ.</emphasis>, причем один вариант продукции должен быть написан с этим символом, а другой - без него. С одним изменением, а именно - удалением продукции <emphasis>typedef-имя</emphasis>:<emphasis>идентификатор</emphasis> и объявлением <emphasis>typedef-имени</emphasis> символом-термином, данная грамматика будет понятна генератору грамматического распознавателя YACC. Ей присуще лишь одно противоречие, вызываемое неоднозначностью конструкции <emphasis>if-else</emphasis>.</p>
    <p><code><emphasis>единица–трансляции</emphasis>:</code></p>
    <p><code>    <emphasis>внешнее-объявление</emphasis></code></p>
    <p><code>    <emphasis>единица-трансляции внешнее-объявление</emphasis></code></p>
    <p><code><emphasis>внешнее-объявление</emphasis>:</code></p>
    <p><code>    <emphasis>определение-функции</emphasis></code></p>
    <p><code>    <emphasis>объявление</emphasis></code></p>
    <p><code><emphasis>определение функции</emphasis>:</code></p>
    <p><code>    <emphasis>спецификаторы-объявления<sub>необ</sub> объявитель</emphasis></code></p>
    <p><code>    <emphasis>список-объявлений<sub>необ</sub> составная-инструкция</emphasis></code></p>
    <p><code><emphasis>объявление</emphasis>:</code></p>
    <p><code>    <emphasis>спецификаторы-объявления список-инициализаторов-объявителей<sub>необ</sub></emphasis></code></p>
    <p><code><emphasis>список-объявлений</emphasis>:</code></p>
    <p><code>    <emphasis>объявление</emphasis></code></p>
    <p><code>    <emphasis>список-объявлений объявление</emphasis></code></p>
    <p><code><emphasis>спецификаторы-объявления</emphasis>:</code></p>
    <p><code>    <emphasis>спецификатор-класса-памяти спецификаторы-объявления<sub>необ</sub></emphasis></code></p>
    <p><code>    <emphasis>спецификатор-типа спецификаторы-объявления<sub>необ</sub></emphasis></code></p>
    <p><code>    <emphasis>квалификатор-типа спецификаторы-объявления<sub>необ</sub></emphasis></code></p>
    <p><code><emphasis>спецификатор-класса-памяти</emphasis>: один из</code></p>
    <p><code>    auto     register     static     extern     typedef</code></p>
    <p><code><emphasis>спецификатор-типа</emphasis>: один из</code></p>
    <p><code>    void char short int long float double signed unsigned</code></p>
    <p><code>    <emphasis>спецификатор-структуры-или-объединения</emphasis></code></p>
    <p><code>    <emphasis>спецификатор-перечисления</emphasis></code></p>
    <p><code>    <emphasis>typedef-имя</emphasis></code></p>
    <p><code><emphasis>квалификатор-типа</emphasis>: один из</code></p>
    <p><code>    const    volatile</code></p>
    <p><code><emphasis>спецификатор-структуры-или-объединения</emphasis>:</code></p>
    <p><code>    <emphasis>структуры-или-объединения-идентификатор<sub>необ</sub></emphasis> { <emphasis>список-объявлений-структуры</emphasis> }</code></p>
    <p><code>    <emphasis>структуры-или-объединения идентификатор</emphasis></code></p>
    <p><code><emphasis>структура-или-объединение</emphasis>: одно из</code></p>
    <p><code>    struct   union</code></p>
    <p><code><emphasis>список-объявлений-структуры</emphasis>:</code></p>
    <p><code>    <emphasis>объявление-структуры</emphasis></code></p>
    <p><code>    <emphasis>список-объявлений-структуры объявление-структуры</emphasis></code></p>
    <p><code><emphasis>список-объявителей-ииициализаторов</emphasis>:</code></p>
    <p><code>    <emphasis>объявитель-инициализатор</emphasis></code></p>
    <p><code>    <emphasis>список-объявителей-инициализаторов</emphasis> , <emphasis>объявитель-инициализатор</emphasis></code></p>
    <p><code><emphasis>объявитель-инициализатор</emphasis>:</code></p>
    <p><code>    объявитель</code></p>
    <p><code>    <emphasis>объявитель</emphasis> = <emphasis>инициализатор</emphasis></code></p>
    <p><code><emphasis>объявление-структуры</emphasis>:</code></p>
    <p><code>    <emphasis>список-спецификаторов-квалификаторов список-объявителей-структуры</emphasis></code></p>
    <p><code><emphasis>список-спецификаторов-квалификаторов</emphasis>:</code></p>
    <p><code>    <emphasis>спецификатор-типа список-спецификаторов-квалификаторов<sub>необ</sub></emphasis></code></p>
    <p><code>    <emphasis>квалификатор-типа список-спецификаторов-квалификаторов<sub>необ</sub></emphasis></code></p>
    <p><code><emphasis>список-структуры-объявителей</emphasis>:</code></p>
    <p><code>    <emphasis>структуры–объявитель</emphasis></code></p>
    <p><code>    <emphasis>список-структуры-объявителей</emphasis> , <emphasis>структуры-объявитель</emphasis></code></p>
    <p><code><emphasis>структуры-объявитель</emphasis>:</code></p>
    <p><code>    <emphasis>объявитель</emphasis></code></p>
    <p><code>    <emphasis>объявитель<sub>необ</sub></emphasis> : <emphasis>константное-выражение</emphasis></code></p>
    <p><code><emphasis>спецификатор-перечисления</emphasis>:</code></p>
    <p><code>    enum <emphasis>идентификатор<sub>необ</sub></emphasis> { <emphasis>список-перечислителей</emphasis> }</code></p>
    <p><code>    enum <emphasis>идентификатор</emphasis></code></p>
    <p><code><emphasis>список-перечислителей</emphasis>:</code></p>
    <p><code>    <emphasis>перечислитель</emphasis></code></p>
    <p><code>    <emphasis>список-перечислителей перечислитель</emphasis></code></p>
    <p><code><emphasis>перечислитель</emphasis>:</code></p>
    <p><code>    <emphasis>идентификатор</emphasis></code></p>
    <p><code>    <emphasis>указатель<sub>необ</sub> собственно-объявитель</emphasis></code></p>
    <p><code><emphasis>собственно-объявитель</emphasis>:</code></p>
    <p><code>    <emphasis>идентификатор</emphasis></code></p>
    <p><code>    ( <emphasis>объявитель</emphasis> )</code></p>
    <p><code>    <emphasis>собственно-объявитель</emphasis> [ <emphasis>константное-выражение<sub>необ</sub></emphasis> ]</code></p>
    <p><code>    <emphasis>собственно-объявитель</emphasis> ( <emphasis>список-типов-параметров</emphasis> )</code></p>
    <p><code>    <emphasis>собственно-объявитель</emphasis> ( <emphasis>список-идентификаторов<sub>необ</sub></emphasis> )</code></p>
    <p><code><emphasis>указатель</emphasis>:</code></p>
    <p><code>    * <emphasis>список~квалификаторов-типа<sub>необ</sub></emphasis></code></p>
    <p><code>    * <emphasis>список-квалификаторов-типа<sub>необ</sub> указатель</emphasis></code></p>
    <p><code><emphasis>список-квалификаторов-типа</emphasis>:</code></p>
    <p><code>    <emphasis>квалификатор-типа</emphasis></code></p>
    <p><code>    <emphasis>список-квалификаторов-типа квалификатор-типа</emphasis></code></p>
    <p><code><emphasis>список-типов-параметров</emphasis>:</code></p>
    <p><code>    <emphasis>список-параметров</emphasis></code></p>
    <p><code>    <emphasis>список-параметров</emphasis> , ...</code></p>
    <p><code><emphasis>список-параметров</emphasis>:</code></p>
    <p><code>    <emphasis>объявление-параметра</emphasis></code></p>
    <p><code>    <emphasis>список-параметров</emphasis> , <emphasis>объявление-параметра</emphasis></code></p>
    <p><code><emphasis>объявление-параметра</emphasis>:</code></p>
    <p><code>    <emphasis>спецификаторы-объявления объявитель</emphasis></code></p>
    <p><code>    <emphasis>спецификаторы-объявления абстрактный-объявитель<sub>необ</sub></emphasis></code></p>
    <p><code><emphasis>список-идентификаторов</emphasis>:</code></p>
    <p><code>    <emphasis>идентификатор</emphasis></code></p>
    <p><code>    <emphasis>список-идентификаторов</emphasis> , <emphasis>идентификатор</emphasis></code></p>
    <p><code><emphasis>инициализатор</emphasis>:</code></p>
    <p><code>    <emphasis>выражение-присваивания</emphasis></code></p>
    <p><code>    { <emphasis>список-инициализаторов</emphasis> }</code></p>
    <p><code>    { <emphasis>список-инициализаторов</emphasis>, }</code></p>
    <p><code><emphasis>список-инициализаторов</emphasis>:</code></p>
    <p><code>    <emphasis>инициализатор</emphasis></code></p>
    <p><code>    <emphasis>список-инициализаторов</emphasis> , <emphasis>инициализатор</emphasis></code></p>
    <p><code><emphasis>имя-типа</emphasis>:</code></p>
    <p><code>    <emphasis>список-спецификаторое-квалификаторов абстрактный-объявитель<sub>необ</sub></emphasis></code></p>
    <p><code><emphasis>абстрактный-объявитель</emphasis>:</code></p>
    <p><code>    <emphasis>указатель</emphasis></code></p>
    <p><code>    <emphasis>указатель<sub>необ</sub> собственно-абстрактный-объявитель</emphasis></code></p>
    <p><code><emphasis>собственно-абстрактный-объявитель</emphasis>:</code></p>
    <p><code>    ( <emphasis>абстрактный-объявитель</emphasis> )</code></p>
    <p><code>    <emphasis>собственно-абстрактный-объявитель<sub>необ</sub></emphasis> [<emphasis>константное-выражение<sub>необ</sub></emphasis>]</code></p>
    <p><code>    <emphasis>собственно-абстрактный-объявитель<sub>необ</sub></emphasis> (<emphasis>список-типов-параметров<sub>необ</sub></emphasis>)</code></p>
    <p><code><emphasis>typedef-имя</emphasis>:</code></p>
    <p><code>    <emphasis>идентификатор</emphasis></code></p>
    <p><code><emphasis>инструкция</emphasis>:</code></p>
    <p><code>    <emphasis>помеченная-инструкция</emphasis></code></p>
    <p><code>    <emphasis>инструкция–выражение</emphasis></code></p>
    <p><code>    <emphasis>составная-инструкция</emphasis></code></p>
    <p><code>    <emphasis>инструкция-выбора</emphasis></code></p>
    <p><code>    <emphasis>циклическая-инструкция</emphasis></code></p>
    <p><code>    <emphasis>инструкция-перехода</emphasis></code></p>
    <p><code><emphasis>помеченная-инструкция</emphasis>:</code></p>
    <p><code>    <emphasis>идентификатор</emphasis> : <emphasis>инструкция</emphasis></code></p>
    <p><code>    case <emphasis>константное-выражение</emphasis> : <emphasis>инструкция</emphasis></code></p>
    <p><code>    default : <emphasis>инструкция</emphasis></code></p>
    <p><code><emphasis>инструкция-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>выражение<sub>необ</sub></emphasis>;</code></p>
    <p><code><emphasis>составная-инструкция</emphasis>:</code></p>
    <p><code>    ( <emphasis>список-объявлений<sub>необ</sub> список-инструкций<sub>необ</sub></emphasis>)</code></p>
    <p><code><emphasis>список-инструкций</emphasis>:</code></p>
    <p><code>    <emphasis>инструкция</emphasis></code></p>
    <p><code>    <emphasis>список-инструкций инструкция</emphasis></code></p>
    <p><code><emphasis>инструкция-выбора</emphasis>:</code></p>
    <p><code>    if ( <emphasis>выражение</emphasis> ) <emphasis>инструкция</emphasis></code></p>
    <p><code>    if ( <emphasis>выражение</emphasis> ) <emphasis>инструкция</emphasis> else <emphasis>инструкция</emphasis></code></p>
    <p><code>    switch ( <emphasis>выражение</emphasis> ) <emphasis>инструкция</emphasis></code></p>
    <p><code><emphasis>циклическая-инструкция</emphasis>:</code></p>
    <p><code>    while ( <emphasis>выражение</emphasis> ) <emphasis>инструкция</emphasis></code></p>
    <p><code>    do <emphasis>инструкция</emphasis> while ( <emphasis>выражение</emphasis> )</code></p>
    <p><code>    return <emphasis>выражение<sub>необ</sub></emphasis>;</code></p>
    <p><code><emphasis>выражение</emphasis>:</code></p>
    <p><code>    <emphasis>выражение-присваивания</emphasis></code></p>
    <p><code>    <emphasis>выражение</emphasis> , <emphasis>выражение-присваивания</emphasis></code></p>
    <p><code><emphasis>выражение-присваивания</emphasis>:</code></p>
    <p><code>    <emphasis>условное-выражение</emphasis></code></p>
    <p><code>    <emphasis>унарное-выражение оператор-присваивания выражение-присваивания</emphasis></code></p>
    <p><code><emphasis>оператор-присваивания</emphasis>: один из</code></p>
    <p><code>    =   *=   /=   %=   +=   -=   &lt;&lt;=   &gt;&gt;=   &amp;=   ^=   |=</code></p>
    <p><code><emphasis>условное-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>логическое-ИЛИ-выражение</emphasis></code></p>
    <p><code>    <emphasis>логическое-ИЛИ-выражение</emphasis> ? <emphasis>выражение</emphasis> : <emphasis>условное-выражение</emphasis></code></p>
    <p><code><emphasis>константное-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>условное-выражение</emphasis></code></p>
    <p><code><emphasis>логическое-ИЛИ-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>логическое-И-выражение</emphasis></code></p>
    <p><code>    <emphasis>логическое-ИЛИ-выражение</emphasis> || <emphasis>логическое-И-выражение</emphasis></code></p>
    <p><code><emphasis>логическое-И-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>ИЛИ-выражение</emphasis></code></p>
    <p><code>    <emphasis>логическое-И-выражение</emphasis> &amp;&amp; <emphasis>ИЛИ-выражение</emphasis></code></p>
    <p><code><emphasis>ИЛИ-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>исключающее-ИЛИ-выражение</emphasis></code></p>
    <p><code>    <emphasis>ИЛИ-выражение</emphasis> | <emphasis>исключающее-ИЛИ-выражение</emphasis></code></p>
    <p><code><emphasis>исключающее-ИЛИ-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>И-выражение</emphasis></code></p>
    <p><code>    <emphasis>исключающее-ИЛИ-выражение</emphasis> ^ <emphasis>И-выражение</emphasis></code></p>
    <p><code><emphasis>И-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>выражение-равенства</emphasis></code></p>
    <p><code>    <emphasis>И-выражение</emphasis> &amp; <emphasis>выражение-равенства</emphasis></code></p>
    <p><code><emphasis>выражение-равенства</emphasis>:</code></p>
    <p><code>    <emphasis>выражение-отношения</emphasis></code></p>
    <p><code>    <emphasis>выражение-равенства</emphasis> == <emphasis>выражение-отношения</emphasis></code></p>
    <p><code>    <emphasis>выражение-равенства</emphasis> != <emphasis>выражение-отношения</emphasis></code></p>
    <p><code><emphasis>выражение-отношения</emphasis>:</code></p>
    <p><code>    <emphasis>сдвиговое-выражение</emphasis></code></p>
    <p><code>    <emphasis>выражение-отношения</emphasis> &lt; <emphasis>сдвиговое-выражение</emphasis></code></p>
    <p><code>    <emphasis>выражение-отношения</emphasis> &gt; <emphasis>сдвиговое-выражение</emphasis></code></p>
    <p><code>    <emphasis>выражение-отношения</emphasis> &lt;= <emphasis>сдвиговое-выражение</emphasis></code></p>
    <p><code>    <emphasis>выражение-отношения</emphasis> &gt;= <emphasis>сдвиговое-выражение</emphasis></code></p>
    <p><code><emphasis>сдвиговое-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>аддитивное-выражение</emphasis></code></p>
    <p><code>    <emphasis>сдвиговое-выражение</emphasis> &gt;&gt; <emphasis>аддитивное-выражение</emphasis></code></p>
    <p><code>    <emphasis>сдвиговое-выражение</emphasis> &lt;&lt; <emphasis>аддитивное-выражение</emphasis></code></p>
    <p><code><emphasis>аддитивное-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>мультипликативное-выражение</emphasis></code></p>
    <p><code>    <emphasis>аддитивное-выражение</emphasis> + <emphasis>мультипликативное-выражение</emphasis></code></p>
    <p><code>    <emphasis>аддитивное-выражение</emphasis> - <emphasis>мультипликативное-выражение</emphasis></code></p>
    <p><code><emphasis>мультипликативное-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
    <p><code>    <emphasis>мультипликативное-выражение</emphasis> * <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
    <p><code>    <emphasis>мультипликативное-выражение</emphasis> / <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
    <p><code>    <emphasis>мультипликативное-выражение</emphasis> % <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
    <p><code><emphasis>выражение-приведенное-к-типу</emphasis>:</code></p>
    <p><code>    <emphasis>унарное-выражение</emphasis></code></p>
    <p><code>    ( <emphasis>имя-типа</emphasis> ) <emphasis>выражение-приведенное-к-типу</emphasis></code></p>
    <p><code><emphasis>унарное-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>постфиксное –выражение</emphasis></code></p>
    <p><code>    ++ <emphasis>унарное-выражение</emphasis></code></p>
    <p><code>    -- <emphasis>унарное-выражение</emphasis></code></p>
    <p><code>    <emphasis>унарный-оператор выражение-приведенное-к-типу</emphasis></code></p>
    <p><code>    sizeof <emphasis>унарное-выражение</emphasis></code></p>
    <p><code>    sizeof( <emphasis>имя-типа</emphasis> )</code></p>
    <p><code><emphasis>унарный-оператор</emphasis>: один из</code></p>
    <p><code>    &amp;   *   +   -   ~   !</code></p>
    <p><code><emphasis>постфиксное-выражение</emphasis>:</code></p>
    <p><code>    <emphasis>первичное-выражение</emphasis></code></p>
    <p><code>    <emphasis>постфиксное-выражение</emphasis> [ <emphasis>выражение</emphasis> ]</code></p>
    <p><code>    <emphasis>постфиксное-выражение</emphasis> ( <emphasis>список-аргументов-выражений<sub>необ</sub></emphasis> )</code></p>
    <p><code>    <emphasis>постфиксное-выражение</emphasis> , <emphasis>идентификатор</emphasis></code></p>
    <p><code>    <emphasis>постфиксное-выражение</emphasis> -&gt; <emphasis>идентификатор</emphasis></code></p>
    <p><code>    <emphasis>постфиксное-выражение</emphasis> ++ </code></p>
    <p><code>    <emphasis>постфиксное-выражение</emphasis> --</code></p>
    <p><code><emphasis>первичное -выражение</emphasis>:</code></p>
    <p><code>    <emphasis>идентификатор</emphasis></code></p>
    <p><code>    <emphasis>константа</emphasis></code></p>
    <p><code>    <emphasis>строка</emphasis></code></p>
    <p><code>    ( <emphasis>выражение</emphasis> )</code></p>
    <p><code><emphasis>список-аргументов-выражений</emphasis>:</code></p>
    <p><code>    <emphasis>выражение-присваивания</emphasis></code></p>
    <p><code>    <emphasis>список-аргументов-выражений</emphasis> , <emphasis>выражение-присваивания</emphasis></code></p>
    <p><code><emphasis>константа</emphasis>:</code></p>
    <p><code>    <emphasis>целая-константа</emphasis></code></p>
    <p><code>    <emphasis>символьная-константа</emphasis></code></p>
    <p><code>    <emphasis>константа-с-плавающей-точкой</emphasis></code></p>
    <p><code>    <emphasis>константа-перечисление</emphasis></code></p>
    <p>Ниже приводится грамматика языка препроцессора в виде перечня структур управляющих строк. Для механического получения программы грамматического разбора она не годится. Грамматика включает символ <emphasis>текст</emphasis>, который означает текст обычной программы, безусловные управляющие строки препроцессора и его законченные условные конструкции. </p>
    <p><code><emphasis>управляющая-строка</emphasis>:</code></p>
    <p><code>    #define <emphasis>идентификатор последовательность-лексем</emphasis></code></p>
    <p><code>    #define <emphasis>идентификатор</emphasis> ( <emphasis>идентификатор</emphasis>, ..., <emphasis>идентификатор</emphasis>) <emphasis>последовательность-лексем</emphasis> </code></p>
    <p><code>    #undef <emphasis>идентификатор</emphasis></code></p>
    <p><code>    #include &lt;<emphasis>имя-файла</emphasis>&gt;</code></p>
    <p><code>    #include "<emphasis>имя-файла</emphasis>"</code></p>
    <p><code>    #include <emphasis>последовательность-лексем</emphasis></code></p>
    <p><code>    #line <emphasis>константа</emphasis> "<emphasis>идентификатор</emphasis>"</code></p>
    <p><code>    #line <emphasis>константа</emphasis></code></p>
    <p><code>    #error <emphasis>последовательность-лексем</emphasis><sub><emphasis>необ</emphasis></sub></code></p>
    <p><code>    #pragma <emphasis>последовательность-лексем</emphasis><sub><emphasis>необ</emphasis></sub></code></p>
    <p><code>    #</code></p>
    <p><code>    <emphasis>условная-конструкция-препроцессора</emphasis></code></p>
    <p><code><emphasis>условная-конструкция-препроцессора</emphasis>:</code></p>
    <p><code>    <emphasis>if-строка текст elif-части else-часть</emphasis><sub><emphasis>необ</emphasis></sub> #endif</code></p>
    <p><code><emphasis>if-строка</emphasis>:</code></p>
    <p><code>    #if <emphasis>константное-выражение</emphasis></code></p>
    <p><code>    #ifdef <emphasis>идентификатор</emphasis></code></p>
    <p><code>    #ifndef <emphasis>идентификатор</emphasis></code></p>
    <p><code><emphasis>elif-части</emphasis>:</code></p>
    <p><code>    <emphasis>elif-строка текст</emphasis></code></p>
    <p><code>    <emphasis>elif-части</emphasis><sub><emphasis>необ</emphasis></sub></code></p>
    <p><code><emphasis>elif-строка</emphasis>:</code></p>
    <p><code>    #elif <emphasis>константное-выражение</emphasis></code></p>
    <p><code><emphasis>else-часть</emphasis>:</code></p>
    <p><code>    <emphasis>else-строка текст</emphasis></code></p>
    <p><code><emphasis>else-строка</emphasis>:</code></p>
    <p><code>    #else</code></p>
   </section>
  </section>
  <section>
   <title>
    <p>Приложение B. Стандартная библиотека</p>
   </title>
   <section>
    <p>Настоящее приложение представляет собой краткое изложение библиотеки, утвержденной в качестве ANSI-стандарта. Сама по себе библиотека не является частью языка, однако, заложенный в ней набор функций, а также определений типов и макросов составляет системную среду, поддерживающую стандарт Си. Мы не приводим здесь несколько функций с ограниченной областью применения – те, которые легко синтезируются из других функций, а также опускаем все то, что касается многобайтовых символов и специфики, обусловленной языком, национальными особенностями и культурой. </p>
    <p>Функции, типы и макросы объявляются в следующих стандартных заголовочных файлах: </p>
    <p><code><strong>&lt;assert.h&gt;</strong></code></p>
    <p><code><strong>&lt;ctype.h&gt;</strong></code></p>
    <p><code><strong>&lt;errno.h&gt;</strong></code></p>
    <p><code><strong>&lt;float.h&gt;</strong></code></p>
    <p><code><strong>&lt;limits.h&gt;</strong></code></p>
    <p><code><strong>&lt;locale.h&gt;</strong></code></p>
    <p><code><strong>&lt;math.h&gt;</strong></code></p>
    <p><code><strong>&lt;setjmp.h&gt;</strong></code></p>
    <p><code><strong>&lt;signal.h&gt;</strong></code></p>
    <p><code><strong>&lt;stdarg.h&gt;</strong></code></p>
    <p><code><strong>&lt;stddef.h&gt;</strong></code></p>
    <p><code><strong>&lt;stdio.h&gt;</strong></code></p>
    <p><code><strong>&lt;stdlib.h&gt;</strong></code></p>
    <p><code><strong>&lt;string.h&gt;</strong></code></p>
    <p><code><strong>&lt;time.h&gt;</strong></code></p>
    <p>Доступ к заголовочному файлу осуществляется с помощью строки препроцессора </p>
    <p><code>#include <emphasis>&lt;заголовочный файл&gt;</emphasis></code></p>
    <p>Заголовочные файлы можно включать в любом порядке и сколько угодно раз. Строка <emphasis>#include</emphasis> не должна быть внутри внешнего объявления или определения и должна встретиться раньше, чем что-нибудь из включаемого заголовочного файла будет востребовано. В конкретной реализации заголовочный файл может и не быть исходным файлом. </p>
    <p>Внешние идентификаторы, начинающиеся со знака подчеркивания, а также все другие идентификаторы, начинающиеся с двух знаков подчеркивания или с подчеркивания и заглавной буквы, зарезервированы для использования в библиотеке. </p>
   </section>
   <section>
    <title>
     <p>B1. Ввод-вывод: ‹stdio.h› </p>
    </title>
    <section>
     <p>Определенные в <strong>&lt;stdio.h&gt;</strong> функции ввода-вывода, а также типы и макросы составляют приблизительно одну треть библиотеки. </p>
     <p><emphasis>Поток</emphasis> - это источник или получатель данных; его можно связать с диском или с каким-то другим внешним устройством. Библиотека поддерживает два вида потоков: <emphasis>текстовый</emphasis> и <emphasis>бинарный</emphasis>, хотя на некоторых системах, в частности в UNIXe, они не различаются. <emphasis>Текстовый поток</emphasis> - это последовательность строк; каждая строка имеет нуль или более символов и заканчивается символом '\n'. Операционная среда может потребовать коррекции текстового потока (например, перевода '\n' в символы возврат-каретки и перевод-строки). </p>
     <p><emphasis>Бинарный поток</emphasis> - это последовательность непреобразованных байтов, представляющих собой некоторые промежуточные данные, которые обладают тем свойством, что если их записать, а затем прочесть той же системой ввода- вывода, то мы получим информацию, совпадающую с исходной. </p>
     <p>Поток соединяется с файлом или устройством посредством его <emphasis>открытия</emphasis>, указанная связь разрывается путем <emphasis>закрытия</emphasis> потока. Открытие файла возвращает указатель на объект типа <emphasis>FILE</emphasis>, который содержит всю информацию, необходимую для управления этим потоком. Если не возникает двусмысленности, мы будем пользоваться терминами "файловый указатель" и "поток" как равнозначными. </p>
     <p>Когда программа начинает работу, уже открыты три потока: <strong>stdin</strong>, <strong>stdout</strong> и <strong>stderr</strong>. </p>
    </section>
    <section>
     <title>
      <p>B1.1. Операции над файлами</p>
     </title>
     <p>Ниже перечислены функции, оперирующие с файлами. Тип <strong>size_t</strong> - беззнаковый целочисленный тип, используемый для описания результата оператора <strong>sizeof</strong>. </p>
     <p><code>FILE *fopen(const char *filename, const char *mode);</code></p>
     <p><strong>fopen</strong> открывает файл с заданным именем и возвращает поток или NULL, если попытка открытия оказалась неудачной. Режим <emphasis>mode</emphasis> допускает следующие значения: </p>
     <table>
      <tr>
       <td>"r"</td>
       <td>текстовый файл открывается для чтения (от <emphasis>read</emphasis> (англ.) - читать);</td>
      </tr>
      <tr>
       <td>"w"</td>
       <td>текстовый файл создается для записи; старое содержимое (если оно было) выбрасывается (от <emphasis>write</emphasis> (англ.) - писать);</td>
      </tr>
      <tr>
       <td>"а"</td>
       <td>текстовый файл открывается или создается для записи в конец файла (от <emphasis>append</emphasis> (англ.) - добавлять);</td>
      </tr>
      <tr>
       <td>"r+"</td>
       <td>текстовый файл открывается для исправления (т. е. для чтения и для записи);</td>
      </tr>
      <tr>
       <td>"w+"</td>
       <td>текстовый файл создается для исправления; старое содержимое (если оно было) выбрасывается;</td>
      </tr>
      <tr>
       <td>"a+"</td>
       <td>текстовый файл открывается или создается для исправления уже существующей информации и добавления новой в конец файла. </td>
      </tr>
     </table>
     <p>Режим "исправления" позволяет читать и писать в один и тот же файл; при переходах от операций чтения к операциям записи и обратно должны осуществляться обращения к <strong>fflush</strong> или к функции позиционирования файла. Если указатель режима дополнить буквой <emphasis>b</emphasis> (например "rb" или "w+b"), то это будет означать, что файл бинарный. Ограничение на длину имени файла задано константой FILENAME_MAX. Константа FOPEN_MAX ограничивает число одновременно открытых файлов. </p>
     <p><code>FILE *freopen(const char *filename, const char *mode, FILE *stream);</code></p>
     <p><strong>freopen</strong> открывает файл с указанным режимом и связывает его с потоком <emphasis>stream</emphasis>. Она возвращает <emphasis>stream</emphasis> или, в случае ошибки, NULL. Обычно <emphasis>freopen</emphasis> используется для замены файлов, связанных с <emphasis>stdin</emphasis>, <emphasis>stdout</emphasis> или <emphasis>stderr</emphasis>, другими файлами. </p>
     <p><code>int fflush(FILE *stream);</code></p>
     <p>Применяемая к потоку вывода функция <strong>fflush</strong> производит дозапись всех оставшихся в буфере (еще не записанных) данных, для потока ввода эта функция не определена. Возвращает EOF в случае возникшей при записи ошибки или нуль в противном случае. Обращение вида <emphasis>fflush</emphasis>(NULL) выполняет указанные операции для всех потоков вывода. </p>
     <p><code>int fclose(FILE *stream);</code></p>
     <p><strong>fсlose</strong> производит дозапись еще не записанных буферизованных данных, сбрасывает несчитанный буферизованный ввод, освобождает все автоматически запрошенные буфера, после чего закрывает поток. Возвращает EOF в случае ошибки и нуль в противном случае. </p>
     <p><code>int remove(const char *filename);</code></p>
     <p><strong>remove</strong> удаляет файл с указанным именем; последующая попытка открыть файл с этим именем вызовет ошибку. Возвращает ненулевое значение в случае неудачной попытки. </p>
     <p><code>int rename(const char *oldname, const char *newname);</code></p>
     <p><strong>rename</strong> заменяет имя файла; возвращает ненулевое значение в случае, если попытка изменить имя оказалась неудачной. Первый параметр задает старое имя, второй - новое. </p>
     <p><code>FILE *tmpfile(void);</code></p>
     <p><strong>tmpfile</strong> создает временный файл с режимом доступа "wb+", который автоматически удаляется при его закрытии или обычном завершении программой своей работы. Эта функция возвращает поток или, если не смогла создать файл, NULL. </p>
     <p><code>char *tmpnam(char s[L_tmpnam]);</code></p>
     <p><strong>tmpnam</strong>(NULL) создает строку, не совпадающую ни с одним из имен существующих файлов, и возвращает указатель на внутренний статический массив. <emphasis>tmpnam(s)</emphasis> запоминает строку в <emphasis>s</emphasis> и возвращает ее в качестве значения функции; длина <emphasis>s</emphasis> должна быть не менее <strong>L_tmpnam</strong>. При каждом вызове <emphasis>tmpnam</emphasis> генерируется новое имя; при этом гарантируется не более TMPMAX различных имен за один сеанс работы программы. Заметим, что <emphasis>tmpnam</emphasis> создает имя, а не файл. </p>
     <p><code>int setvbuf(FILE *stream, char *buf, int mode, size_t size);</code></p>
     <p><strong>setvbuf</strong> управляет буферизацией потока; к ней следует обращаться прежде, чем будет выполняться чтение, запись или какая-либо другая операция, <emphasis>mode</emphasis> со значением <strong>_IOFBF</strong> вызывает полную буферизацию, с <strong>_IOLBF</strong> - "построчную" буферизацию текстового файла, a <emphasis>mode</emphasis> со значением <strong>_IONBF</strong> отменяет всякую буферизацию. Если параметр <emphasis>buf</emphasis> не есть NULL, то его значение - указатель на буфер, в противном случае под буфер будет запрашиваться память. Параметр <emphasis>size</emphasis> задает размер буфера. Функция <emphasis>setvbuf</emphasis> в случае ошибки выдает ненулевое значение. </p>
     <p><code>void setbuf(FILE *stream, char *buf);</code></p>
     <p>Если <emphasis>buf</emphasis> есть NULL, то для потока <emphasis>stream</emphasis> буферизация выключается. В противном случае вызов <strong>setbuf</strong> приведет к тем же действиям, что и вызов (void) setvbuf (stream, buf, _IOFBF, BUFSIZ). </p>
    </section>
    <section>
     <title>
      <p>B1.2. Форматный вывод</p>
     </title>
     <p>Функции <strong>printf</strong> осуществляют вывод информации по формату. </p>
     <p><code>int fprintf(FILE *stream, const char *format, ...);</code></p>
     <p><strong>fprintf</strong> преобразует и пишет вывод в поток <emphasis>stream</emphasis> под управлением <emphasis>format</emphasis>. Возвращаемое значение - число записанных символов или, в случае ошибки, отрицательное значение. </p>
     <p><emphasis>Форматная строка</emphasis> содержит два вида объектов: <emphasis>обычные символы</emphasis>, копируемые в выводной поток, и <emphasis>спецификации преобразования</emphasis>, которые вызывают преобразование и печать остальных аргументов в том порядке, как они перечислены. Каждая спецификация преобразования начинается с <strong>%</strong> и заканчивается символом-спецификатором преобразования. Между % и символом- спецификатором в порядке, в котором они здесь перечислены, могут быть расположены следующие элементы информации: </p>
     <p>• Флаги (в любом порядке), модифицирующие спецификацию: </p>
     <table>
      <tr>
       <td><strong>-</strong></td>
       <td>указывает на то, что преобразованный аргумент должен быть прижат к левому краю поля;</td>
      </tr>
      <tr>
       <td><strong>+</strong></td>
       <td>предписывает печатать число всегда со знаком;</td>
      </tr>
      <tr>
       <td><emphasis>пробел</emphasis></td>
       <td>если первый символ - не знак, то числу должен предшествовать пробел;</td>
      </tr>
      <tr>
       <td><strong>0</strong></td>
       <td>указывает, что числа должны дополняться слева нулями до всей ширины поля;</td>
      </tr>
      <tr>
       <td><strong>#</strong></td>
       <td>указывает на одну из следующих форм вывода: для <emphasis>o</emphasis> первой цифрой должен быть 0; для <emphasis>x</emphasis> или <emphasis>X</emphasis> ненулевому результату должны предшествовать 0x или 0X; для <emphasis>e</emphasis>, <emphasis>E</emphasis>, <emphasis>f</emphasis>, <emphasis>g</emphasis> и <emphasis>G</emphasis> вывод должен обязательно содержать десятичную точку; для <emphasis>g</emphasis> и <emphasis>G</emphasis> завершающие нули не отбрасываются. </td>
      </tr>
     </table>
     <p>• Число, специфицирующее минимальную ширину поля. Преобразованный аргумент будет напечатан в поле, размер которого не меньше указанной ширины, а если потребуется, в поле большего размера. Если число символов преобразованного аргумента меньше ширины поля, то поле будет дополнено слева (или справа, если число прижимается к левому краю). Обычно поле дополняется пробелами (или нулями, если присутствует флаг дополнения нулями). </p>
     <p>• Точка, отделяющая указатель ширины поля от указателя точности. </p>
     <p>• Число, задающее точность, которое специфицирует максимальное количество символов, печатаемых из строки, или количество цифр после десятичной точки в преобразованиях e, E или f, или количество значащих цифр для g или G - преобразования, или минимальное количество цифр при печати целого (до необходимой ширины поля число дополняется слева нулями). </p>
     <p>• Модификаторы <strong>h</strong>, <strong>l</strong> (буква ell) или <strong>L</strong>. "h" указывает на то, что соответствующий аргумент должен печататься как <emphasis>short</emphasis> или <emphasis>unsigned short</emphasis>; "l" сообщает, что аргумент имеет тип <emphasis>long</emphasis> или <emphasis>unsigned long</emphasis>; "L" информирует, что аргумент принадлежит типу <emphasis>long double</emphasis>. </p>
     <p>Ширина, или точность, или обе эти характеристики могут быть специфицированы с помощью <strong>*</strong>; в этом случае необходимое число "извлекается" из следующего аргумента, который должен иметь тип <emphasis>int</emphasis> (в случае двух звездочек используются два аргумента). </p>
     <p>Символы-спецификаторы и разъяснение их смысла приведены в таблице B-1. Если за <strong>%</strong> нет правильного символа-спецификатора, результат не определен. </p>
     <p><code>int printf(const char *format, ...); </code></p>
     <p><strong>printf</strong>(...) полностью эквивалентна <emphasis>fprintf</emphasis>(stdout, ...). </p>
     <p><code>int sprintf(char *s, const char *format, ...) </code></p>
     <p><strong>sprintf</strong> действует так же, как и <emphasis>printf</emphasis>, только вывод осуществляет в строку <emphasis>s</emphasis>, завершая ее символом '\0'. Строка <emphasis>s</emphasis> должна быть достаточно большой, чтобы вмещать результат вывода. Возвращает количество записанных символов, в число которых символ '\0' не входит. </p>
     <p><code>int vprintf (const char *format, va_list arg) </code></p>
     <p><code>int vfprintf (FILE *stream, const char *format, va_list arg) </code></p>
     <p><code>int vsprintf (char *s, const char *format, va_list arg) </code></p>
     <p>Функции <strong>vprintf</strong>, <strong>vfprintf</strong> и <strong>vsprintf</strong> эквивалентны соответствующим <emphasis>printf</emphasis>- функциям с той лишь разницей, что переменный список аргументов представлен параметром <emphasis>arg</emphasis>, инициализированным макросом <emphasis>va_start</emphasis> и, возможно, вызовами <emphasis>va_arg</emphasis> (см. в B7 описание <strong>&lt;stdarg.h&gt;</strong>). </p>
     <p><strong>Таблица B-1. Преобразования <emphasis>printf</emphasis></strong></p>
     <table>
      <tr>
       <th>Символ</th>
       <th>Тип аргумента; вид печати</th>
      </tr>
      <tr>
       <td><strong>d</strong>, <strong>i</strong></td>
       <td><strong>int</strong>; знаковая десятичная запись</td>
      </tr>
      <tr>
       <td><strong>o</strong></td>
       <td><strong>unsigned int</strong>; беззнаковая восьмеричная запись (без 0 слева) </td>
      </tr>
      <tr>
       <td><strong>x</strong>, <strong>X</strong></td>
       <td><strong>unsigned int</strong>; беззнаковая шестнадцатеричная запись (без 0x или 0X слева), в качестве цифр от 10 до 15 используются abcdef для x и ABCDEF для X</td>
      </tr>
      <tr>
       <td><strong>u</strong></td>
       <td><strong>unsigned int</strong>; беззнаковое десятичное целое</td>
      </tr>
      <tr>
       <td><strong>c</strong></td>
       <td><strong>int</strong>; единичный символ после преобразования в <emphasis>unsigned char</emphasis></td>
      </tr>
      <tr>
       <td><strong>s</strong></td>
       <td><strong>char *</strong>; символы строки печатаются, пока не встретится '\0' или не исчерпается количество символов, указанное точностью</td>
      </tr>
      <tr>
       <td><strong>f</strong></td>
       <td><strong>double</strong>; десятичная запись вида [-]mmm.ddd, где количество <emphasis>d</emphasis> специфицируется точностью. По умолчанию точность равна 6; нулевая точность подавляет печать десятичной точки</td>
      </tr>
      <tr>
       <td><strong>e</strong>, <strong>E</strong></td>
       <td><strong>double</strong>; десятичная запись вида [-]m.dddddde±xx или запись вида [-]m.ddddddE±xx, где количество <emphasis>d</emphasis> специфицируется точностью. По умолчанию точность равна 6; нулевая точность подавляет печать десятичной точки</td>
      </tr>
      <tr>
       <td><strong>g</strong>, <strong>G</strong></td>
       <td><strong>double</strong>; используется <strong>%e</strong> и <strong>%E</strong>, если порядок меньше -4 или больше или равен точности; в противном случае используется <strong>%f</strong>. Завершающие нули и точка в конце не печатаются</td>
      </tr>
      <tr>
       <td><strong>p</strong></td>
       <td><strong>void *</strong>; печатает в виде указателя (представление зависит от реализации</td>
      </tr>
      <tr>
       <td><strong>n</strong></td>
       <td><strong>int *</strong>; число символов, напечатанных к данному моменту данным вызовом <emphasis>printf</emphasis>, <emphasis>записывается</emphasis> в аргумент. Никакие другие аргументы не преобразуются</td>
      </tr>
      <tr>
       <td><strong>%</strong></td>
       <td>никакие аргументы не преобразуются; печатается <strong>%</strong></td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>B1.3. Форматный ввод</p>
     </title>
     <p>Функции <strong>scanf</strong> имеют дело с форматным преобразованием при вводе</p>
     <p><code>int fscanf(FILE *stream, const char *format, ...); </code></p>
     <p><strong>fscanf</strong> читает данные из потока <emphasis>stream</emphasis> под управлением <emphasis>format</emphasis> и преобразованные величины присваивает по порядку аргументам, каждый из которых должен быть указателем. Завершает работу, если исчерпался формат. Выдает EOF по исчерпании файла или перед любым преобразованием, если возникла ошибка; в остальных случаях функция возвращает количество преобразованных и введенных элементов. </p>
     <p>Форматная строка обычно содержит спецификации преобразования, которые используются для управления вводом. В форматную строку могут входить: </p>
     <p>• пробелы и табуляции, которые игнорируются;</p>
     <p>• обычные символы (кроме <strong>%</strong>), которые ожидаются в потоке ввода среди символов, отличных от символов-разделителей; </p>
     <p>• спецификации преобразования, состоящие из <strong>%</strong>; необязательного знака <strong>*</strong>, подавляющего присваивание; необязательного числа, специфицирующего максимальную ширину поля; необязательных <strong>h</strong>, <strong>l</strong> или <strong>L</strong>, указывающих размер присваиваемого значения, и символа-спецификатора преобразования. </p>
     <p>Спецификация преобразования определяет преобразование следующего поля ввода. Обычно результат размещается в переменной, на которую указывает соответствующий аргумент. Однако если присваивание подавляется с помощью знака <strong>*</strong>, как, например, в %*s, то поле ввода просто пропускается, и никакого присваивания не происходят. Поле ввода определяется как строка символов, отличных от символов-разделителей; при этом ввод строки прекращается при выполнении любого из двух условий: если встретился символ-разделитель или если ширина поля (в случае, когда она указана) исчерпана. Из этого следует, что при переходе к следующему полю <emphasis>scanf</emphasis> может "перешагивать" через границы строк, поскольку символ новой строки является символом-разделителем. (Под символами-разделителями понимаются символы пробела, табуляции, новой строки, возврата каретки, вертикальной табуляции и смены страницы.) </p>
     <p>Символ-спецификатор указывает на способ интерпретации поля ввода. Соответствующий аргумент должен быть указателем. Список допустимых символов-спецификаторов приводится в таблице B-2. </p>
     <p>Символам-спецификаторам <strong>d</strong>, <strong>i</strong>, <strong>n</strong>, <strong>o</strong>, <strong>u</strong> и <strong>x</strong> может предшествовать <strong>h</strong>, если аргумент есть указатель на <emphasis>short</emphasis> (а не <emphasis>int</emphasis>) или <strong>l</strong> (буква ell), если аргумент есть указатель на <emphasis>long</emphasis>. Символам-спецификаторам <strong>e</strong>, <strong>f</strong> и <strong>g</strong> может предшествовать <strong>l</strong>, если аргумент - указатель на <emphasis>double</emphasis> (а не <emphasis>float</emphasis>), или <strong>L</strong>, если аргумент - указатель на <emphasis>long double</emphasis>. </p>
     <p><code>int scanf (const char *format, ...); </code></p>
     <p><strong>scanf</strong>(...) делает то же, что и <emphasis>fscanf</emphasis>(stdin, ...). </p>
     <p><code>int sscanf (const char *s, const char *format, ...); </code></p>
     <p><strong>sscanf</strong>(s, ...) делает то же, что и <emphasis>scanf</emphasis>(...), только ввод символов осуществляет из строки <emphasis>s</emphasis>. </p>
     <p><strong>Таблица B-2. Преобразования <emphasis>scanf</emphasis></strong></p>
     <table>
      <tr>
       <th>Символ</th>
       <th>Данные на вводе; тип аргумента</th>
      </tr>
      <tr>
       <td><strong>d</strong></td>
       <td>десятичное целое; <strong>int *</strong></td>
      </tr>
      <tr>
       <td><strong>i</strong></td>
       <td>целое: <strong>int *</strong>. Целое может быть восьмеричным (с нулем слева) или шестнадцатеричным (с 0x или 0X слева) </td>
      </tr>
      <tr>
       <td><strong>o</strong></td>
       <td>восьмеричное целое (с нулем слева или без него); <strong>int *</strong></td>
      </tr>
      <tr>
       <td><strong>u</strong></td>
       <td>беззнаковое десятичное целое; <strong>unsigned int *</strong></td>
      </tr>
      <tr>
       <td><strong>x</strong></td>
       <td>шестнадцатеричное целое (с 0x или 0X слева или без них): <strong>int *</strong></td>
      </tr>
      <tr>
       <td><strong>c</strong></td>
       <td>символы, <strong>char *</strong>. Символы ввода размещаются в указанном массиве в количестве, заданном шириной поля; по умолчанию это количество равно 1. Символ'\0' не добавляется. Символы-разделители здесь рассматриваются как обычные символы и поступают в аргумент. Чтобы прочесть следующий символ-разделитель, используйте %1s</td>
      </tr>
      <tr>
       <td><strong>s</strong></td>
       <td>строка символов, отличных от символов-разделителей (записывается без кавычек); <strong>char *</strong>, указывающий на массив размера достаточного, чтобы вместить строку и добавляемый к ней символ '\0'</td>
      </tr>
      <tr>
       <td><strong>e</strong>, <strong>f</strong>, <strong>g</strong></td>
       <td>число с плавающей точкой; <strong>float *</strong>. Формат ввода для <emphasis>float</emphasis> состоит из необязательного знака, строки цифр, возможно с десятичной точкой, и необязательного порядка, состоящего из <strong>E</strong> или <strong>e</strong> и целого, возможно со знаком</td>
      </tr>
      <tr>
       <td><strong>p</strong></td>
       <td>значение указателя в виде, в котором printf ("%р") его напечатает; <strong>void *</strong></td>
      </tr>
      <tr>
       <td><strong>n</strong></td>
       <td>записывает в аргумент число символов, прочитанных к этому моменту в этом вызове; <strong>int *</strong>. Никакого чтения ввода не происходит. Счетчик числа введенных элементов не увеличивается</td>
      </tr>
      <tr>
       <td><strong>[...]</strong></td>
       <td>выбирает из ввода самую длинную непустую строку, состоящую из символов, заданных в квадратных скобках: <strong>char *</strong>. В конец строки добавляется '\0'. Спецификатор вида <strong>[]...]</strong> включает <strong>]</strong> в задаваемое множество символов</td>
      </tr>
      <tr>
       <td><strong>[^...]</strong></td>
       <td>выбирает из ввода самую длинную непустую строку, состоящую из символов, не входящих в заданное в скобках множество. В конец добавляется '\0'. Спецификатор вида <strong>[^]...]</strong> включает <strong>]</strong> в задаваемое множество символов</td>
      </tr>
      <tr>
       <td><strong>%</strong></td>
       <td>обычный символ <strong>%</strong>; присваивание не делается</td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>B1.4. Функции ввода-вывода символов</p>
     </title>
     <p><code>int fgetc(FILE *stream); </code></p>
     <p><strong>fgetc</strong> возвращает следующий символ из потока <emphasis>stream</emphasis> в виде <emphasis>unsigned char</emphasis> (переведенную в <emphasis>int</emphasis>) или EOF, если исчерпан файл или обнаружена ошибка. </p>
     <p><code>char *fgets(char *s, int n, FILE *stream); </code></p>
     <p><strong>fgets</strong> читает не более <emphasis>n-1</emphasis> символов в массив <emphasis>s</emphasis>, прекращая чтение, если встретился символ новой строки, который включается в массив; кроме того, записывает в массив '\0'. Функция <emphasis>fgets</emphasis> возвращает <emphasis>s</emphasis> или, если исчерпан файл или обнаружена ошибка, NULL. </p>
     <p><code>int fputc(int с, FILE *stream); </code></p>
     <p><strong>fputc</strong> пишет символ <emphasis>c</emphasis> (переведенный в <emphasis>unsigned char</emphasis>) в <emphasis>stream</emphasis>. Возвращает записанный символ или EOF в случае ошибки. </p>
     <p><code>int fputs(const char *s, FILE *stream); </code></p>
     <p><strong>fputs</strong> пишет строку <emphasis>s</emphasis> (которая может не иметь '\n' ) в <emphasis>stream</emphasis>; возвращает неотрицательное целое или EOF в случае ошибки. </p>
     <p><code>int getc(FILE *stream); </code></p>
     <p><strong>getc</strong> делает то же, что и <emphasis>fgetc</emphasis>, но в отличие от последней, если она - макрос, <emphasis>stream</emphasis> может браться более одного раза. </p>
     <p><code>int getchar(void); </code></p>
     <p><strong>getchar</strong>() делает то же, что <emphasis>getc</emphasis>(stdin). </p>
     <p><code>char *gets(char *s); </code></p>
     <p><strong>gets</strong> читает следующую строку ввода в массив <emphasis>s</emphasis>, заменяя символ новой строки на '\0'. Возвращает <emphasis>s</emphasis> или, если исчерпан файл или обнаружена ошибка, NULL. </p>
     <p><code>int putc(int с, FILE *stream); </code></p>
     <p><strong>putc</strong> делает то же, что и <emphasis>fputc</emphasis>, но в отличие от последней, если <emphasis>putc</emphasis> - макрос, значение <emphasis>stream</emphasis> может браться более одного раза. </p>
     <p><code>int putchar(int c); </code></p>
     <p><strong>putchar</strong>(c) делает тоже, что <emphasis>putc</emphasis>(c, stdout). </p>
     <p><code>int puts(const char *s); </code></p>
     <p><strong>puts</strong> пишет строку <emphasis>s</emphasis> и символ новой строки в <emphasis>stdout</emphasis>. Возвращает EOF в случае ошибки, или неотрицательное значение, если запись прошла нормально. </p>
     <p><code>int ungetc(int с, FILE *stream); </code></p>
     <p><strong>ungetc</strong> отправляет символ <emphasis>c</emphasis> (переведенный в <emphasis>unsigned char</emphasis>) обратно в <emphasis>stream</emphasis>; при следующем чтении из <emphasis>stream</emphasis> он будет получен снова. Для каждого потока вернуть можно не более одного символа. Нельзя возвращать EOF. В качестве результата <emphasis>ungetc</emphasis> выдает отправленный назад символ или, в случае ошибки, EOF. </p>
    </section>
    <section>
     <title>
      <p>B1.5. Функции прямого ввода-вывода</p>
     </title>
     <p><code>size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream); </code></p>
     <p><strong>fread</strong> читает из потока <emphasis>stream</emphasis> в массив <emphasis>ptr</emphasis> не более <emphasis>nobj</emphasis> объектов размера <emphasis>size</emphasis>. Она возвращает количество прочитанных объектов, которое может быть меньше заявленного. Для индикации состояния после чтения следует использовать <emphasis>feof</emphasis> и <emphasis>ferror</emphasis>. </p>
     <p><code>size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream); </code></p>
     <p><strong>fwrite</strong> пишет из массива <emphasis>ptr</emphasis> в <emphasis>stream nobj</emphasis> объектов размера <emphasis>size</emphasis>; возвращает число записанных объектов, которое в случае ошибки меньше <emphasis>nobj</emphasis>. </p>
    </section>
    <section>
     <title>
      <p>B1.6. Функции позиционирования файла</p>
     </title>
     <p><code>int fseek(FILE *stream, long offset, int origin); </code></p>
     <p><strong>fseek</strong> устанавливает позицию для <emphasis>stream</emphasis>; последующее чтение или запись будет производиться с этой позиции. В случае бинарного файла позиция устанавливается со смещением <emphasis>offset</emphasis> - относительно начала, если <emphasis>origin</emphasis> равен <strong>SEEK_SET</strong>; относительно текущей позиции, если <emphasis>origin</emphasis> равен <strong>SEEK_CUR</strong>; и относительно конца файла, если <emphasis>origin</emphasis> равен <strong>SEEK_END</strong>. Для текстового файла <emphasis>offset</emphasis> должен быть нулем или значением, полученным с помощью вызова функции <emphasis>ftell</emphasis>. При работе с текстовым файлом <emphasis>origin</emphasis> всегда должен быть равен <strong>SEEK_SET</strong>. </p>
     <p><code>long ftell(FILE *stream); </code></p>
     <p><strong>ftell</strong> возвращает текущую позицию потока <emphasis>stream</emphasis> или -1L, в случае ошибки. </p>
     <p><code>void rewind(FILE *stream); </code></p>
     <p><strong>rewind</strong>(fp) делает то же, что и fseek(fp, 0L, SEEK_SET); clearerr(fp). </p>
     <p><code>int fgetpos(FILE *stream, fpos_t *ptr); </code></p>
     <p><strong>fgetpos</strong> записывает текущую позицию потока <emphasis>stream</emphasis> в <emphasis>*ptr</emphasis> для последующего использования ее в <emphasis>fsetpos</emphasis>. Тип <strong>fpos_t</strong> позволяет хранить такого рода значения, В случае ошибки <emphasis>fgetpos</emphasis> возвращает ненулевое значение. </p>
     <p><code>int fsetpos(FILE *stream, const fpos_t *ptr); </code></p>
     <p><strong>fsetpos</strong> устанавливает позицию в <emphasis>stream</emphasis>, читая ее из <emphasis>*ptr</emphasis>, куда она была записана ранее с помощью <emphasis>fgetpos</emphasis>. В случае ошибки <emphasis>fsetpos</emphasis> возвращает ненулевое значение. </p>
    </section>
    <section>
     <title>
      <p>B1.7. Функции обработки ошибок</p>
     </title>
     <p>Многие функции библиотеки в случае ошибки или конца файла устанавливают индикаторы состояния. Эти индикаторы можно проверять и изменять. Кроме того, целое выражение <strong>errno</strong> (объявленное в <strong>&lt;errno.h&gt;</strong>) может содержать номер ошибки, который дает дополнительную информацию о последней из обнаруженных ошибок. </p>
     <p><code>void clearerr(FILE *stream); </code></p>
     <p><strong>clearerr</strong> очищает индикаторы конца файла и ошибки потока <emphasis>stream</emphasis>. </p>
     <p><code>int feof(FILE *stream); </code></p>
     <p><strong>feof</strong> возвращает ненулевое значение, если для потока <emphasis>stream</emphasis> установлен индикатор конца файла. </p>
     <p><code>int ferror(FILE *stream); </code></p>
     <p><strong>ferror</strong> возвращает ненулевое значение, если для потока <emphasis>stream</emphasis> установлен индикатор ошибки. </p>
     <p><code>void perror(const char *s); </code></p>
     <p><strong>perror</strong>(s) печатает <emphasis>s</emphasis> и зависимое от реализации сообщение об ошибке, соответствующее целому значению в <emphasis>errno</emphasis>, т. е. делает то же, что и обращение к функции <emphasis>fprintf</emphasis> вида</p>
     <p><code>fprintf(stderr, "%s: %s\n", s, "сообщение об ошибке") </code></p>
     <p>См. <emphasis>strerror</emphasis> в параграфе B3.</p>
    </section>
   </section>
   <section>
    <title>
     <p>B2. Проверки класса символа: ‹ctype.h›</p>
    </title>
    <p>Заголовочный файл <strong>&lt;ctype.h&gt;</strong> объявляет функции, предназначенные для проверок символов. Аргумент каждой из них имеет тип <emphasis>int</emphasis> и должен либо представлять собой EOF, либо быть значением <emphasis>unsigned char</emphasis>, приведенным к <emphasis>int</emphasis>; возвращаемое значение тоже имеет тип <emphasis>int</emphasis>. Функции возвращают ненулевое значение ("истина"), когда аргумент c удовлетворяет описанному условию или принадлежит указанному классу символов, и нуль в противном случае. </p>
    <table>
     <tr>
      <td><strong>isalnum</strong>(c)</td>
      <td><strong>isalpha</strong>(c) или <strong>isdigit</strong>(c) есть истина</td>
     </tr>
     <tr>
      <td><strong>isalpha</strong>(c) </td>
      <td><strong>isupper</strong>(c) или <strong>islower</strong>(c) есть истина</td>
     </tr>
     <tr>
      <td><strong>iscntrl</strong>(c) </td>
      <td>управляющий символ</td>
     </tr>
     <tr>
      <td><strong>isdigit</strong>(c)</td>
      <td>десятичная цифра</td>
     </tr>
     <tr>
      <td><strong>isgraph</strong>(c)</td>
      <td>печатаемый символ кроме пробела</td>
     </tr>
     <tr>
      <td><strong>islower</strong>(c)</td>
      <td>буква нижнего регистра</td>
     </tr>
     <tr>
      <td><strong>isprint</strong>(c)</td>
      <td>печатаемый символ, включая пробел</td>
     </tr>
     <tr>
      <td><strong>ispunct</strong>(c)</td>
      <td>печатаемый символ кроме пробела, буквы или цифры</td>
     </tr>
     <tr>
      <td><strong>isspace</strong>(c)</td>
      <td>пробел, смена страницы, новая строка, возврат каретки, табуляция, вертикальная табуляция</td>
     </tr>
     <tr>
      <td><strong>isupper</strong>(c)</td>
      <td>буква верхнего регистра</td>
     </tr>
     <tr>
      <td><strong>isxdigit</strong>(c) </td>
      <td>шестнадцатеричная цифра</td>
     </tr>
    </table>
    <p>В наборе семибитовых ASCII-символов печатаемые символы находятся в диапазоне от <strong>0x20</strong> (' ') до <strong>0x7E</strong> ('~'); управляющие символы - от <strong>0</strong> (<emphasis>NUL</emphasis>) до <strong>0x1F</strong> (<emphasis>US</emphasis>) и 0x7F (<emphasis>DEL</emphasis>). </p>
    <p>Помимо перечисленных есть две функции, приводящие буквы к одному из регистров: </p>
    <p><code>int <strong>tolower</strong>(int c) – переводит <emphasis>c</emphasis> на нижний регистр; </code></p>
    <p><code>int <strong>toupper</strong>(int c) - переводит <emphasis>c</emphasis> на верхний регистр.</code></p>
    <p>Если <emphasis>c</emphasis> - буква на верхнем регистре, то <emphasis>tolower</emphasis>(c) выдаст эту букву на нижнем регистре; в противном случае она вернет <emphasis>c</emphasis>. Если <emphasis>c</emphasis> - буква на нижнем регистре, то <emphasis>toupper</emphasis>(c) выдаст эту букву на верхнем регистре; в противном случае она вернет <emphasis>c</emphasis>. </p>
   </section>
   <section>
    <title>
     <p>B3. Функции, оперирующие со строками: <strong>&lt;string.h&gt;</strong></p>
    </title>
    <p>Имеются две группы функций, оперирующих со строками. Они определены в заголовочном файле <strong>&lt;string.h&gt;</strong>. Имена функций первой группы начинаются с букв <emphasis>str</emphasis>, второй - с <emphasis>mem</emphasis>. Если копирование имеет дело с объектами, перекрывающимися по памяти, то, за исключением <strong>memmove</strong>, поведение функций не определено. Функции сравнения рассматривают аргументы как массивы элементов типа <emphasis>unsigned char</emphasis>. </p>
    <p>В таблице на с. 321 переменные <emphasis>s</emphasis> и <emphasis>t</emphasis> принадлежат типу <emphasis>char *</emphasis>, <emphasis>cs</emphasis> и <emphasis>ct</emphasis> – типу <emphasis>const char *</emphasis>, <emphasis>n</emphasis> - типу <emphasis>size_t</emphasis>, а <emphasis>c</emphasis> - значение типа <emphasis>int</emphasis>, приведенное к типу <emphasis>char</emphasis>. </p>
    <p>Последовательные вызовы <strong>strtok</strong> разбивают строку <emphasis>s</emphasis> на лексемы. Ограничителем лексемы служит любой символ из строки <emphasis>ct</emphasis>. В первом вызове указатель <emphasis>s</emphasis> не равен NULL. Функция находит в строке <emphasis>s</emphasis> первую лексему, состоящую из символов, не входящих в <emphasis>ct</emphasis>; ее работа заканчивается тем, что поверх следующего символа пишется '\0' и возвращается указатель на лексему. Каждый последующий вызов, в котором указатель <emphasis>s</emphasis> равен NULL, возвращает указатель на следующую лексему, которую функция будет искать сразу за концом предыдущей. Функция <emphasis>strtok</emphasis> возвращает NULL, если далее никакой лексемы не обнаружено. Параметр <emphasis>ct</emphasis> от вызова к вызову может варьироваться. </p>
    <p>Здесь и ниже под такими выражениями как cs&lt;ct не следует понимать арифметическое сравнение указателей. Подразумевается лексикографическое сравнение, т. е. <emphasis>cs</emphasis> меньше (больше) <emphasis>ct</emphasis>, если первый несовпавший элемент в <emphasis>cs</emphasis> арифметически меньше (больше) соответствующего элемента из <emphasis>ct</emphasis>.— <emphasis>Примеч. ред.</emphasis> </p>
    <table>
     <tr>
      <td>char *<strong>strcpy</strong>(s,ct) </td>
      <td>копирует строку <emphasis>ct</emphasis> в строку <emphasis>s</emphasis>, включая '\0'; возвращает <emphasis>s</emphasis></td>
     </tr>
     <tr>
      <td>char *<strong>strncpy</strong>(s,ct,n) </td>
      <td>копирует не более <emphasis>n</emphasis> символов строки <emphasis>ct</emphasis> в <emphasis>s</emphasis>; возвращает <emphasis>s</emphasis>. Дополняет результат символами '\0', если символов в <emphasis>ct</emphasis> меньше <emphasis>n</emphasis></td>
     </tr>
     <tr>
      <td>char *<strong>strcat</strong>(s,ct) </td>
      <td>приписывает <emphasis>ct</emphasis> к <emphasis>s</emphasis>; возвращает <emphasis>s</emphasis></td>
     </tr>
     <tr>
      <td>char *<strong>strncat</strong>(s,ct,n) </td>
      <td>приписывает не более <emphasis>n</emphasis> символов <emphasis>ct</emphasis> к <emphasis>s</emphasis>, завершая <emphasis>s</emphasis> символом '\0'; возвращает <emphasis>s</emphasis></td>
     </tr>
     <tr>
      <td>char <strong>strcmp</strong>(cs,st) </td>
      <td>сравнивает <emphasis>cs</emphasis> и <emphasis>ct</emphasis>; возвращает &lt;0, если cs&lt;ct; 0, если cs==ct; и &gt;0, если cs&gt;ct (<emphasis>I.B.: вообще-то, функция возвращает int</emphasis>)</td>
     </tr>
     <tr>
      <td>char <strong>strncmp</strong>(cs,ct) </td>
      <td>сравнивает не более <emphasis>n</emphasis> символов <emphasis>cs</emphasis> и <emphasis>ct</emphasis>; возвращает &lt;0, если cs&lt;ct, 0, если cs==ct, и &gt;0, если cs&gt;ct (<emphasis>I.B.: тоже int должна возвращать</emphasis>)</td>
     </tr>
     <tr>
      <td>char *<strong>strchr</strong>(cs,c) </td>
      <td>возвращает указатель на первое вхождение <emphasis>c</emphasis> в <emphasis>cs</emphasis> или, если такового не оказалось, NULL</td>
     </tr>
     <tr>
      <td>char *<strong>strrchr</strong>(cs,c) </td>
      <td>возвращает указатель на последнее вхождение <emphasis>c</emphasis> в <emphasis>cs</emphasis> или, если такового не оказалось, NULL</td>
     </tr>
     <tr>
      <td>size_t <strong>strspn</strong>(cs,ct) </td>
      <td>возвращает длину начального сегмента <emphasis>cs</emphasis>, состоящего из символов, входящих в строку <emphasis>ct</emphasis></td>
     </tr>
     <tr>
      <td>size_t <strong>strcspn</strong>(cs,ct) </td>
      <td>возвращает длину начального сегмента <emphasis>cs</emphasis>, состоящего из символов, не входящих в строку <emphasis>ct</emphasis></td>
     </tr>
     <tr>
      <td>char *<strong>strpbrk</strong>(cs,ct) </td>
      <td>возвращает указатель в <emphasis>cs</emphasis> на первый символ, который совпал с одним из символов, входящих в <emphasis>ct</emphasis>, или, если такового не оказалось, NULL</td>
     </tr>
     <tr>
      <td>char *<strong>strstr</strong>(cs, ct) </td>
      <td>возвращает указатель на первое вхождение <emphasis>ct</emphasis> в <emphasis>cs</emphasis> или, если такового не оказалось, NULL</td>
     </tr>
     <tr>
      <td>size_t <strong>strlen</strong>(cs) </td>
      <td>возвращает длину <emphasis>cs</emphasis></td>
     </tr>
     <tr>
      <td>char * <strong>strerror</strong>(n) </td>
      <td>возвращает указатель на зависящую от реализации строку, соответствующую номеру ошибки <emphasis>n</emphasis></td>
     </tr>
     <tr>
      <td>char * <strong>strtok</strong>(s, ct) </td>
      <td><emphasis>strtok</emphasis> ищет в <emphasis>s</emphasis> лексему, ограниченную символами из <emphasis>ct</emphasis>; более подробное описание этой функции см. ниже</td>
     </tr>
    </table>
    <p>Функции <strong>mem...</strong> предназначены для манипулирования с объектами как с массивами символов; их назначение - получить интерфейсы к эффективным программам. В приведенной ниже таблице <emphasis>s</emphasis> и <emphasis>t</emphasis> принадлежат типу <emphasis>void *</emphasis>; <emphasis>cs</emphasis> и <emphasis>ct</emphasis> - типу <emphasis>const void *</emphasis>; <emphasis>n</emphasis> - типу <emphasis>size_t</emphasis>; а <emphasis>c</emphasis> имеет значение типа <emphasis>int</emphasis>, приведенное к типу <emphasis>char</emphasis>. </p>
    <table>
     <tr>
      <td>void *<strong>memcpy</strong>(s,ct, n) </td>
      <td>копирует <emphasis>n</emphasis> символов из <emphasis>ct</emphasis> в <emphasis>s</emphasis> и возвращает <emphasis>s</emphasis></td>
     </tr>
     <tr>
      <td>void *<strong>memmove</strong>(s,ct,n) </td>
      <td>делает то же самое, что и <emphasis>memcpy</emphasis>, но работает и в случае "перекрывающихся" объектов. </td>
     </tr>
     <tr>
      <td>int <strong>memcmp</strong>(cs, ct, n) </td>
      <td>сравнивает первые <emphasis>n</emphasis> символов <emphasis>cs</emphasis> и <emphasis>ct</emphasis>; выдает тот же результат, что и функция <emphasis>strcmp</emphasis></td>
     </tr>
     <tr>
      <td>void *<strong>memchr</strong>(cs, c, n) </td>
      <td>возвращает указатель на первое вхождение символа <emphasis>c</emphasis> в <emphasis>cs</emphasis> или, если среди первых <emphasis>n</emphasis> символов <emphasis>c</emphasis> не встретилось, NULL</td>
     </tr>
     <tr>
      <td>void *<strong>memset</strong>(s, c, n) </td>
      <td>размещает символ <emphasis>c</emphasis> в первых <emphasis>n</emphasis> позициях строки <emphasis>s</emphasis> и возвращает <emphasis>s</emphasis></td>
     </tr>
    </table>
   </section>
   <section>
    <title>
     <p>B4. Математические функции: <strong>&lt;math.h&gt;</strong></p>
    </title>
    <p>В заголовочном файле <strong>&lt;math.h&gt;</strong> описываются математические функции и определяются макросы. </p>
    <p>Макросы <strong>EDOM</strong> и <strong>ERANGE</strong> (находящиеся в <strong>&lt;errno.h&gt;</strong>) задают отличные от нуля целочисленные константы, используемые для фиксации ошибки области и ошибки диапазона; <strong>HUGE_VAL</strong> определена как положительное значение типа <strong>double</strong>. <emphasis>Ошибка области</emphasis> возникает, если аргумент выходит за область значений, для которой определена функция. Фиксация ошибки области осуществляется присвоением <emphasis>errno</emphasis> значения <emphasis>EDOM</emphasis>; возвращаемое значение зависит от реализации. Ошибка диапазона возникает тогда, когда результат функции не может быть представлен в виде <emphasis>double</emphasis>. В случае переполнения функция возвращает <emphasis>HUGE_VAL</emphasis> с правильным знаком и в <emphasis>errno</emphasis> устанавливается значение <emphasis>ERANGE</emphasis>. Если результат оказывается меньше, чем возможно представить данным типом, функция возвращает нуль, а устанавливается ли в этом случае <emphasis>errno</emphasis> в <emphasis>ERANGE</emphasis>, зависит от реализации. Далее <emphasis>x</emphasis> и <emphasis>y</emphasis> имеют тип <emphasis>double</emphasis>, <emphasis>n</emphasis> - тип <emphasis>int</emphasis>, и все функции возвращают значения типа <emphasis>double</emphasis>. Углы в тригонометрических функциях задаются в <emphasis>радианах</emphasis>. </p>
    <table>
     <tr>
      <td><strong>sin</strong>(x) </td>
      <td>синус <emphasis>x</emphasis></td>
     </tr>
     <tr>
      <td><strong>cos</strong>(x)</td>
      <td>косинус <emphasis>x</emphasis></td>
     </tr>
     <tr>
      <td><strong>tan</strong>(x) </td>
      <td>тангенс <emphasis>x</emphasis></td>
     </tr>
     <tr>
      <td><strong>asin</strong>(x)</td>
      <td>арксинус <emphasis>x</emphasis> в диапазоне <emphasis>[-pi/2,pi/2]</emphasis>, <emphasis>x</emphasis> в диапазоне <emphasis>[-1,1]</emphasis> </td>
     </tr>
     <tr>
      <td><strong>acos</strong>(x) </td>
      <td>арккосинус <emphasis>x</emphasis> в диапазоне <emphasis>[0, pi]</emphasis>, <emphasis>x</emphasis> в диапазоне <emphasis>[-1,1]</emphasis> </td>
     </tr>
     <tr>
      <td><strong>atan</strong>(x) </td>
      <td>арктангенс <emphasis>x</emphasis> в диапазоне <emphasis>[-pi/2, pi/2]</emphasis> </td>
     </tr>
     <tr>
      <td><strong>atan2</strong>(y,x) </td>
      <td>арктангенс <emphasis>y/x</emphasis> в диапазоне <emphasis>[-pi, pi]</emphasis> </td>
     </tr>
     <tr>
      <td><strong>sinh</strong>(x) </td>
      <td>гиперболический синус <emphasis>x</emphasis></td>
     </tr>
     <tr>
      <td><strong>cosh</strong>(x) </td>
      <td>гиперболический косинус <emphasis>x</emphasis></td>
     </tr>
     <tr>
      <td><strong>tanh</strong>(x) </td>
      <td>гиперболический тангенс <emphasis>x</emphasis></td>
     </tr>
     <tr>
      <td><strong>exp</strong>(x) </td>
      <td>Экспоненциальная функция <emphasis>e<sup>x</sup></emphasis></td>
     </tr>
     <tr>
      <td><strong>log</strong>(x) </td>
      <td>натуральный логарифм <emphasis>ln(x)</emphasis>, <emphasis>x &gt; 0</emphasis></td>
     </tr>
     <tr>
      <td><strong>log10</strong>(x) </td>
      <td>десятичный логарифм <emphasis>lg(x)</emphasis>, <emphasis>x &gt; 0</emphasis></td>
     </tr>
     <tr>
      <td><strong>pow</strong>(x,y) </td>
      <td><emphasis>x<sup>y</sup></emphasis>, ошибка области, если <emphasis>x = 0</emphasis> или <emphasis>y&lt;=0</emphasis> или <emphasis>x&lt;0</emphasis> и <emphasis>y</emphasis> – не целое</td>
     </tr>
     <tr>
      <td><strong>sqrt</strong>(x) </td>
      <td>квадратный корень <emphasis>x</emphasis>, <emphasis>x &gt;= 0</emphasis></td>
     </tr>
     <tr>
      <td><strong>ceil</strong>(x) </td>
      <td>наименьшее целое в виде <emphasis>double</emphasis>, которое не меньше <emphasis>x</emphasis></td>
     </tr>
     <tr>
      <td><strong>floor</strong>(x) </td>
      <td>наибольшее целое в виде <emphasis>double</emphasis>, которое не больше <emphasis>x</emphasis></td>
     </tr>
     <tr>
      <td><strong>fabs</strong>(x) </td>
      <td>абсолютное значение |x|</td>
     </tr>
     <tr>
      <td><strong>ldexp</strong>(x, n) </td>
      <td>x * 2<sup>n</sup></td>
     </tr>
     <tr>
      <td><strong>frexp</strong>(x, int *еxр) </td>
      <td>разбивает <emphasis>x</emphasis> на два сомножителя, первый из которых - нормализованная дробь в интервале [1/2, 1), которая возвращается, а второй - степень двойки, эта степень запоминается в <emphasis>*exp</emphasis>. Если <emphasis>x</emphasis> - нуль, то обе части результата равны нулю </td>
     </tr>
     <tr>
      <td><strong>modf</strong>(x,double *ip) </td>
      <td>разбивается на целую и дробную части, обе имеют тот же знак, что и <emphasis>x</emphasis>. Целая часть запоминается в <emphasis>*ip</emphasis>, дробная часть выдается как результат </td>
     </tr>
     <tr>
      <td><strong>fmod</strong>(x, y)</td>
      <td>остаток от деления <emphasis>x</emphasis> на <emphasis>y</emphasis> в виде числа с плавающей точкой. Знак результата совпадает со знаком <emphasis>x</emphasis>. Если <emphasis>y</emphasis> равен нулю, результат зависит от реализации </td>
     </tr>
    </table>
   </section>
   <section>
    <title>
     <p>B5. Функции общего назначения: <strong>&lt;stdlib.h&gt;</strong></p>
    </title>
    <p>Заголовочный файл <strong>&lt;stdlib.h&gt;</strong> объявляет функции, предназначенные для преобразования чисел, запроса памяти и других задач. </p>
    <p><code>double atof(const char *s)</code></p>
    <p><strong>atof</strong> переводит <emphasis>s</emphasis> в <emphasis>double</emphasis>; эквивалентна strtod(s, (char**) NULL). </p>
    <p><code>int atoi(const char *s)</code></p>
    <p><strong>atoi</strong> переводит <emphasis>s</emphasis> в <emphasis>int</emphasis>; эквивалентна (int)strtol(s, (char**)NULL, 10). </p>
    <p><code>int atol(const char *s)</code></p>
    <p><strong>atol</strong> переводит <emphasis>s</emphasis> в <emphasis>long</emphasis>; эквивалентна strtol(s, (char**) NULL, 10). </p>
    <p><code>double strtod(const char *s, char **endp)</code></p>
    <p><strong>strtod</strong> преобразует первые символы строки <emphasis>s</emphasis> в <emphasis>double</emphasis>, игнорируя начальные символы-разделители; запоминает указатель на непреобразованный конец в <emphasis>*endp</emphasis> (если <emphasis>endp</emphasis> не NULL), при переполнении она выдает <emphasis>HUGE_VAL</emphasis> с соответствующим знаком, в случае, если результат оказывается меньше, чем возможно представить данным типом, возвращается 0; в обоих случаях в <emphasis>errno</emphasis> устанавливается <emphasis>ERANGE</emphasis>. </p>
    <p><code>long strtol(const char *s, char **endp, int base)</code></p>
    <p><strong>strtol</strong> преобразует первые символы строки <emphasis>s</emphasis> в <emphasis>long</emphasis>, игнорируя начальные символы-разделители; запоминает указатель на непреобразованный конец в <emphasis>*endp</emphasis> (если <emphasis>endp</emphasis> не NULL). Если <emphasis>base</emphasis> находится в диапазоне от 2 до 36, то преобразование делается в предположении, что на входе - запись числа по основанию <emphasis>base</emphasis>. Если <emphasis>base</emphasis> равно нулю, то основанием числа считается 8, 10 или 16; число, начинающееся с цифры 0, считается восьмеричным, а с 0x или 0X - шестнадцатеричным. Цифры от 10 до <emphasis>base-1</emphasis> записываются начальными буквами латинского алфавита в любом регистре. При основании, равном 16, в начале числа разрешается помещать 0x или 0X. В случае переполнения функция возвращает LONG_MAX или LONG_MIN (в зависимости от знака), a в <emphasis>errno</emphasis> устанавливается ERANGE. </p>
    <p><code>unsigned long strtoul(const char *s, char **endp, int base)</code></p>
    <p><strong>strtoul</strong> работает так же, как и <emphasis>strtol</emphasis>, с той лишь разницей, что возвращает результат типа <emphasis>unsigned long</emphasis>, а в случае переполнения - ULONG_MAX. </p>
    <p><code>int rand(void)</code></p>
    <p><strong>rand</strong> выдает псевдослучайное число в диапазоне от 0 до RAND_MAX; RAND_MAX не меньше 32767. </p>
    <p><code>void srand(unsigned int seed)</code></p>
    <p><strong>srand</strong> использует <emphasis>seed</emphasis> в качестве семени для новой последовательности псевдослучайных чисел. Изначально параметр <emphasis>seed</emphasis> равен 1. </p>
    <p><code>void *calloc(size_t nobj, size_t size)</code></p>
    <p><strong>calloc</strong> возвращает указатель на место в памяти, отведенное для массива <emphasis>nobj</emphasis> объектов, каждый из которых размера <emphasis>size</emphasis>, или, если памяти запрашиваемого объема нет, NULL. Выделенная область памяти обнуляется. </p>
    <p><code>void *malloc(size_t size)</code></p>
    <p><strong>malloc</strong> возвращает указатель на место в памяти для объекта размера <emphasis>size</emphasis> или, если памяти запрашиваемого объема нет, NULL. Выделенная область памяти не инициализируется. </p>
    <p><code>void *realloc(void *p, size_t size)</code></p>
    <p><strong>realloc</strong> заменяет на <emphasis>size</emphasis> размер объекта, на который указывает <emphasis>p</emphasis>. Для части, размер которой равен наименьшему из старого и нового размеров, содержимое не изменяется. Если новый размер больше старого, дополнительное пространство не инициализируется, <emphasis>realloc</emphasis> возвращает указатель на новое место памяти или, если требования не могут быть удовлетворены, NULL (<emphasis>*p</emphasis> при этом не изменяется). </p>
    <p><code>void free(void *р)</code></p>
    <p><strong>free</strong> освобождает область памяти, на которую указывает <emphasis>p</emphasis>; эта функция ничего не делает, если <emphasis>p</emphasis> равно NULL. В <emphasis>p</emphasis> должен стоять указатель на область памяти, ранее выделенную одной из функций: <emphasis>calloc</emphasis>, <emphasis>malloc</emphasis> или <emphasis>realloc</emphasis>. </p>
    <p>void abort(void *р) </p>
    <p><strong>abort</strong> вызывает аварийное завершение программы, ее действия эквивалентны вызову <strong>raise</strong>(SIGABRT). </p>
    <p><code>void exit(int status)</code></p>
    <p><strong>exit</strong> вызывает нормальное завершение программы. Функции, зарегистрированные с помощью <strong>atexit</strong>, выполняются в порядке, обратном их регистрации. Производится опорожнение буферов открытых файлов, открытые потоки закрываются, и управление возвращается в среду, из которой был произведен запуск программы. Значение <emphasis>status</emphasis>, передаваемое в среду, зависит от реализации, однако при успешном завершении программы принято передавать нуль. Можно также использовать значения EXIT_SUCCESS (в случае успешного завершения) и EXIT_FAILURE (в случае ошибки). </p>
    <p>int atexit(void (*fcn)(void)) </p>
    <p><strong>atexit</strong> регистрирует <emphasis>fcn</emphasis> в качестве функции, которая будет вызываться при нормальном завершении программы; возвращает ненулевое значение, если регистрация не может быть выполнена. </p>
    <p><code>int system(const char *s)</code></p>
    <p><strong>system</strong> пepeдaeт cтpoку <emphasis>s</emphasis> oпepaциoннoй cpeдe для выпoлнeния. Если <emphasis>s</emphasis> есть NULL и существует командный процессор, то <emphasis>system</emphasis> возвращает ненулевое значение. Если <emphasis>s</emphasis> не NULL, то возвращаемое значение зависит от реализации. </p>
    <p><code>char *getenv(const char *name)</code></p>
    <p><strong>getenv</strong> возвращает строку среды, связанную с <emphasis>name</emphasis>, или, если никакой строки не существует, NULL. Детали зависят от реализации. </p>
    <p><code>void *bsearch(const void *key, const void *base, size_t n, size_t size, int (*cmp)(const void *keyval, const void *datum))</code></p>
    <p><strong>bsearch</strong> ищет среди <emphasis>base[0]...base[n-1]</emphasis> элемент с подходящим ключом <emphasis>*key</emphasis>. Функция <emphasis>cmp</emphasis> должна сравнивать первый аргумент (ключ поиска) со своим вторым аргументом (значением ключа в таблице) и в зависимости от результата сравнения выдавать отрицательное число, нуль или положительное значение. Элементы массива <emphasis>base</emphasis> должны быть упорядочены в возрастающем порядке, <emphasis>bsearch</emphasis> возвращает указатель на элемент с подходящим ключом или, если такого не оказалось, NULL. </p>
    <p><code>void qsort(void *base, size_t n, size_t size, int (*cmp)(const void *, const void *))</code></p>
    <p><strong>qsort</strong> сортирует массив <emphasis>base[0]...base[n-1]</emphasis> объектов размера <emphasis>size</emphasis> в возрастающем порядке. Функция сравнения <emphasis>cmp</emphasis> - такая же, как и в <emphasis>bsearch</emphasis>. </p>
    <p><code>int abs(int n)</code></p>
    <p><strong>abs</strong> возвращает абсолютное значение аргумента типа <emphasis>int</emphasis>. </p>
    <p><code>long labs(long n)</code></p>
    <p><strong>labs</strong> возвращает абсолютное значение аргумента типа <emphasis>long</emphasis>. </p>
    <p><code>div_t div(int num, int denom)</code></p>
    <p><strong>div</strong> вычисляет частное и остаток от деления <emphasis>num</emphasis> на <emphasis>denom</emphasis>. Результаты типа <emphasis>int</emphasis> запоминаются в элементах <emphasis>quot</emphasis> и <emphasis>rem</emphasis> структуры <emphasis>div_t</emphasis>. </p>
    <p><code>ldiv_t ldiv(long num, long denom)</code></p>
    <p><strong>ldiv</strong> вычисляет частное и остаток от деления <emphasis>num</emphasis> на <emphasis>denom</emphasis>. Результаты типа <emphasis>long</emphasis> запоминаются в элементах <emphasis>quot</emphasis> и <emphasis>rem</emphasis> структуры <emphasis>ldiv_t</emphasis>. </p>
   </section>
   <section>
    <title>
     <p>B6. Диагностика: <strong>&lt;assert.h&gt;</strong></p>
    </title>
    <p>Макрос <strong>assert</strong> используется для включения в программу диагностических сообщений. </p>
    <p><code>void assert (int <emphasis>выражение</emphasis>)</code></p>
    <p>Если <emphasis>выражение</emphasis> имеет значение нуль, то</p>
    <p><code>assert (<emphasis>выражение</emphasis>)</code></p>
    <p>напечатает в <emphasis>stderr</emphasis> сообщение следующего вида: </p>
    <p>Assertion failed: <emphasis>выражение</emphasis>, file <emphasis>имя-файла</emphasis>, line <code><emphasis>nnn</emphasis></code> </p>
    <p>после чего будет вызвана функция <emphasis>abort</emphasis>, которая завершит вычисления. Имя исходного файла и номер строки будут взяты из макросов __FILE__ и __LINE__. </p>
    <p>Если в момент включения файла <strong>&lt;assert.h&gt;</strong> было определено имя <strong>NDEBUG</strong>, то макрос <emphasis>assert</emphasis> игнорируется. </p>
   </section>
   <section>
    <title>
     <p>B7. Списки аргументов переменной длины: <strong>&lt;stdarg.h&gt;</strong></p>
    </title>
    <p>Заголовочный файл <strong>&lt;stdarg.h&gt;</strong> предоставляет средства для перебора аргументов функции, количество и типы которых заранее не известны. Пусть <emphasis>lastarg</emphasis> - последний именованный параметр функции <emphasis>f</emphasis> с переменным числом аргументов. Внутри <emphasis>f</emphasis> объявляется переменная <emphasis>ap</emphasis> типа <strong>va_list</strong>, предназначенная для хранения указателя на очередной аргумент: </p>
    <p><code>va_list ар;</code></p>
    <p>Прежде чем будет возможен доступ к безымянным аргументам, необходимо один раз инициализировать <emphasis>ap</emphasis>, обратившись к макросу <strong>va_start</strong>: </p>
    <p><code>va_start(va_list ap, lastarg);</code></p>
    <p>С этого момента каждое обращение к макросу: </p>
    <p><code>type <strong>va_arg</strong>(va_list ap, type);</code></p>
    <p>будет давать значение очередного безымянного аргумента указанного типа, и каждое такое обращение будет вызывать автоматическое приращение указателя <emphasis>ap</emphasis>, чтобы последний указывал на следующий аргумент. Один раз после перебора аргументов, но до выхода из <emphasis>f</emphasis> необходимо обратиться к макросу </p>
    <p><code>void <strong>va_end</strong>(va_list ap);</code></p>
   </section>
   <section>
    <title>
     <p>B8. Дальние переходы: <strong>&lt;setjmp.h&gt;</strong></p>
    </title>
    <p>Объявления в <strong>&lt;setjmp.h&gt;</strong> предоставляют способ отклониться от обычной последовательности "вызов - возврат"; типичная ситуация - необходимость вернуться из "глубоко вложенного" вызова функции на верхний уровень, минуя промежуточные возвраты. </p>
    <p><code>int setjmp(jmp_buf env);</code></p>
    <p>Макрос <strong>setjmp</strong> сохраняет текущую информацию о вызовах в <emphasis>env</emphasis> для последующего ее использования в <strong>longjmp</strong>. Возвращает нуль, если возврат осуществляется непосредственно из <emphasis>setjmp</emphasis>, и не нуль, если - от последующего вызова <emphasis>longjmp</emphasis>. Обращение к <emphasis>setjmp</emphasis> возможно только в определенных контекстах, в основном это проверки в <emphasis>if</emphasis>, <emphasis>switсh</emphasis> и циклах, причем только в простых выражениях отношения. </p>
    <p><code>if (setjmp() == 0)</code></p>
    <p><code>    /* после прямого возврата */</code></p>
    <p><code>else</code></p>
    <p><code>    /* после возврата из longjmp */</code></p>
    <empty-line/>
    <p><code>void longjmp(jmp_buf env, int val);</code></p>
    <p><strong>longjmp</strong> восстанавливает информацию, сохраненную в самом последнем вызове <emphasis>setjmp</emphasis>, по информации из <emphasis>env</emphasis>; выполнение программы возобновляется, как если бы функция <emphasis>setjmp</emphasis> только что отработала и вернула ненулевое значение <emphasis>val</emphasis>. Результат будет непредсказуемым, если в момент обращения к <emphasis>longjmp</emphasis> функция, содержащая вызов <emphasis>setjmp</emphasis>, уже "отработала" и осуществила возврат. Доступные ей объекты имеют те значения, которые они имели в момент обращения к <emphasis>longjmp</emphasis>; <emphasis>setjmp</emphasis> не сохраняет значений. </p>
   </section>
   <section>
    <title>
     <p>B9. Сигналы: <strong>&lt;signal.h&gt;</strong></p>
    </title>
    <p>Заголовочный файл <strong>&lt;signal.h&gt;</strong> предоставляет средства для обработки исключительных ситуаций, возникающих во время выполнения программы, таких как прерывание, вызванное внешним источником или ошибкой в вычислениях. </p>
    <p><code>void (*signal(int sig, void (*handler)(int)))(int)</code></p>
    <p><strong>signal</strong> устанавливает, как будут обрабатываться последующие сигналы. Если параметр <emphasis>handler</emphasis> имеет значение <strong>SIG_DFL</strong>, то используется зависимая от реализации "обработка по умолчанию"; если значение <emphasis>handler</emphasis> равно <strong>SIG_IGN</strong>, то сигнал игнорируется; в остальных случаях будет выполнено обращение к функции, на которую указывает <emphasis>handler</emphasis> с типом сигнала в качестве аргумента. В число допустимых видов сигналов входят: </p>
    <table>
     <tr>
      <td><strong>SIGABRT</strong></td>
      <td>аварийное завершение, например от <emphasis>abort</emphasis>; </td>
     </tr>
     <tr>
      <td><strong>SIGFPE</strong></td>
      <td>арифметическая ошибка: деление на 0 или переполнение; </td>
     </tr>
     <tr>
      <td><strong>SIGILL</strong></td>
      <td>неверный код функции (недопустимая команда); </td>
     </tr>
     <tr>
      <td><strong>SIGINT</strong></td>
      <td>запрос на взаимодействие, например прерывание; </td>
     </tr>
     <tr>
      <td><strong>SIGSEGV</strong></td>
      <td>неверный доступ к памяти, например выход за границы; </td>
     </tr>
     <tr>
      <td><strong>SIGTERM</strong></td>
      <td>требование завершения, посланное в программу. </td>
     </tr>
    </table>
    <p><emphasis>signal</emphasis> возвращает предыдущее значение <emphasis>handler</emphasis> в случае специфицированного сигнала, или <strong>SIGERR</strong> в случае возникновения ошибки. </p>
    <p>Когда в дальнейшем появляется сигнал <emphasis>sig</emphasis>, сначала восстанавливается готовность поведения "по умолчанию", после чего вызывается функция, заданная в параметре <emphasis>handler</emphasis>, т.е. как бы выполняется вызов (*<emphasis>handler</emphasis>)(sig). Если функция <emphasis>handler</emphasis> вернет управление назад, то вычисления возобновятся с того места, где застал программу пришедший сигнал. Начальное состояние сигналов зависит от реализации. </p>
    <p>int raise(int sig) </p>
    <p><strong>raise</strong> посылает в программу сигнал <emphasis>sig</emphasis>. В случае неудачи возвращает ненулевое значение.  </p>
   </section>
   <section>
    <title>
     <p>B10. Функции даты и времени: ‹time.h›</p>
    </title>
    <p>Заголовочный файл <strong>&lt;time.h&gt;</strong> объявляет типы и функции, связанные с датой и временем. Некоторые функции имеют дело с местным временем, которое может отличаться от календарного, например в связи с зонированием времени. Типы <strong>clосk_t</strong> и <strong>time_t</strong> - арифметические типы для представления времени, a <emphasis>struct tm</emphasis> содержит компоненты календарного времени: </p>
    <p><code>int tm_sec; - секунды от начала минуты (0,61); -- I.B.: все же наверно от 0 до 59</code></p>
    <p><code>int tm_min; - минуты от начала часа (0,59); </code></p>
    <p><code>int tm_hour; - часы от полуночи (0,23);int tm_mday; - число месяца (1,31); </code></p>
    <p><code>int tm_mon; - месяцы с января(0,11);</code></p>
    <p><code>int tm_year; - годы с 1900; </code></p>
    <p><code>int tm_wday; - дни с воскресенья (0,6);</code></p>
    <p><code>int tm_yday; - дни с 1 января (0,365); </code></p>
    <p><code>int tm_isdst; - признак летнего времени.</code></p>
    <p>Значение <emphasis>tm_isdst</emphasis> - положительное, если время приходится на сезон, когда время суток сдвинуто на 1 час вперед, нуль в противном случае и отрицательное, если информация не доступна. </p>
    <p><code>clock_t clock(void)</code></p>
    <p><strong>clock</strong> возвращает время, фиксируемое процессором от начала выполнения программы, или -1, если оно не известно. Для выражения этого времени в секундах применяется формула clock()/CLOCKS_PER_SEC. </p>
    <p><code>time_t time(time_t *tp)</code></p>
    <p><strong>time</strong> возвращает текущее календарное время (т. е. время, прошедшее после определенной даты, - обычно после 0 ч 00 мин 00 с GMT 1-го января 1970 г. - примеч. ред.) или -1, если время не известно. Если <emphasis>tp</emphasis> не равно NULL, то возвращаемое значение записывается и в <emphasis>*tp</emphasis>. </p>
    <p><code>double difftime(time_t time2, time_t time1)</code></p>
    <p><strong>difftime</strong> возвращает разность <emphasis>time2 - time1</emphasis>, выраженную в секундах. </p>
    <p><code>time_t mktime(struct tm *tp)</code></p>
    <p><strong>mktime</strong> преобразует местное время, заданное структурой <emphasis>*tp</emphasis>, в календарное, выдавая его в том же виде, что и функция <emphasis>time</emphasis>. Компоненты будут иметь значения в указанных диапазонах. Функция <emphasis>mktime</emphasis> возвращает календарное время или -1, если оно не представимо. </p>
    <p>Следующие четыре функции возвращают указатели на статические объекты, каждый из которых может быть изменен другими вызовами. </p>
    <p><code>char *asctime(const struct tm *tp)</code></p>
    <p><strong>asctime</strong> переводит время в структуре <emphasis>*tp</emphasis> в строку вида </p>
    <p><code>Sun Jan 3 15:14:13 1988\n\0</code></p>
    <empty-line/>
    <p><code>char *ctime(const time_t *tp)</code></p>
    <p><strong>ctime</strong> переводит календарное время в местное, что эквивалентно выполнению asctime(localtime(tp))</p>
    <p><code>struct tm *gmtime(const time_t *tp)</code></p>
    <p><strong>gmtime</strong> переводит календарное время во Всемирное координированное время (Coordinated Universal Time - UTC). Выдаст NULL, если UTC не известно. Имя этой функции, <emphasis>gmtime</emphasis>, происходит от Greenwich Mean Time (среднее время по Гринвичскому меридиану). </p>
    <p><code>struct tm *localtime(const time_t *tp)</code></p>
    <p><strong>localtime</strong> переводит календарное время <emphasis>*tp</emphasis> в местное. </p>
    <p><code>size_t strftime(char *s, size_t smax, const char *fmt, const struct tm *tp)</code></p>
    <p><strong>strftime</strong> форматирует информацию о дате и времени из <emphasis>*tp</emphasis> в строку <emphasis>s</emphasis> согласно формату <emphasis>fmt</emphasis>, который имеет много общих черт с форматом, задаваемым в функции <emphasis>printf</emphasis>. Обычные символы (включая и завершающий символ '\0') копируются в <emphasis>s</emphasis>. Каждая пара, состоящая из <strong>%</strong> и буквы, заменяется, как показано ниже, с использованием значений по форме, соответствующей местным традициям. В <emphasis>s</emphasis> размещается не более <emphasis>smax</emphasis> символов; <emphasis>strftime</emphasis> возвращает число символов без учета '\0' или нуль, если число сгенерированных символов больше <emphasis>smax</emphasis>. </p>
    <table>
     <tr>
      <td>%a</td>
      <td>сокращенное название дня недели</td>
     </tr>
     <tr>
      <td>%A</td>
      <td>полное название дня недели</td>
     </tr>
     <tr>
      <td>%b</td>
      <td>сокращенное название месяца </td>
     </tr>
     <tr>
      <td>%B</td>
      <td>полное название месяца</td>
     </tr>
     <tr>
      <td>%c</td>
      <td>местное представление даты и времени</td>
     </tr>
     <tr>
      <td>%d</td>
      <td>день месяца (01-31) </td>
     </tr>
     <tr>
      <td>%H</td>
      <td>час (24-часовое время) (00-23) </td>
     </tr>
     <tr>
      <td>%I</td>
      <td>час (12-часовое время) (01-12) </td>
     </tr>
     <tr>
      <td>%j</td>
      <td>день от начала года (001-366) </td>
     </tr>
     <tr>
      <td>%m</td>
      <td>месяц (01-12) </td>
     </tr>
     <tr>
      <td>%M</td>
      <td>минута (00-59) </td>
     </tr>
     <tr>
      <td>%p</td>
      <td>местное представление AM или РМ (до или после полудня) </td>
     </tr>
     <tr>
      <td>%S</td>
      <td>секунда (00-61) </td>
     </tr>
     <tr>
      <td>%U</td>
      <td>неделя от начала года (считая, что воскресенье - 1-й день недели) (00-53) </td>
     </tr>
     <tr>
      <td>%w</td>
      <td>день недели (0-6, номер воскресенья - 0) </td>
     </tr>
     <tr>
      <td>%W</td>
      <td>неделя от начала года (считая, что понедельник - 1-й день недели) (00-53)</td>
     </tr>
     <tr>
      <td>%x</td>
      <td>местное представление даты</td>
     </tr>
     <tr>
      <td>%X</td>
      <td>местное представление времени</td>
     </tr>
     <tr>
      <td>%y</td>
      <td>год без указания века (00-99) </td>
     </tr>
     <tr>
      <td>%Y</td>
      <td>год с указанием века</td>
     </tr>
     <tr>
      <td>%Z</td>
      <td>название временной зоны, если она есть</td>
     </tr>
     <tr>
      <td>%%</td>
      <td>%</td>
     </tr>
    </table>
   </section>
   <section>
    <title>
     <p>B11. Зависящие от реализации пределы: <strong>&lt;limits.h&gt;</strong> и <strong>&lt;float.h&gt;</strong></p>
    </title>
    <p>Заголовочный файл <strong>&lt;limits.h&gt;</strong> определяет константы для размеров целочисленных типов. Ниже перечислены минимальные приемлемые величины, но в конкретных реализациях могут использоваться и большие значения. </p>
    <table>
     <tr>
      <td><strong>CHAR_BIT</strong> </td>
      <td>8</td>
      <td>битов в значении <strong>char</strong></td>
     </tr>
     <tr>
      <td><strong>SCHAR_MAX</strong></td>
      <td><strong>UCHAR_MAX</strong> или <strong>SCHAR_MAX</strong></td>
      <td>максимальное значение <emphasis>char</emphasis></td>
     </tr>
     <tr>
      <td><strong>CHAR_MIN</strong></td>
      <td>0 или <strong>SCHAR_MIN</strong></td>
      <td>минимальное значение <emphasis>char</emphasis></td>
     </tr>
     <tr>
      <td><strong>INT_MAX</strong></td>
      <td>+32767</td>
      <td>максимальное значение <emphasis>int</emphasis></td>
     </tr>
     <tr>
      <td><strong>INT_MIN</strong></td>
      <td>-32767 (I.B.:<emphasis>обычно это значение -32768</emphasis>)</td>
      <td>минимальное значение <emphasis>int</emphasis></td>
     </tr>
     <tr>
      <td><strong>LONG_MAX</strong></td>
      <td>+2147463647</td>
      <td>максимальное значение <emphasis>long</emphasis></td>
     </tr>
     <tr>
      <td><strong>LONG_MIN</strong></td>
      <td>-2147483647 (I.B.:<emphasis>обычно это значение -2147483648</emphasis>)</td>
      <td>минимальное значение <emphasis>long</emphasis></td>
     </tr>
     <tr>
      <td><strong>SCHAR_MAX</strong></td>
      <td>+127</td>
      <td>максимальное значение <emphasis>signed char</emphasis></td>
     </tr>
     <tr>
      <td><strong>SCHAR_MIN</strong></td>
      <td>-127 (I.B.:<emphasis>обычно это значение -128</emphasis>)</td>
      <td>минимальное значение <emphasis>signed char</emphasis></td>
     </tr>
     <tr>
      <td><strong>SHRT_MAX</strong></td>
      <td>+32767</td>
      <td>максимальное значение <emphasis>short</emphasis></td>
     </tr>
     <tr>
      <td><strong>SHRT_MIN</strong></td>
      <td>-32767 (I.B.:<emphasis>обычно это значение -32768</emphasis>)</td>
      <td>минимальное значение <emphasis>short</emphasis></td>
     </tr>
     <tr>
      <td><strong>UCHAR_MAX</strong></td>
      <td>255</td>
      <td>максимальное значение <emphasis>unsigned char</emphasis></td>
     </tr>
     <tr>
      <td><strong>UINT_MAX</strong></td>
      <td>65535</td>
      <td>максимальное значение <emphasis>unsigned int</emphasis></td>
     </tr>
     <tr>
      <td><strong>ULONG_MAX</strong></td>
      <td>4294967295</td>
      <td>максимальное значение <emphasis>unsigned long</emphasis></td>
     </tr>
     <tr>
      <td><strong>USHRT_MAX</strong></td>
      <td>65535</td>
      <td>максимальное значение <emphasis>unsigned short</emphasis></td>
     </tr>
    </table>
    <p>Имена, приведенные в следующей таблице, взяты из <strong>&lt;float.h&gt;</strong> и являются константами, имеющими отношение к арифметике с плавающей точкой. Значения (если они есть) представляют собой минимальные значения для соответствующих величин. В каждой реализации устанавливаются свои значения. </p>
    <table>
     <tr>
      <td><strong>FLT_RADIX</strong></td>
      <td>2</td>
      <td>основание для представления порядка, например: 2, 16</td>
     </tr>
     <tr>
      <td><strong>FLT_ROUNDS</strong></td>
      <td/>
      <td>способ округления при сложении чисел с плавающей точкой</td>
     </tr>
     <tr>
      <td><strong>FLT_DIG</strong></td>
      <td>6</td>
      <td>количество верных десятичных цифр</td>
     </tr>
     <tr>
      <td><strong>FLT_EPSILON</strong></td>
      <td>1E-5</td>
      <td>минимальное х, такое, что 1.0 + х != 1.0</td>
     </tr>
     <tr>
      <td><strong>FLT_MANT_DIG</strong></td>
      <td/>
      <td>количество цифр по основанию <strong>FLT_RADIX</strong> в мантиссе</td>
     </tr>
     <tr>
      <td><strong>FLT_MAX</strong></td>
      <td>1E+37</td>
      <td>максимальное число с плавающей точкой</td>
     </tr>
     <tr>
      <td><strong>FLT_MAX_EXP</strong></td>
      <td/>
      <td>максимальное n, такое, что <strong>FLT_RADIX</strong><sup>n</sup>-1 представимо</td>
     </tr>
     <tr>
      <td><strong>FLT_MIN</strong></td>
      <td>1E-37</td>
      <td>минимальное нормализованное число с плавающей точкой</td>
     </tr>
     <tr>
      <td><strong>FLT_MIN_EXP</strong></td>
      <td/>
      <td>минимальное n, такое, что 10<sup>n</sup> представимо в виде нормализованного числа</td>
     </tr>
     <tr>
      <td><strong>DBL_DIG</strong></td>
      <td>10</td>
      <td>количество верных десятичных цифр для типа <emphasis>double</emphasis></td>
     </tr>
     <tr>
      <td><strong>DBL_EPSILON</strong></td>
      <td>1E-9</td>
      <td>минимальное х, такое, что 1.0 + x != 1.0, где x принадлежит типу <emphasis>double</emphasis> </td>
     </tr>
     <tr>
      <td><strong>DBL_MANT_DIG</strong></td>
      <td/>
      <td>количество цифр по основанию <strong>FLT_RADIX</strong> в мантиссе для чисел типа <emphasis>double</emphasis></td>
     </tr>
     <tr>
      <td><strong>DBL_MAX</strong></td>
      <td>1E+37</td>
      <td>максимальное число с плавающей точкой типа <emphasis>double</emphasis></td>
     </tr>
     <tr>
      <td><strong>DBL_MAX_EXP</strong></td>
      <td/>
      <td>максимальное n, такое, что <strong>FLT_RADIX</strong><sup>n</sup>-1 представимо в виде числа типа <emphasis>double</emphasis></td>
     </tr>
     <tr>
      <td><strong>DBL_MIN</strong></td>
      <td>1E-37</td>
      <td>минимальное нормализованное число с плавающей точкой типа <emphasis>double</emphasis></td>
     </tr>
     <tr>
      <td><strong>DBL_MIN_EXP</strong></td>
      <td/>
      <td>минимальное n, такое, что 10<sup>n</sup> представимо в виде нормализованного числа типа <emphasis>double</emphasis></td>
     </tr>
    </table>
   </section>
  </section>
  <section>
   <title>
    <p>Приложение C. Перечень изменений </p>
   </title>
   <p>С момента публикации первого издания этой книги определение языка Си претерпело изменения. Почти все нововведения - это расширения исходной версии языка, выполненные так, чтобы сохранилась совместимость с существующими программами; некоторые изменения касаются устранения двусмысленностей первоначального описания, а некоторые представляют собой модификации, привнесенные существующей практикой. Многие из новых возможностей, впоследствии принятые другими разработчиками Си-компиляторов, были первоначально объявлены в документах, прилагаемых к компиляторам. Комитет ANSI, подготавливая стандарт языка, включил большинство этих изменений, а также ввел другие значительные модификации. Некоторые коммерческие компиляторы реализовали их еще до выпуска официального Си-стандарта. </p>
   <p>В этом приложении сведены воедино различия между языком, определенным в первой его редакции, и той его версии, которая принята в качестве стандарта. Здесь рассматривается только сам язык; вопросы, относящиеся к его окружению и библиотеке, не затрагиваются. Хотя последние и являются важной частью стандарта, но, поскольку в первом издании не делалось попытки описать среду и библиотеку, с соответствующими стандартными элементами сравнивать практически нечего.</p>
   <p>• В стандарте более тщательно, по сравнению с первым изданием, определено и расширено препроцессирование: в его основу явно положены лексемы; введены новые операторы для "склеивания" лексем (<strong>##</strong>) и создания символьных строк (<strong>#</strong>), а также новые управляющие строки, такие как <strong>#elif</strong> и <strong>#pragma</strong>; разрешено повторное определение макроса с той же последовательностью лексем; отменена подстановка параметров внутри строк. Разрешено "склеивание" строк с помощью знака <strong>\</strong> в любом месте, не только в строках и макроопределениях (см. A.12). </p>
   <p>• Минимальное число значимых символов всех внутренних идентификаторов доведено до 31; для идентификаторов с внешней связью оно остается равным 6; буквы нижнего и верхнего регистров не различаются. (Многие реализации допускают большее число значимых символов.) </p>
   <p>• Для знаков <strong>#</strong>, <strong>\</strong>, <strong>^</strong>, <strong>[</strong>, <strong>]</strong>, <strong>{</strong>, <strong>}</strong>, <strong>|</strong>, <strong>~</strong>, которых может не быть в некоторых наборах символов, введены трехзнаковые последовательности, начинающиеся с <strong>??</strong> (см. A12.1). Следует заметить, что введение трехзнаковых последовательностей может повредить значения строк, в которых содержатся <strong>??</strong>.</p>
   <p>• Введены новые ключевые слова (<strong>void</strong>, <strong>const</strong>, <strong>volatile</strong>, <strong>signed</strong>, <strong>enum</strong>), а мертворожденное слово <strong>entry</strong> из обращения изъято.</p>
   <p> • Для символьных констант и строковых литералов определены новые эскейп-последовательности. Объявлено, что появление за <strong>\</strong> символов не из принятых эскейп-последовательностей приводит к непредсказуемому результату (см. A2.5.2.).</p>
   <p>• Узаконено полюбившееся всем тривиальное изменение: 8 и 9 не являются восьмеричными цифрами.</p>
   <p>• Введен расширенный набор суффиксов для явного указания типов констант: <strong>U</strong> и <strong>L</strong> - для целых и <strong>F</strong> и <strong>L</strong> - для типов с плавающей точкой. Уточнены также правила определения типа для констант без суффиксов (A2.5).</p>
   <p>• Объявлено, что соседние строки конкатенируются.</p>
   <p>• Предоставлены средства, позволяющие записывать строковые литералы и символьные константы из расширенного набора символов (A2.6).</p>
   <p>• Объекты типа <strong>char</strong> (как и объекты другого типа) можно специфицировать явно со знаком или без знака. Исключается использование словосочетания <strong>long float</strong> в смысле <strong>double</strong>, но вводится тип <strong>long double</strong> для чисел с плавающей точкой повышенной точности.</p>
   <p>• С некоторых пор доступен тип <strong>unsigned char</strong>. Стандарт вводит ключевое слово <strong>signed</strong> для явного указания, что объект типа <strong>char</strong> или другого целочисленного типа имеет знак.</p>
   <p>• Уже несколько лет в большинстве реализаций доступен тип <strong>void</strong>. Стандарт вводит <strong>void *</strong> в качестве типа обобщенного указателя; раньше для этой цели использовали <strong>char *</strong>. Одновременно вступают в силу правила, по которым запрещается без преобразования типа "смешивать" указатели и целые или указатели разных типов.</p>
   <p>• Стандарт устанавливает минимальные пределы диапазонов арифметических типов, предусматривает заголовочные файлы <strong>&lt;limits.h&gt;</strong> и <strong>&lt;float.h&gt;</strong>, в которых помещаются эти характеристики для каждой конкретной реализации.</p>
   <p>• <strong>Перечисление</strong> - новый тип, которого не было в первой редакции.</p>
   <p>• Стандарт заимствует из C++ способ записи квалификатора типа, в частности квалификатора <strong>const</strong> (A8.2).</p>
   <p>• Вводится запрет на модификацию строк: это значит, что их разрешается размещать в памяти, доступной только на чтение (ПЗУ).</p>
   <p>• Изменены "обычные арифметические преобразования"; по существу, выполнен переход от принципа "для целых всегда превалирует <strong>unsigned</strong>; для плавающей точки всегда используется <strong>double</strong>" к принципу "повышение до минимального достаточно вместительного типа" (см. A6.5).</p>
   <p>• Отменены старые операторы присваивания вроде <strong>=+</strong>. Каждый оператор присваивания теперь представляется одной отдельной лексемой. В первом издании оператор присваивания мог изображаться парой символов, возможно, разделенных символами-разделителями.</p>
   <p>• Компиляторам более не разрешается трактовать математическую ассоциативность операторов как вычислительную ассоциативность.</p>
   <p>• Введен унарный оператор <strong>+</strong> для симметрии с унарным <strong>-</strong>.</p>
   <p>• Разрешено использовать указатель на функцию в качестве ее именующего выражения без явного оператора <strong>*</strong> (см. A7.3.2).</p>
   <p>• Структурами разрешено оперировать при присваиваниях, можно передавать структуры в качестве аргументов функциям и получать их в качестве результата от функций.</p>
   <p>• Разрешено применять оператор получения адреса <strong>&amp;</strong> к массиву; результатом является указатель на массив.</p>
   <p>• В первой редакции результат операции <strong>sizeof</strong> имел тип <strong>int</strong>; во многих реализациях он заменен на <strong>unsigned</strong>. Стандарт официально объявляет его зависимым от реализации, но требует, чтобы он был определен в заголовочном файле <strong>&lt;stddef.h&gt;</strong> под именем <strong>size_t</strong>. Аналогичное изменение было сделано в отношении типа разности указателей) который теперь выступает под именем <strong>ptrdiff_t</strong> (см. A7.4.8 и A7.7).</p>
   <p>• Запрещено применять оператор получения адреса <strong>&amp;</strong> к объекту типа <strong>register</strong> даже тогда, когда данный компилятор не располагает его на регистре.</p>
   <p>• Типом результата операции сдвига является тип ее левого операнда; тип правого операнда на повышение типа результата влияния не оказывает (см. A7.8).</p>
   <p>• Стандарт разрешает адресоваться с помощью указателей на место, лежащее сразу за последним элементом массива, и позволяет оперировать с такими указателями, как с обычными, см. A7.7.</p>
   <p>• Стандарт вводит (заимствованный из C++) способ записи прототипа функции с включением в него типов параметров и явного указания о возможности их изменения и формализует метод работы с переменным списком аргументов. (см. A7.3.2, A8.6.3, B7.) С некоторыми ограничениями доступен и старый способ записи.</p>
   <p>• Стандартом запрещены пустые объявления, т. е. такие, в которых нет объявителей и не объявляется ни одной структуры, объединения или перечисления. Однако объявление с одним тегом структуры (или объединения) переобъявит ее даже в том случае, если она была объявлена во внешней области действия.</p>
   <p>• Запрещены объявления внешних данных, не имеющие спецификаторов и квалификаторов (т. е. объявления с одним "голым" объявителем).</p>
   <p>• В некоторых реализациях, когда <strong>extern</strong>-объявление расположено во внутреннем блоке, его область видимости распространяется на остальную часть файла. Стандарт вносит ясность в эту ситуацию и объявляет, что область видимости такого объявления ограничена блоком.</p>
   <p>• Область видимости параметров "вставляется" в составную инструкцию, представляющую собой тело функции, так что объявления на верхнем уровне функции не могут их "затенить".</p>
   <p>• Несколько изменены именные пространства идентификаторов. Всем тегам структур, объединений и перечислений стандарт выделяет одно именное пространство; для меток инструкций вводится отдельное именное пространство (см. A11.1). Кроме того, имена элементов связаны со структурой или объединением, частью которого они являются. (С некоторых пор это общепринятая практика.)</p>
   <p>• Допускается инициализация объединения; инициализатор относится к первому элементу объединения.</p>
   <p>• Разрешается инициализация автоматических структур, объединений и массивов, хотя и с некоторыми ограничениями.</p>
   <p>• Разрешается инициализация массива символов с помощью строкового литерала по точному количеству указанных символов (без '\0').</p>
   <p>• Управляющее выражение и <strong>case</strong>-метки в <strong>switch</strong> могут иметь любой целочисленный тип. </p>
  </section>
  <section>
   <title>
    <p>Предметный указатель </p>
   </title>
   <p><strong>0... </strong>константа восьмеричная 2.3, A2.5.1</p>
   <p><strong>0x... </strong>константа шестнадцатеричная 2.3, A2.5.1</p>
   <p><strong>...</strong> многоточие 7.3, A7.3.2</p>
   <p><strong>&gt;=</strong> оператор больше или равно 2.6, A7.9</p>
   <p><strong>&gt;</strong> оператор больше чем 2.6, A7.9</p>
   <p><strong>-</strong> оператор вычитания 2.5, A7.7</p>
   <p><strong>--</strong> оператор декремента 1.5.2, 2.8, 5.5, A7.3.4, A7.4.1</p>
   <p><strong>/</strong> оператор деления 1.2, 2.5, A7.6</p>
   <p><strong>%</strong> оператор деления по модулю 2.5, A7.6</p>
   <p><strong>.</strong> оператор доступа к элементу структуры 6.1, A7.3, A7.3.3</p>
   <p><strong>-&gt;</strong> оператор доступа к элементу структуры через указатель 6.2, A7.3, A7.3.3</p>
   <p><strong>,</strong> оператор запятая 3.5, A7.18</p>
   <p><strong>++</strong> оператор инкремента 1.5.2, 2.8, 5.5, A7.4, A7.4.1</p>
   <p><strong>*</strong> оператор косвенного доступа 5.1, A7.4.3</p>
   <p><strong>&amp;&amp;</strong> оператор логического И 1.5.4, 2.6, 2.9, A7.14</p>
   <p><strong>||</strong> оператор логического ИЛИ 1.5.4, 2.6, 2.9, A7.15</p>
   <p><strong>!</strong> оператор логического отрицания 2.6, A7.4, A7.4.7</p>
   <p><strong>&lt;=</strong> оператор меньше или равно 2.6, A7.9</p>
   <p><strong>&lt;</strong> оператор меньше чем 2.6, A7.9</p>
   <p><strong>!=</strong> оператор неравенства 1.5.1, 2.6, A7.10</p>
   <p><strong>&amp;</strong> оператор побитового И 2.9, A7.11</p>
   <p><strong>|</strong> оператор побитового ИЛИ 2.9, A7.13</p>
   <p><strong>^</strong> оператор побитового исключающего ИЛИ 2.9, A7.12</p>
   <p><strong>~</strong> оператор побитового отрицания 2.9, A7.4.6</p>
   <p><strong>&amp;</strong> оператор получения адреса 5.1, A7.4.2</p>
   <p><strong>#</strong> оператор препроцессора 4.11.2, A12.3</p>
   <p><strong>##</strong> оператор препроцессора 4.11.2, A12.3</p>
   <p><strong>=</strong> оператор присваивания 1.5.1, 2.6, A7.17</p>
   <p><strong>+=</strong> оператор присваивания 2.10</p>
   <p><strong>==</strong> оператор равенства 1.5.3, 2.6, A7.10</p>
   <p><strong>&lt;&lt;</strong> оператор сдвига влево 2.9, A7.8</p>
   <p><strong>&gt;&gt;</strong> оператор сдвига вправо 2.9, A7.8</p>
   <p><strong>+</strong> оператор сложения 2.5, A7.7</p>
   <p><strong>*</strong> оператор умножения 2.5, A7.6</p>
   <p><strong>-</strong> оператор унарный минус A7.4.5</p>
   <p><strong>+</strong> оператор унарный плюс A7.4.4</p>
   <p><strong>"</strong> символ двойная кавычка 1.1, 1.5.3, 2.3, A2.5.2, A2.6</p>
   <p><strong>'</strong> символ кавычка 1.5.3, 2.3, A2.5.2</p>
   <p><strong>\0</strong> символ нулевой 1.9, 2.3, A2.5.2</p>
   <p><strong>\\</strong> символ обратная наклонная черта 1.1, 2.3</p>
   <p><strong>_</strong> символ подчеркивания 2.1, A2.3, B</p>
   <p><strong>?:</strong> условное выражение 2.11, A7.16</p>
   <subtitle>А</subtitle>
   <p>аргументы командной строки 5.10</p>
   <subtitle>Б</subtitle>
   <p>бесконечный цикл for( ; ; ) 3.5, 4.11.2</p>
   <p>библиотечная функция 1.1, 4.1, 4.3, Приложение B</p>
   <p> abort B5</p>
   <p> abs B5</p>
   <p> acos B4</p>
   <p> asctime B10</p>
   <p> asin B4</p>
   <p> atan, atan2 7.8.6, B4</p>
   <p> atof B5</p>
   <p> atoi B5</p>
   <p> atol B5</p>
   <p> bsearch B5</p>
   <p> calloc 7.8.5, B5</p>
   <p> ceil B4</p>
   <p> clearerr B1.7</p>
   <p> clock B10</p>
   <p> cos 7.8.6, B4</p>
   <p> cosh B4</p>
   <p> ctime B10</p>
   <p> difftime B10</p>
   <p> div B5</p>
   <p> exit 7.6, B5</p>
   <p> exp 7.8.6, B4</p>
   <p> fabs 7.8.6, B4</p>
   <p> fclose 7.5, B1.1</p>
   <p> feof 7.6, B1.7</p>
   <p> ferror B1.7</p>
   <p> fflush B1.1</p>
   <p> fgetc B1.4</p>
   <p> fgetpos B1.6</p>
   <p> fgets 7.7, B1.4</p>
   <p> filecopy 7.6 </p>
   <p> floor B4</p>
   <p> fmod B4</p>
   <p> fopen 7.5, B1.1</p>
   <p> fprintf 7.5, B1.2</p>
   <p> fputc B1.4</p>
   <p> fputs 7.7, B1.4</p>
   <p> fread B1.5</p>
   <p> free B5</p>
   <p> freopen B1.1</p>
   <p> frexp B4</p>
   <p> fscanf 7.5, B1.3</p>
   <p> fseek B1.6</p>
   <p> fsetpos B1.6</p>
   <p> ftell B1.6</p>
   <p> fwrite B1.5</p>
   <p> getc 7.5, B1.4</p>
   <p> getchar 1.5, 7.1, 7.5, B1.4</p>
   <p> getenv B5</p>
   <p> gets B1.4</p>
   <p> gmtime B10</p>
   <p> isalnum 7.8.2, B2</p>
   <p> isalpha 7.8.2, B2</p>
   <p> iscntrl B2</p>
   <p> isdigit 7.8.2, B2</p>
   <p> isgraph B2</p>
   <p> islower 7.8.2, B2</p>
   <p> isprint B2</p>
   <p> ispunct B2</p>
   <p> isspace 7.8.2, B2</p>
   <p> isupper 7.8.2, B2</p>
   <p> isxdigit B2</p>
   <p> labs B5</p>
   <p> ldexp B4</p>
   <p> ldiv B5</p>
   <p> localtime B10</p>
   <p> log, log10 7.8.6, B4</p>
   <p> longjmp B8 </p>
   <p> malloc 6.5, 7.8.5, B5 </p>
   <p> memchr B3</p>
   <p> memcmp B3 </p>
   <p> memcpy B3</p>
   <p> memmove B3</p>
   <p> memset B3</p>
   <p> mktime B10</p>
   <p> modf B4</p>
   <p> perror B1.7</p>
   <p> pow 7.8.6, B4</p>
   <p> printf B1.2</p>
   <p> putc 7.5, B1.4</p>
   <p> putchar 1.5, 7.1, B1.4</p>
   <p> puts 7.7, B1.4</p>
   <p> qsort B5</p>
   <p> raise B9</p>
   <p> rand B5</p>
   <p> realloc B5</p>
   <p> remove B1.1</p>
   <p> rename B1.1</p>
   <p> rewind B1.6</p>
   <p> scanf 7.4, B1.3</p>
   <p> setbuf B1.1</p>
   <p> setjmp B8</p>
   <p> setvbuf B1.1</p>
   <p> signal B9</p>
   <p> sin 7.8.6, B4</p>
   <p> sinh B4</p>
   <p> sprintf 7.2, B1.2</p>
   <p> sqrt 7.8.6, B4</p>
   <p> srand B5</p>
   <p> sscanf B1.3</p>
   <p> strcat 7.8.1, B3</p>
   <p> strchr 7.8.1, B3</p>
   <p> strcmp 7.8.1, B3</p>
   <p> strcpy 7.8.1, B3</p>
   <p> strcspn B3</p>
   <p> strerror B3</p>
   <p> strftime B10</p>
   <p> strlen 7.8.1, B3</p>
   <p> strncat 7.8.1, B3</p>
   <p> strncmp 7.8.1, B3</p>
   <p> strncpy 7.8.1, B3</p>
   <p> strpbrk B3</p>
   <p> strrchr 7.8.1, B3</p>
   <p> strspn B3</p>
   <p> strstr B3</p>
   <p> strtod B5</p>
   <p> strtok B3</p>
   <p> strtol B5</p>
   <p> strtoul B5</p>
   <p> system B5</p>
   <p> tan B4</p>
   <p> tanh B4</p>
   <p> time B10</p>
   <p> tmpfile B1.1</p>
   <p> tmpnam B1.1</p>
   <p> tolower 7.8.2, B2</p>
   <p> toupper 7.8.2, B2</p>
   <p> ungetc 7.8.3, B1.4</p>
   <p> vfprintf 8.3, B1.2</p>
   <p> vprintf 8.3, B1.2</p>
   <p> vsprintf 8.3, B1.2</p>
   <p>бинарное дерево 6.5</p>
   <p>бинарный поток 7.5, B1</p>
   <p>битовое поле</p>
   <p> выравнивание 6.9, A8.3</p>
   <p> объявление 6.9, A8.3</p>
   <p>биты, образцы манипулирования 2.9, 6.9</p>
   <p>блок см. <emphasis>также</emphasis> составная инструкция</p>
   <p> структура 3.1, 4.8, A9.3</p>
   <p> инициализация в. 4.9, A9.3 </p>
   <p>буферизация см. setbuf, setvbuf</p>
   <p>буферизованный getchar 8.2</p>
   <p>быстрая сортировка 4.10, 5.6</p>
   <subtitle>В</subtitle>
   <p>ввод</p>
   <p> без буферизации 8.2</p>
   <p> возврат символа на 4.3 </p>
   <p> с буферизацией 8.2</p>
   <p> с клавиатуры 1.1, 7.1, 8.1</p>
   <p> форматный см. scanf</p>
   <p>ввод-вывод</p>
   <p> символов 1.5, 7.1</p>
   <p> ошибки 7.6, B1.7</p>
   <p> перенаправление 7.1, 7.5, 8.1</p>
   <p> с терминала 1.5</p>
   <p>високосный год, вычисление 2.5, 5.7</p>
   <p>вывод на экран 1.5, 7.1, 7.5, 8.1</p>
   <p> перенаправление 7.1 </p>
   <p> форматный см. printf</p>
   <p>вызов</p>
   <p> по значению 1.8, 5.2, A7.3.2</p>
   <p> по указателю 1.8, 5.3</p>
   <p>выравнивание битового поля </p>
   <p> с помощью union 8.7</p>
   <p> ограничения по 6.4, 6.5, 6.8, 7.8.5, 8.7, A6.6</p>
   <p>выражение A7</p>
   <p> в скобках A7.2</p>
   <p> константное 2.3, 3.4, 4.11.3, A7.19 </p>
   <p> логическое, численное значение 2.7</p>
   <p> очередность вычисления 2.12, A7</p>
   <p> первичное A7.2 </p>
   <p> присваивания 1.5.1, 1.5.4, 2.10, A7.17</p>
   <p>выражение-инструкция 3.1, 3.2, A9.2</p>
   <p>вычисление, порядок 1.5.4, 2.9, 2.12, 3.5, 4.3, 4.11.2, 5.1, A7</p>
   <p>вычитание из указателя 5.4, 6.4, A6.6</p>
   <subtitle>Г</subtitle>
   <p>грамматический разбор методом рекурсивного спуска 5.12</p>
   <p>граничные условия 1.5.2, 3.7</p>
   <subtitle>Д</subtitle>
   <p>деление целых 1.2, 2.5</p>
   <p>дерево </p>
   <p> бинарное 6.5 </p>
   <p> разбора 5.12</p>
   <p>дескриптор файла 8.1</p>
   <p>длина</p>
   <p> имени 2.1, A2.3</p>
   <p> переменной A2.3</p>
   <p> строки 2.3</p>
   <subtitle>Е</subtitle>
   <p>единица трансляции A2, A7.17, A8.2</p>
   <subtitle>З</subtitle>
   <p>завершение программы 7.6</p>
   <p>загадочные числа 1.4 </p>
   <p>знак, размножение 2.7, A2.5.2</p>
   <subtitle>И</subtitle>
   <p>идентификатор A2.3</p>
   <p>имени затенение 4.8</p>
   <p>имен пространство A11.1 </p>
   <p>именующее выражение функции A7.3.2</p>
   <p>имя A2.3</p>
   <p>индекс отрицательный 5.3</p>
   <p>индексирование массива 1.6, 5.3, A7.3.1, A8.6.2</p>
   <p> и указатели 5.3, A8.6.2 </p>
   <p>инициализатор 4.9, A8.7</p>
   <p>инициализация 2.4, 4.9, A8.7</p>
   <p> в блоке 4.9, A9.3</p>
   <p> двумерных массивов 5.7, A8.7</p>
   <p> массива 4.9, 5.8, A8.7</p>
   <p> массивов структур 6.3</p>
   <p> объединения A8.7</p>
   <p> переменных </p>
   <p>  автоматических 1.10, 2.4, 4.9, A8.7</p>
   <p>  внешних 2.4, 4.4, 4.9, A8.7</p>
   <p>  статических 2.4, 4.9, A8.7</p>
   <p> по умолчанию 4.9, A8.7</p>
   <p> строковой константой 4.9, A8.7</p>
   <p> структуры 6.1, A8.7</p>
   <p> указателя 5.4 </p>
   <p>инструкции A9</p>
   <p> выбора A9.4</p>
   <p> перехода A9.6 </p>
   <p> присваивания вложенные 1.5.1, 1.5.4, 2.11</p>
   <p> последовательность выполнения A9.3</p>
   <p>инструкция</p>
   <p> окончание 1.5.2, 3.1 </p>
   <p> помеченная A9.1 </p>
   <p> пустая 1.5.2, A9.2 </p>
   <p>исключительные ситуации B9</p>
   <subtitle>К</subtitle>
   <p>квалификатор типа A7.17, A8.2</p>
   <p>ключевые слова A2.4</p>
   <p>командная строка аргументов 5.10</p>
   <p>комментарий 1.2, A2.2, A12</p>
   <p>компиляция </p>
   <p> нескольких файлов 4.1</p>
   <p> раздельная 4, 4.4, A11 </p>
   <p> Си-программ 1.1, 1.7</p>
   <p>конец файла см. EOF</p>
   <p>конкатенация</p>
   <p> лексем 4.11.2, A12.3</p>
   <p> строк 2.3, 4.11.2, A2.6</p>
   <p>константа 2.3, A2.5</p>
   <p> восьмеричная 0... 2.3, A2.5.1 </p>
   <p> из расширенного набора A2.5.2</p>
   <p> перечисления 2.3, A2.5.4, A8.4</p>
   <p> символьная 1.5.3, 2.3, A2.5.2</p>
   <p> с плавающей точкой 1.2, 2.3, A2.5.3</p>
   <p> строковая 1.1, 1.5.3, 1.9, 2.3, 5.3, 5.5, A2.6</p>
   <p> суффикс 2.3, A2.5.1</p>
   <p> тип 2.2, A2.5 </p>
   <p> шестнадцатеричная 0x... 2.3, A2.5.1</p>
   <p>константное выражение 2.3, 3.4, 4.11.3, A7.19</p>
   <subtitle>Л</subtitle>
   <p>лексема A2.1, A12.3</p>
   <p> конкатенация 4.11.2, A12.3</p>
   <p> подстановка A12.3</p>
   <p>лексика, соглашения A2</p>
   <p>лексикографическая сортировка 5.11</p>
   <p>лексическая область видимости A11.1</p>
   <p>литерал строковый см. <emphasis>константа строковая</emphasis></p>
   <subtitle>М</subtitle>
   <p>макро-процессор 4.11, A12</p>
   <p> см. также <emphasis>препроцессор</emphasis></p>
   <p>макрос</p>
   <p> расширение A12.3 </p>
   <p> с аргументами 4.11.2 </p>
   <p> feof 8.5 </p>
   <p> ferror 8.5 </p>
   <p> getc 8.5 </p>
   <p> putc 8.5 </p>
   <p>массив</p>
   <p> а не указатель 5.3, 5.5, 5.7</p>
   <p> двумерный 5.7, A8.7</p>
   <p> имя в роли аргумента 1.8, 5.3, 5.7</p>
   <p> индексирование в 1.6, 5.4, A7.3.1</p>
   <p> многомерный 5.7, A8.6.2</p>
   <p> объявитель A8.6.2</p>
   <p> объявление 1.6, 5.7, A8.6.2 </p>
   <p> порядок элементов в памяти 5.7, A8.6.2</p>
   <p> преобразование имени 5.3, A7.1</p>
   <p> размер по умолчанию 4.9, 5.8, 6.3</p>
   <p> символов 1.9, 5.5</p>
   <p> ссылки на элементы A7.3.1</p>
   <p> структур 6.3</p>
   <p>  инициализация 6.3</p>
   <p> указателей 5.6</p>
   <p>масштабирование целых в арифметике с указателями 5.4, 6.4, A7.7</p>
   <p>метка 3.8, A9.1 </p>
   <p> область видимости 3.8, A9.1, A11.1</p>
   <p> case 3.4, A9.1</p>
   <p> default 3.4, A9.1</p>
   <p>многопутевое ветвление 1.6, 3.3</p>
   <p>многоточие ... 7.3, A7.3.2</p>
   <p>множественное присваивание 1.5</p>
   <p>модульность 1.7, 1.9, 1.10, 4, 4.3, 5.6</p>
   <subtitle>H</subtitle>
   <p>небуферизованный getchar 8.2 </p>
   <p>незавершенный тип A8.3 </p>
   <p>неоднозначность if-else 3.2, A9.4, A13</p>
   <p>неправильная арифметика с указателями 5.4, 6.4, A7.7</p>
   <p>несоответствие типов объявлений 4.2</p>
   <p>нотация синтаксиса A3</p>
   <p>нуль, опущенная проверка на нуль 3.2, 5.5</p>
   <subtitle>O</subtitle>
   <p>область видимости A4, A11.1</p>
   <p> автоматических переменных 4.4, A11.1</p>
   <p> внешних объектов 4.4, A11.1</p>
   <p> лексическая A11.1 </p>
   <p> меток 3.8, A9.1, A11.1</p>
   <p> правила определения 4.4, A10_2</p>
   <p>обобщенный указатель см. <emphasis>void *</emphasis>, <emphasis>указатель</emphasis></p>
   <p>обратная польская запись 4.3</p>
   <p>объединение, тег A8.3</p>
   <p>объект A4.1, A5</p>
   <p>объявитель A8.5</p>
   <p>абстрактный A8.8</p>
   <p>массива A8.6.2 </p>
   <p>функции A8.6.3 </p>
   <p>объявление 1.2, 2.4, A8</p>
   <p> а не определение 1.10, 4.4, A8.1</p>
   <p> битового поля 6.9, A8.3</p>
   <p> внешнее A10, A10.2</p>
   <p> внешней переменной 1.10, A10</p>
   <p> класса памяти A8.1</p>
   <p> массива 1.6, 5.7, A8.6.2 </p>
   <p> структуры 6.1, A8.3</p>
   <p> типа A8.6 </p>
   <p> указателя 5.1, 5.3, A8.6.1 </p>
   <p> функции A8.6.3 </p>
   <p>  неявное 1.7, 4.2, A7.3.2</p>
   <p>  новым способом A7.3.2</p>
   <p>  старым способом 1.7, 1.10, 4.2, A7.3.2 </p>
   <p> typedef 6.7, A8.1, A8.9</p>
   <p> union 6.8, A8.3</p>
   <p>оператор </p>
   <p> больше &gt; 2.6, A7.9</p>
   <p> больше или равно &gt;= 2.6, A7.9</p>
   <p> вычитания - 2.5, A7.7</p>
   <p> декремента -- 1.5.2, 2.8, 5.5, A7.3.4, A7.4.1</p>
   <p> деления / 1.2, 2.5, A7.6 </p>
   <p> деления по модулю % 2.5, A7.6</p>
   <p> доступа к элементу структуры </p>
   <p>  точка . 6.1, A7.3, A7.3.3</p>
   <p>  через указатель -&gt; 6.2, A7.3 </p>
   <p> запятая , 3.5, A7.18 </p>
   <p> инкремента ++ 1.5.2, 2.8, 5.5, A7.3.4, A7.4.1</p>
   <p> косвенного доступа * 5.1, A7.4.3</p>
   <p> логический отрицания ! 2.6, A7.4, A7.4.7</p>
   <p> логического И &amp;&amp; 1.5.4, 2.6, 2.9, A7.14</p>
   <p> логического ИЛИ || 1.5.4, 2.6, 2.9, A7.15</p>
   <p> меньше &lt; 2.6, A7.9</p>
   <p> меньше или равно &lt;= 2.6, A7.9</p>
   <p> неравенства != 1.5.1, 2.6, A7.10</p>
   <p> побитового отрицания ~ 2.9, A7.4.6</p>
   <p> получения адреса &amp; 5.1, A7.4.2</p>
   <p> приведения к типу 2.7, 2.7, 6.5, A6.6, A7.5, A8.8</p>
   <p> присваивания = 1.5.1, 2.6, A7.17</p>
   <p> присваивания += 2.10</p>
   <p> равенства == 1.5.3, 2.6, A7.10</p>
   <p> сдвига влево &lt;&lt; 2.9, A7.8</p>
   <p> сдвига вправо &gt;&gt; 2.9, A7.8 </p>
   <p> сложения + 2.5, A7.7</p>
   <p> умножения * 2.5, A7.6</p>
   <p> унарного минуса - A7.4.5</p>
   <p> унарного плюса + A7.4.4</p>
   <p> sizeof 4.11.3, 5.4, 6.3, A7.4, A7.4.8</p>
   <p>операторы</p>
   <p> аддитивные A7.7</p>
   <p> арифметические 2.5</p>
   <p> ассоциативность 2.12, A7</p>
   <p> мультипликативные A7.6</p>
   <p> отношения 1.5.1, 2.6, 2.7, A7.9</p>
   <p> побитовые 2.9, A7.11</p>
   <p> приоритет 1.5.1, 2.12, 5.1, 6.2, A7</p>
   <p> присваивания 2.6, 2.10, A7.17</p>
   <p> равенства 2.6, A7.10</p>
   <p>операции над</p>
   <p> объединениями 6.8</p>
   <p> указателями 5.4</p>
   <p>определение</p>
   <p> аргумента 1.7, A7.3.2</p>
   <p> внешней переменной 1.10, A10.2</p>
   <p> макросов A12.3</p>
   <p> памяти A8 </p>
   <p> параметра 1.7, A7.3.2</p>
   <p> пробное A10.2</p>
   <p> удаление см. #undef </p>
   <p> функции 1.7, 4.1, A10.1</p>
   <p>опущенный спецификатор</p>
   <p> класса памяти A8.1 </p>
   <p> типа A8.2</p>
   <p>отбрасывание</p>
   <p> значения с плавающей точкой 2.7, A6.3</p>
   <p> при делении 1.2, 2.5, A7.6</p>
   <p>отрицательные индексы 5.3</p>
   <p>отступы в тексте программы 1.2, 1.5.3, 1.6, 3.2</p>
   <subtitle>П</subtitle>
   <p>память</p>
   <p> автоматическая 1.10, A4.1</p>
   <p> класс A4.1</p>
   <p> объявление класса A8.1</p>
   <p> определение A8.1</p>
   <p> распределитель 6.5, 8.7</p>
   <p> резервирование A8.1</p>
   <p> спецификатор класса A8.1</p>
   <p>  опущенный A8.1</p>
   <p> статическая 1.10, 4.6, A4.1</p>
   <p>параметр 4.7, 5.3, A7.3.2</p>
   <p> определение 1.7, A7.3.2</p>
   <p>первичное выражение A7.2</p>
   <p>переменная A4 </p>
   <p> автоматическая 1.8, 4.3, A4.1</p>
   <p> адрес 1.8, 5.1, A7.4.2 </p>
   <p> внешняя 1.10, 4.3, A4.1 </p>
   <p> синтаксис имени 2.1, A2.1</p>
   <p>переносимость Введение, 2.3, 2.7, 6.7, 7, 8.6</p>
   <p>переполнение A6, B4, B9 </p>
   <p>перечисление</p>
   <p> константа 2.3, A2.5.4, A8.4</p>
   <p> тег A8.4</p>
   <p> тип A4.2 </p>
   <p>перечислитель A2.5.4, A8.4</p>
   <p>побочный эффект 2.12, 4.11.2, A7, A7.3.2</p>
   <p>повышение</p>
   <p> типа аргумента 2.7, A7.3.2</p>
   <p> целочисленное 2.7, A6.1</p>
   <p>подмассив-аргумент 5.3</p>
   <p>поле см. битовое поле </p>
   <p>польская запись 4.3</p>
   <p>порядок</p>
   <p> в записи числа 2.3, A2.5.3</p>
   <p> выполнения инструкций A9</p>
   <p> вычислений 1.5.4, 2.9, 2.12, 3.5, 4.3, 4.11.2, 5.1, A7</p>
   <p> трансляции A12</p>
   <p>поток</p>
   <p> бинарный 7.5, B1</p>
   <p> текстовый 1.5, 7.1, B1</p>
   <p>по умолчанию</p>
   <p> инициализация 4.9, A8.7</p>
   <p> размер массива 4.9, 5.8, 6.3</p>
   <p> тип функции 1.9, A7.3.2</p>
   <p>преобразование A6</p>
   <p> даты 5.7 </p>
   <p> имени массива 5.3, A7.1</p>
   <p> инструкцией return 4.2, A9.6</p>
   <p> обычное арифметическое 2.7, A6.5</p>
   <p> оператором приведения 2.7, A6.6, A7.5</p>
   <p> присваиванием 2.7, A7.17</p>
   <p> символ - целое 1.6, 2.7, A6.1</p>
   <p> с плавающей точкой - целое 2.7, A6.3</p>
   <p> указатель - целое A6.6</p>
   <p> указателя 6.5, A6.6</p>
   <p> функции A7.1</p>
   <p> целое - символ 2.7 </p>
   <p> целое - с плавающей точкой 1.2, A6.3</p>
   <p> целое - указатель A6.6</p>
   <p> double - float 2.7, A6.4</p>
   <p> float - double 2.7, A6.4</p>
   <p>препроцессор </p>
   <p> заранее определенные имена A12.10</p>
   <p>  __FILE__ A12.10, B6</p>
   <p>  __LINE__ A12.10, B6</p>
   <p> макрос 4.11, A12</p>
   <p> оператор препроцессора </p>
   <p>  # 4.11.2, A12.3</p>
   <p>  ## 4.11.2, A12.3</p>
   <p>  defined 4.11.3, A12.5</p>
   <p>приведение к типу 2.7, A6.6, A7.5</p>
   <p>приоритеты операторов 1.5.1, 2.12, 5.1, 6.2, A7</p>
   <p>присваивание</p>
   <p> выражение 1.5.1, 1.5.4, 2.9, A7.17</p>
   <p> инструкция вложенная 1.5.1, 1.5.4, 2.10</p>
   <p> множественное 1.5.4</p>
   <p> подавленное scanf 7.4, B1.3</p>
   <p>пробное определение A10.2</p>
   <p>программа</p>
   <p> аргументы см. аргументы командной строки</p>
   <p> калькулятор 4.2, 4.3, 7.4</p>
   <p> конкатенации файлов 7.5</p>
   <p> копирования файлов 1.5.1, 8.2, 8.3</p>
   <p> перевода в нижний регистр 7.1</p>
   <p> печати </p>
   <p>  каталога 8.6 </p>
   <p>  самой длинной строки 1.9, 1.10</p>
   <p> подсчета </p>
   <p>  ключевых слов 6.3</p>
   <p>  символов 1.5.2</p>
   <p>  символов-разделителей 1.6, 3.4</p>
   <p>  слов 1.5.4, 6.5</p>
   <p>  строк 1.5.3</p>
   <p> поиска</p>
   <p>  в таблице 6.6</p>
   <p>  по образцу 4.1, 5.10</p>
   <p> преобразования температур 1.2</p>
   <p> сортировки 5.6, 5.11</p>
   <p> формат 1.2, 1.5.2, 1.6, 2.4, 6.4, A</p>
   <p> читаемость 1.2, 2.10, 3.6, 4.9, 6.7</p>
   <p>производные типы Введение, 1.2, A4.3 </p>
   <p>пространство имен A11.1</p>
   <p>прототип функции 1.7, 1.9, 2.7, 4.2, 5.11, A7.3.2</p>
   <subtitle>Р</subtitle>
   <p>раскрытие указателя см. <emphasis>оператор косвенного обращения</emphasis> </p>
   <p>расположение фигурных скобок 1.2</p>
   <p>распределитель памяти 6.5, 8.7</p>
   <p>регистр, адрес A8.1 </p>
   <p>резервирование памяти A8 </p>
   <p>рекурсивный спуск в грамматическом разборе 5.12</p>
   <p>рекурсия 4.10, 6.5, 8.6, A7.3.2</p>
   <p>Ритчи Д. М. Предисловие к первому изданию</p>
   <p>Ричардс М. Введение</p>
   <subtitle>С</subtitle>
   <p>связь A4.1, A11.1</p>
   <p> внешняя 4.3, A2.3, A4.1, A8.1, A11.2</p>
   <p> внутренняя A4.1, A11.2</p>
   <p>символ </p>
   <p> беззнаковый 2.7, A4.2</p>
   <p> ввод-вывод 1.5</p>
   <p> вертикальная табуляция \v 2.3, A2.5.2</p>
   <p> возврат каретки \r 2.3, A2.5.2 </p>
   <p> двойная кавычка " 1.1, 1.5.3, 2.3, A2.5.2, A2.6</p>
   <p> знаковый 2.7, A4.2</p>
   <p> кавычка ' 1.5.3, 2.3, A2.5.2 </p>
   <p> новая страница \f 2.3, A2.5.2 </p>
   <p> новая строка \n 1.1, 1.4, 1.5.3, 2.3, 2.3, A2.1, A2.5.2, A12.2, B1</p>
   <p> обратная наклонная черта \\ 1.1, 2.3</p>
   <p> подчеркивания _ 2.1, A2.3, B</p>
   <p> сигнал-звонок \a 2.3, A2.5.2</p>
   <p>символы </p>
   <p> набор A12</p>
   <p>  ASCII 1.5.3, 2.3, 2.7, A12.1, B2</p>
   <p>  EBCDIC 2.7</p>
   <p>  ISO A12.1</p>
   <p> разделители 7.4, 7.8.2, A2.1, B1.3, B2</p>
   <p> строка см. константа строковая</p>
   <p>символы-разделители 7.4, 7.8.2, A2.1, B1.3, B2</p>
   <p>синтаксис имен переменных 2.1, A2.3</p>
   <p>системный вызов 8</p>
   <p> close 8.3</p>
   <p> creat 8.3</p>
   <p> fstat 8.6</p>
   <p> lseek 8.4</p>
   <p> open 8.3 </p>
   <p> read 8.2</p>
   <p> sbrk 8.7</p>
   <p> stat 8.6</p>
   <p> unlink 8.3</p>
   <p> write 8.2</p>
   <p>склеивание строк A12.2</p>
   <p>сокрытие информации 4.1, 4.3, 4.3</p>
   <p>сортировка</p>
   <p> лексикографическая 5.11</p>
   <p> текстовых строк 5.6, 5.11 </p>
   <p> численная 5.11</p>
   <p>составная инструкция 3.2, 4.8, A9.3, A9.5</p>
   <p>спецификатор </p>
   <p> класса памяти A8.1</p>
   <p>  опущенный A8.1</p>
   <p> типа A8.2</p>
   <p> auto A8.1</p>
   <p> enum 2.3, A8.4</p>
   <p> extern 49-51, 4.4, A8.1</p>
   <p> register 4.7, A8.1</p>
   <p> static 4.6, A8.1</p>
   <p> struct A8.3</p>
   <p> union A8.3</p>
   <p>список </p>
   <p> аргументов переменной длины 7.3, 8.3, A7.3.2, A8.6.3, A10.1, B7</p>
   <p> ключевых слов A2.4</p>
   <p>сравнение указателей 5.4, 6.4, 8.7, A7.9</p>
   <p>стандартный </p>
   <p> ввод 7.1, 7.5, 8.1</p>
   <p> вывод 7.1, 8.1</p>
   <p>строка</p>
   <p> длина 2.3</p>
   <p> конкатенация 2.3, 4.11.2, A2.6</p>
   <p> пустая 2.3</p>
   <p> тип A7.2</p>
   <p>структура</p>
   <p> вложенная 6.1</p>
   <p> имя элемента 6.1, A8.3</p>
   <p> инициализация 6.1, A8.7</p>
   <p> объявление 6.1, A8.3</p>
   <p> оператор доступа к ее элементу </p>
   <p>  . (точка) 6.1, A7.3.3</p>
   <p>  через указатель -&gt; 6.2, A7.3.3</p>
   <p> размер 6.4, A7.4.8</p>
   <p> семантика ссылки на нее A7.3.3</p>
   <p> синтаксис ссылки на нее A7.3.3</p>
   <p> ссылающаяся на себя 6.5, A8.3</p>
   <p> тег 6.1, A8.3</p>
   <p> указатель на нее 6.4</p>
   <p>структуры взаимно рекурсивные 6.5, A8.3</p>
   <p>суффикс в константе A2.5.1</p>
   <subtitle>Т</subtitle>
   <p>таблица</p>
   <p> операторов 2.12</p>
   <p> преобразований в printf 7.2, B1.2</p>
   <p> преобразований в scanf 7.4, B1.3</p>
   <p> стандартных заголовочных файлов B</p>
   <p> эскейп-последовательностей 2.3, A2.5.2</p>
   <p>тег</p>
   <p> объединения A8.3</p>
   <p> перечисления A8.4</p>
   <p> структуры 6.1, A8.3</p>
   <p>текстовый поток 1.5, 7.1, B1</p>
   <p>тип</p>
   <p> имя A8.8</p>
   <p> квалификатор A7.17, A8.2</p>
   <p> константы 2.3, A2.5 </p>
   <p> незавершенный A8.3</p>
   <p> несовместимость в объявлениях 4.2</p>
   <p> объявление A8.6</p>
   <p> опущенный спецификатор A8.2</p>
   <p> правила преобразования 2.7, A6.5</p>
   <p> преобразование в return 4.2, A9.6</p>
   <p> спецификатор A8.2</p>
   <p> строки A7.2 </p>
   <p> эквивалентность A8.9</p>
   <p>типы </p>
   <p> арифметические 5.4</p>
   <p> базовые 1.2, 55, A4.2 </p>
   <p> производные Введение, 1.2, A4.3</p>
   <p> с плавающей точкой A4.2</p>
   <p> целочисленные A4.2 </p>
   <p>Томпсон К. Л. Введение</p>
   <p>точка с запятой ; 1.2, 1.4, 1.5.2, 3.1, 3.2</p>
   <p>транслируемая единица (единица трансляции) A2, A10, A11 </p>
   <p>трансляция </p>
   <p> порядок A12</p>
   <p> фазы A2, A12</p>
   <p>трехзнаковая последовательность A12.1</p>
   <subtitle>У</subtitle>
   <p>удаленное определение см. #undef </p>
   <p>указатели </p>
   <p> арифметика с 5.1, 5.3, 5.4, 5.10, 6.4, A7.7</p>
   <p> вычитание 5.4, 6.4, A6.6 </p>
   <p> и индексирование 5.3, A8.6.2 </p>
   <p> коэффициент домножения целых в арифметике с 5.4, 6.4, A7.7</p>
   <p> массив из 5.6 </p>
   <p> неправильная арифметика с 5.4, 6.4, A7.7</p>
   <p> операции над 5.4</p>
   <p> сравнение 5.4, 6.4, 8.7, A7.9 </p>
   <p>указатель</p>
   <p> а не массив 5.3, 5.5, 5.7</p>
   <p> аргумент 5.2, 5.3</p>
   <p> генерация A7.1</p>
   <p> инициализация 5.4</p>
   <p> на структуру 6.4</p>
   <p> на функцию 5.11, 6.7, A7.3.2</p>
   <p> объявление 5.1, 5.3, A8.6.1 </p>
   <p> преобразование 6.5, A6.6</p>
   <p> пустой 5.4, A6.6</p>
   <p> файла 7.5, 8.5, B1 </p>
   <p> void * 5, 5.4, 5.11, A6.8 </p>
   <p>управляющая строка 4.11, A12.3</p>
   <p>управляющий символ B2</p>
   <p>условная компиляция 4.11.3, A12.5</p>
   <p>условное выражение 2.11, A7.16</p>
   <subtitle>Ф</subtitle>
   <p>фазы трансляции A12</p>
   <p>файл </p>
   <p> включаемый </p>
   <p>  dir.h 8.6</p>
   <p>  fcntl.h 8.3</p>
   <p>  stat.h 8.6</p>
   <p>  syscalls.h 8.2</p>
   <p>  types.h 8.6</p>
   <p> включение 4.11</p>
   <p> дескриптор 8.1</p>
   <p> добавление к 7.5, 8.4, B1 </p>
   <p> доступ к 7.5, 8.1, 8.5, B1 </p>
   <p> заголовочный 1.10, 4.5 </p>
   <p>  &lt;assert.h&gt; B6 </p>
   <p>  &lt;ctype.h&gt; 2.7, B2</p>
   <p>  &lt;errno.h&gt; B1.7</p>
   <p>  &lt;float.h&gt; 2.2, B11</p>
   <p>  &lt;limits.h&gt; B11</p>
   <p>  &lt;locale.h&gt; B</p>
   <p>  &lt;math.h&gt; 2.7, B4</p>
   <p>  &lt;setjmp.h&gt; B8</p>
   <p>  &lt;signal.h&gt; B9</p>
   <p>  &lt;stdarg.h&gt; 7.3, 8.3, B7</p>
   <p>  &lt;stddef.h&gt; 5.4, B</p>
   <p>  &lt;stdio.h&gt; 1.1, 1.5.1, 4.11.1, 4.11.2, 5.4, 7, 7.1, B</p>
   <p>  &lt;stdlib.h&gt; 4.2, 6.5, B, B5</p>
   <p>  &lt;string.h&gt; 2.3, 5.6, B3</p>
   <p>  &lt;time.h&gt; B10</p>
   <p> открытие 7.5, 8.1, 8.3</p>
   <p> права доступа 8.3</p>
   <p> режим доступа 7.5, 8.5, B1.1</p>
   <p> создание 7.5, 8.1</p>
   <p> суффикс имени .h 1.10</p>
   <p> указатель 7.5, 8.5, B1</p>
   <p>фигурные скобки 1.1, 1.2, 3.1, 4.7</p>
   <p> расположение 1.2</p>
   <p>формальный параметр</p>
   <p> см. параметр </p>
   <p>форматный </p>
   <p> ввод см. scanf </p>
   <p> вывод см. printf </p>
   <p>функции проверки символов 7.8.2, B2</p>
   <p>функция </p>
   <p> аргумент 1.7, A7.3.2</p>
   <p> аргумента преобразование см. <emphasis>повышение типа аргумента</emphasis> </p>
   <p> в новом стиле A7.3.2</p>
   <p> в старом стиле 1.7, 1.10, 4.2, A7.3.2 </p>
   <p> вызов </p>
   <p>  семантика A7.3.2</p>
   <p>  синтаксис A7.3.2</p>
   <p> длина имени 2.1, A2.3</p>
   <p> именующее выражение A7.3.2</p>
   <p> неявное объявление 1.7, 4.2, A7.3.2</p>
   <p> объявление A8.6.3 </p>
   <p> определение 1.7, 4.1, A10.1 </p>
   <p> преобразование имени A7.3.2</p>
   <p> прототип 1.7, 1.9, 2.7, 4.2, 5.11, A7.3.2 </p>
   <p> пустая 4.1</p>
   <p> тип по умолчанию 1.9, A7.3.2</p>
   <p> указатель на 5.11, 6.7, A7.3.2</p>
   <p> addpoint 6.2</p>
   <p> addtree 6.5</p>
   <p> afree 5.4</p>
   <p> alloc 5.4</p>
   <p> atof 4.2</p>
   <p> atoi 2.7, 3.5, 4.2</p>
   <p> binsearch 6.3, 6.4</p>
   <p> bitcount 2.10</p>
   <p> canonrect 6.2</p>
   <p> cat 7.5</p>
   <p> closedir 8.6</p>
   <p> copy 1.9, 1.10</p>
   <p> day_of_year 5.7</p>
   <p> dcl 5.12</p>
   <p> dirdcl 5.12</p>
   <p> dirwalk 8.6</p>
   <p> echo 5.10</p>
   <p> error 8.3</p>
   <p> fgets 7.7</p>
   <p> _fillbuf 8.5</p>
   <p> fopen 8.5</p>
   <p> fputs 7.7</p>
   <p> free 8.7</p>
   <p> fsize 8.6</p>
   <p> getbits 2.9</p>
   <p> getch 4.3</p>
   <p> getint 5.2</p>
   <p> getline 1.9, 1.10, 4.1</p>
   <p> getop 4.3</p>
   <p> gettoken 5.12</p>
   <p> getword 6.3</p>
   <p> hash 6.6</p>
   <p> install 6.6</p>
   <p> itoa 3.6</p>
   <p> lookup 6.6</p>
   <p> lower 2.7</p>
   <p> main 1.1</p>
   <p> makepoint 6.2</p>
   <p> malloc 8.7 </p>
   <p> month_day 5.7</p>
   <p> month_name 5.8</p>
   <p> morecore 8.7</p>
   <p> numcmp 5.11</p>
   <p> opendir 8.6</p>
   <p> pop 4.3</p>
   <p> power 1.7, 1.8</p>
   <p> printd 4.10</p>
   <p> ptinrect 6.2</p>
   <p> push 4.3</p>
   <p> qsort 4.10, 5.6, A7.3.2</p>
   <p> rand 2.7</p>
   <p> readdir 8.6</p>
   <p> readlines 5.6</p>
   <p> reverse 3.5</p>
   <p> shellsort 3.5</p>
   <p> squeeze 2.8</p>
   <p> srand 2.7</p>
   <p> strcat 2.8</p>
   <p> strcmp 5.5</p>
   <p> strcpy 5.5</p>
   <p> strdup 6.5</p>
   <p> strindex 4.1</p>
   <p> strlen 2.3, 5.3, 5.4</p>
   <p> swap 4.10, 5.2, 5.6, 5.11</p>
   <p> talloc 6.5, 6.7</p>
   <p> treeprint 6.5</p>
   <p> trim 3.7</p>
   <p> undcl 5.12</p>
   <p> ungetch 4.3</p>
   <p> writelines 5.5</p>
   <subtitle>Х</subtitle>
   <p>Xoap Ч.A.P. 4.10</p>
   <subtitle>Ц</subtitle>
   <p>целая константа 2.3, A2.5.1 </p>
   <p>целочисленное повышение 2.7, A6.1 </p>
   <p>целочисленные типы A4.2 </p>
   <p>цикл см. while, for, do </p>
   <p>циклические инструкции A9.5</p>
   <subtitle>Ч</subtitle>
   <p>числа</p>
   <p> размер 1.2, 1.5.2, 2.2, B11</p>
   <p> сортировка 5.11 </p>
   <p>численное значение </p>
   <p> выражения отношения 2.6, 2.7 </p>
   <p> логического выражения 2.7</p>
   <subtitle>Ш</subtitle>
   <p>Шелл Д.Л. 3.5</p>
   <p>шестнадцатеричная константа 0х 2.3, A2.5.1</p>
   <subtitle>Э</subtitle>
   <p>эквивалентность типов A8.10</p>
   <p>экспоненциальная функция 1.7, B4</p>
   <p>элемент структуры, имя 4.3, A8.3</p>
   <p>эскейп-последовательность 1.1, 1.5.3, 2.3, A2.5.2</p>
   <p> шестнадцатеричная \x 2.3, A2.5.2</p>
   <p>эффективность 2.10, 4.7, 4.10, 6.5, 8.7</p>
   <subtitle>A</subtitle>
   <p>\a 2.3, A2.5.2</p>
   <p>American National Standards Institute (ANSI) Предисловие, A</p>
   <p>a.out 1.1, 4.1</p>
   <p>argc 5.10</p>
   <p>argv 5.10</p>
   <p>ASCII 1.5.3, 2.3, 2.7, A12.1, B2 </p>
   <p>asm A2.4 </p>
   <p>auto A8.1 </p>
   <subtitle>B</subtitle>
   <p>\b (забой) 1.1, 2.3, A2.5.2</p>
   <p>break 3.4, 3.7, A9.6</p>
   <p>BUFSIZ B1.1</p>
   <subtitle>C</subtitle>
   <p>case-метка 3.4, A9.1</p>
   <p>cc 1.1, 4.1</p>
   <p>char 1.5.1, 2.2, 2.2, A4.2, A8.2 </p>
   <p>CLOCKS_PER_SEC B10</p>
   <p>clock_t B10 </p>
   <p>const 2.4, A8.2</p>
   <p>continue 3.7, A9.6</p>
   <subtitle>D</subtitle>
   <p>default 3.4, A9.4</p>
   <p>#define 1.4, 4.11.2, A12.3 </p>
   <p> вместо enum 2.3, 5.12</p>
   <p> в несколько строк 4.11.2</p>
   <p> с аргументами 4.11.2</p>
   <p>defined 4.11, A12.5</p>
   <p>DIR-структура 8.6</p>
   <p>Dirent-структура 8.6</p>
   <p>div_t B5</p>
   <p>do-инструкция 3.6, A9.5</p>
   <p>double </p>
   <p> константа 2.3, A2.5.3</p>
   <p> тип 1.2, 1.5.2, 2, 2.2, A4.2, A8.2</p>
   <subtitle>E</subtitle>
   <p>E (спецификатор порядка) 2.3, A2.5.3 </p>
   <p>EBCDIC 2.7 </p>
   <p>EDOM B4</p>
   <p>#elif 4.11.3</p>
   <p>else см. if-else-инструкция </p>
   <p>#else 4.11.3 </p>
   <p>else-if 1.6, 3.3</p>
   <p>#endif 4.11.3</p>
   <p>enum</p>
   <p> а не #define 2.3, 6.9</p>
   <p> спецификатор 2.3, A8.4</p>
   <p>EOF 1.5.1, 7.1, B1.1</p>
   <p>ERANGE B4</p>
   <p>errno B1.7, B4</p>
   <p>#error A12.7</p>
   <p>EXIT_FAILURE, EXIT_SUCCESS B5</p>
   <p>extern 1.10, 4.4, A8.1</p>
   <subtitle>F</subtitle>
   <p>\f символ новой страницы 2.3, A2.5.2</p>
   <p>__FILE__ (имя для препроцессора) B6 </p>
   <p>FILE 7.5</p>
   <p>FILENAME_MAX B1.1 </p>
   <p>float </p>
   <p> константа 2.3, A2.5.3</p>
   <p> тип 1.5.2, 2.2, A4.2, A8.2</p>
   <p>FOPEN_MAX B1.1</p>
   <p>for( ; ; ) бесконечный цикл 3.5, 4.11.2 </p>
   <p>for вместо while 1.3, 3.5</p>
   <p>for-инструкция 1.3, 1.5.2, 3.5, A9.5</p>
   <p>fortran A2.4</p>
   <p>fpos_t B1.6</p>
   <subtitle>G</subtitle>
   <p>getchar </p>
   <p> без буферизации 8.2</p>
   <p> с буферизацией 8.2</p>
   <p>goto-инструкция 3.8, A9.6</p>
   <subtitle>H</subtitle>
   <p>.h (суффикс имени файла) 1.10</p>
   <p>hash-таблица 6.6</p>
   <p>HUGE_VAL B4</p>
   <subtitle>I</subtitle>
   <p>#if 4.11.3, 6.3, A12.5</p>
   <p>#ifdef 4.11.3, A12.5</p>
   <p>if-else</p>
   <p> инструкция 1.5.2, 1.5.4, 3.1, A9.4</p>
   <p> неоднозначность 3.2, A9.4, A13</p>
   <p>#ifndef 4.11.3, A12.5</p>
   <p>#include 1.10, 4.11.1, 7.1, A12.4</p>
   <p>inode 8.6</p>
   <p>int, тип 1.2, 2.2, A8.2 </p>
   <p>_IOFBF, _IOLBF, _IONBF B1.1</p>
   <p>ISO A12.1</p>
   <subtitle>L</subtitle>
   <p>%ld преобразование 1.5.2 </p>
   <p>ldiv_t B5</p>
   <p>#line A12.6</p>
   <p>__LINE__ (имя для препроцессора) B6 </p>
   <p>long</p>
   <p> константа 2.3, A2.5.1 </p>
   <p> тип 1.2, 1.5.2, 2.2, A4.2, A8.2</p>
   <p>long double </p>
   <p> константа 2.3, A2.5.3</p>
   <p> тип 2.2, A4.2 </p>
   <p>LONG_MAX, LONG_MIN B5 </p>
   <p>ls 8.6</p>
   <p>lvalue A5</p>
   <subtitle>M</subtitle>
   <p>main, возврат из 1.7, 7.6</p>
   <subtitle>N</subtitle>
   <p>\n символ новая строка 1.1, 1.5, 1.5.3, 2.3, 2.3, A2.5.2, B1</p>
   <p>NULL 5.4</p>
   <p>null-символ, \0 1.9, 2.3, A2.5.2</p>
   <p>null-указатель 5.4, A6.6</p>
   <subtitle>O</subtitle>
   <p>O_RDONLY, O_RDWR, O_WRONLY 8.3</p>
   <subtitle>P</subtitle>
   <p>#pragma A12.8</p>
   <p>ptrdiff_t 5.4, 6.7</p>
   <subtitle>R</subtitle>
   <p>\r символ возврат каретки 2.3, A2.5.2</p>
   <p>RAND_MAX B5</p>
   <p>register 4.7, A8.1</p>
   <p>return </p>
   <p> из main 1.7, 7.6</p>
   <p> преобразование типа в 4.2, A9.6</p>
   <p>return-инструкция 1.7, 1.9, 4.1, 4.2, A9.6</p>
   <subtitle>S</subtitle>
   <p>scanf, подавление присваивания в 7.4, B1.3</p>
   <p>SEEK_CUR, SEEK_END, SEEK_SET B1.6</p>
   <p>short 1.2, 2.2, A4.2, A8.2 </p>
   <p>SIG_DFL, SIG_ERR, SIG_IGN B9</p>
   <p>signed 2.2, A8.2</p>
   <p>size_t 5.4, 6.3, 6.7, A7.4.8, B1.1</p>
   <p>static</p>
   <p> объявление функции 4.6</p>
   <p> спецификатор класса памяти 4.6, A8</p>
   <p> статические переменные </p>
   <p>  внешние 4.6</p>
   <p>  внутренние 4.6</p>
   <p>stderr 7.5, 7.6, B1</p>
   <p>stdin 7.5, B1</p>
   <p>&lt;stdio.h&gt; 8.5</p>
   <p>stdout 7.5, B1</p>
   <p>struct, спецификатор A8.3</p>
   <p>switch-инструкция 3.4, 4.3, A9.4</p>
   <subtitle>T</subtitle>
   <p>\t символ табуляция 2.3, A2.5.2</p>
   <p>time_t B10</p>
   <p>TMP_MAX B1.1</p>
   <p>typedef-объявление 6.7, A8.1, A8.9</p>
   <subtitle>U</subtitle>
   <p>ULONG_MAX B11</p>
   <p>#undef 4.11.2, 8.2, A12.3 </p>
   <p>union</p>
   <p> выравнивание с помощью 8.7</p>
   <p> объявление 6.8, A8.3</p>
   <p> спецификатор A8.3</p>
   <p>UNIX, файловая система 8.1, 8.6 </p>
   <p>unsigned </p>
   <p> константа 2.3, A2.5</p>
   <p> тип 2.2, 2.10, A4.2, A8.2</p>
   <p>unsigned char (тип) 2.2, 8.2</p>
   <p>unsigned long (константа) 2.3, A2.5.1</p>
   <subtitle>V</subtitle>
   <p>\v символ вертикальная табуляция 2.3, A2.5.2</p>
   <p>va_list, va_start, va_arg, va_end 7.3, 8.3, B1.2, B7</p>
   <p>void</p>
   <p> список аргументов 1.10, 4.2, A8.6.3, A10.1</p>
   <p> тип 1.9, A4.2, A6.7, A8.2</p>
   <p> указатель 5, 5.4, 5.11, A6.8</p>
   <p>volatile A4.4, A8.2</p>
   <subtitle>W</subtitle>
   <p>wchar_t A2.5.2</p>
   <p>while </p>
   <p> инструкция 1.2, 3.5, A9.5</p>
   <p> против for 1.3, 3.5</p>
   <subtitle>X</subtitle>
   <p>\х шестнадцатеричная эскейп-последовательность 2.3, A2.5.2</p>
  </section>
 </body>
 <binary id="pic_1.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAA5QAAADECAMAAADXjp4QAAADAFBMVEUAAAD///8AAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABn
duxjAAAACXBIWXMAAAsSAAALEgHS3X78AAAKwElEQVR42u2dCZLjIAxF8f0vPTUdJ7HjBbAE
Eui9qerqJCzafgA7mU4LALgiWRsAAHsQJYAzECWAMxAlgDMQJYAzECWAMxAlgDMQJYAzECWA
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</binary>
 <binary id="pic_3.jpg" content-type="image/jpeg">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
/9b2ZERERERERERERERERERERERERERf/9f2ZERERERERERf/9k=</binary>
 <binary id="pic_4.jpg" content-type="image/jpeg">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
I8YScc8/sK+hNqHAzb7aD7uk+iUW60+oLpaK23mktsXhdPJD0grJDs3NIzjoucZUphvsMLIm
Ulvk2NDdzqt7ScDr+xlZukvHRE+DUQkxwPCHkZx37O//AF2L6ebqQOjZSNPOdz3O7OOwdqhu
ory26S10UlC0ywRxFrw92NrnnPZ+H8nnWfbfdhxJbw7IwOjfjHb2r//T6m1t/wBw3S24Nzzi
OTOP4yVdHc6yjnpnVlIxs0b4yRTOJbkYz7PlS7fSeAW2mo9+/wAHhZFvxjdtAGce8pCIiIiL
HNPDTs6SeVkTM43PcGj5V9hwcAQQQeQR2rGKiAzmnE0ZmaMmMOG4D0LKiIiIiIiIiIi8IyvU
REREX//U7MiIiIiIiIir75Wvt1mqaqN7WSMaAwmMv8okAANHJJJwB2nC0yqqnakhs9PeYmFs
OpHQObNE1u8Nglc0OblwycgYyvrVrG+N7nU9I6OotFBTS2wDgRvdI8P2gde7axhHccK3usMU
H1R9PzxQsZJU09Y2aRrQHSANiwHHGTjHC2pERERERERERERERf/V7MiIiIiIiIiIiLDVUsFb
TPpqqFk0Mgw9jxkEKoqtH2qakgp6Vj7cKesFbG6k2tPTBpbuOQQcgnOQrGotNBWVFLU1dJDU
1FIcwzSxguYeOQccHIB4WCSxwzaggvMtTUvlp43MhgLx0Ue4AOIAGcnHaSrNEREREREREREX
/9bsyIiIiIiIiIiIiIiIiIiIiIiIiIi//9fsyIiIiIiIiIiIiL//2Q==</binary>
 <binary id="pic_5.jpg" content-type="image/jpeg">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</binary>
 <binary id="pic_6.jpg" content-type="image/jpeg">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
2Q==</binary>
 <binary id="pic_7.jpg" content-type="image/jpeg">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
UpSlKUpSlK//1fs1KUpSlKUpSlKUpSlKUpSlKUpSlKUqlu0ftt8t0VyRKaZLL7ikx5C2dZBb
AyUEEjzjUiuHISsfpNzTgg7XSTv6Ph1t7noX7e5fekn8ysHh2Ef9Pch/6pJ/MrPuehft7l96
SfzKe56F+3uX3pJ/Mr//1vqXuehft7l96SfzK2FhhhRUHrhk+NykEf36x5Ahftrj0x/nOR7d
bqskRTeguzsH/f389MdddGrJCYTpQZX0y3VHpjqVeAqFHDNqbTpS0+Rknzpbqj6yqpV2G3rO
VIfJ36yXfarQcO2wf6F37S57VYPDtqBALboJ6DtTm/8AzVn3OWv9k99pd9qsHhu1Egll3bp+
ku+1T3NWoKKuQ7qIwT2lzJH9b0mtbE0mPIu0ZtSy0zNCW0rWpekFhpRAJJOMqJ+mrelKUpSl
KUqGW/2aG/IygcptS8rVpTsM7nuFeEmca32LaVBpEORcFyWW2lGM622pLiFq2SVajgoICu/b
aueFx5f7jCYZYjMGcoOPKcYiuPNKQG2nEoCQoKGeclJUTtjpvtc+6S8KuUJyQ01AgOMRluB2
OpeVuHCkFxKsNkZGMjCieorZnieczLnG5SIUVCUyTGadbWhKg0cpUHQSFjSCVAAFPhsa54HF
dzmPSLWXGUS0TWYyJTsVTSdK2i6SWyrOfNUkbjOUmuNXG1+MOMlqKh6UI0h53kRVOIcUh1Ta
R8MaEnTkk57q9u0qa7KZe96REVHytopPMDhII36YA1A7dcVzSv1nt3/CyP7zVWlVPE9wl2uw
vSoPKEnmNNNl1JUkFbiUZIBGcas1TtXu8yp7dpalxGpCZUlpyStgkKS2lCgEo1dffBnf+Sa8
1L/hXuUTS0u0hbkmM28w4hKilOtpITkd4L2pI36V9SUCUkJODjY4zivJPXK7wuGZBjuRVz03
FbAXsnWC6c6ErXgr0k4TqAzsPCrXhe6uXa1KdeeDrzL62XPeS0pBSfgrSeigCM4JHhX/1/o0
rymeOYbbU3lwzAdWWi3kKIcaB7+uD17t/GvOtcQXOxszZRcMxlcy6cuOU7o5RWtOD1O6SMdM
EeG9zwlfLtdJsli4sBDaIzD7ZXy0uZXqzlKFq83bzScHxzXXxGJnlGxCNcjCbXOKHQEBXN96
cIB36ebjHpB7qikOy2P4QYDalocjyID+nLYCmylTeQFd4OQd/CvHWnjziGRbJV1ddZeQiIt1
EYMgaVcvWCVZGw3+iriPJvl6ts1x9p1ufaHmpcNC1Nc1w6MlCuWSAFgqSOmyvRmubia5R7s6
uYVqTEPDT06EVjGh4lJCge5aRp6bjJ6V7q1OSHrRCdlpKZC47anQRjCykZ2+fNddVdp/zle/
+OT/APHZq0pSlKUpSlKjeZbkMOMPIC23ElC0nooEYIqnh8HWGC5zGYJUvLatTzy3TlAIQfOJ
+CFEDwBrLvB9gdjIjdgDbaFhaQ04tsjzEoxlJBwUoSCOhwKnd4ctL0tiSuIAuOEBCUrUlGEf
AygHSrT3ZBx3VGjhSxtyH3hAQeelaFtqUpTYC/h6UE6U6u/AGe+uN7gm1t2uVEtjSIrkktKW
69qf1Fs5Tq1Kye8ZBB9O1ZgcD2eNZbfbZTXa+whQQ6SWydStShhJHmk/yTkbDrV72SP2xMzl
J56Wy0F9+gkHHrAqtnqSniq0AjJUxJA36H3s/wDSritHWWn0aHm0uJyFaVDIyDkH6CAa4p1i
tVzbLcyCy6C5zN04OrGCcjfJAwfEbVu5ZrW6cuW+MohLaRlodGzqQPmSSSPCuxSQpJSoZBGC
KrW+G7K1EfiItrAYkq1uo05ClddXz53z1zXXDgxbexyIcdDDeoqKUDGSepPifTWX4UWU8y8+
whbkdWppZG6D34P0D1CsCBDSQUxGAQpaxhsfCV8I/OcnJ781/9D63BtcC2BwQYbMYOEFfLQB
qx09Xd4VLJiRpjYblR2n0JUFBLqAoBQ6HB76hXaLY7OROct0RctGNEhTCS4nHTCsZFbNWy3x
06WYMZtONOENJAxjGNh4bVmFb4VuaLUGIxFbJyUMthAJ+YVyR+HbWwxyFxG5DaZDkhpMhCVh
lS1FR0ZHmjJOPCrSlUVjJPEPEgJOBMawP/LNVe0pSlKUpSlKUpSlKVxzrcmatlztDzDjBUUL
ZIB3GCNwR3/uFc/kd/5cuXra9inkd/5cuXra9inkd/5cuXra9inkd/5cuXra9inkZ/b+O7lk
d+pv2KmatrjacKuU1056rUn/AKJFaSbR2lGk3Ge34Fp/SR6hWU2lCdP6bOOjpmQr9/j9NaGx
tFevt1xyTn/LF49Wax5CZxjt1x+2ufjTyCz8euX21z8a/9H6l5BZ+PXL7a5+NPILPx65fbXP
xrA4fYSpRE+55UcnM90+rfasHh5grCjPumQMbT3cerVRfDsdaSkz7oAfCe6D6wqoDwjDOP4x
vW3/AGtI9uu+1WiLZ2nURlPrL7nMccfeU6tatITupRJOyQPorupSlKUpSlK//9k=</binary>
 <binary id="pic_8.jpg" content-type="image/jpeg">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
pSlKUpSlKUpSlKUpSlKUr//W+zUpSlKUpSlf/9k=</binary>
 <binary id="pic_9.jpg" content-type="image/jpeg">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
K//Z</binary>
 <binary id="pic_10.jpg" content-type="image/jpeg">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
/9k=</binary>
 <binary id="pic_11.jpg" content-type="image/jpeg">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</binary>
 <binary id="pic_12.jpg" content-type="image/jpeg">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
L0z8vYu6IiIiIiIiIiIiIiIiIiIi/9H2ZERf/9k=</binary>
 <binary id="fig6_1.jpg" content-type="image/jpeg">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
PByFmiIiIiIiIiIiIiIi/9k=</binary>
 <binary id="fig6_2.jpg" content-type="image/jpeg">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</binary>
 <binary id="fig6_3.jpg" content-type="image/jpeg">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
/9k=</binary>
 <binary id="fig6_4.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAYABgAAD//gAcU29mdHdhcmU6IE1pY3Jvc29mdCBPZmZpY2X/2wBD
AAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+
JS5ESUM8SDc9Pjv/wAALCABsANYBAREA/8QAGwABAAIDAQEAAAAAAAAAAAAAAAQFAQMGBwL/
xABOEAABAwMCAwELBgcNCQAAAAABAgMEAAURBhITITFBFBYiMlFVYXGUstEVNTZydNMHI3WB
k5WhJDNCU1RWYnOCkbPB0jQ3Q0RSZZKjsf/dAAQAKP/aAAgBAQAAPwD2N55qO0p55xDTaBlS
1qACR6Sag98Nk88QPaUfGnfDZPPED2lHxp3w2TzxA9pR8asKzSlK+HHG2WluurShtCSpS1HA
SB1JPYKp+/TSv85bT7c38ayNZ6VPTUtp9tb+NTIF7tN1WpFuucOYpCQpQjvpcIHTJwelTqUq
FMvNrt7wYm3KJGdUncEPPJQop6ZwT0rR3z2Dz5b/AGpHxrHfTp4Ak3y3gDqTKQP86s0LS4hK
0KCkqGUqByCPLX1SlKUpVXqJkSLUllTYdSuXFC0KTkKTx285Hkxmt3yLafNkP9An4VH7l073
YqH3PbO6UIC1M7G96UnoSOuKh6httmTpu6KRCghYhulJS0jIOw9OVXjb7JbSQ8gggYO4V9cd
r+NR/wCQrCZMdedr7atpwcLBwfJQyGAQkvNgnoNw51oVdrahC1quEYJR4x4yeX7a5mZrXTmp
NJXZNrurLryre+Qwo7HOTas+CcGumt7LRtsU8JAyyj+D6BUVm/aefdfaauUAuR3C26kuJBQo
HBBB9VQ/le0p1SjFxhgGCQCHk48cen01/9D1j5atPnOH+nT8a+V3+zNpKl3eCkDGSqSgY/bV
Xdtf6ZssqGxMujWJm7Y60oOIRjHjFOcZzyPrrFuuEK4a0dlQH2JLMi1NnjtKCgdrq8DI+sa3
XhU2XqGBaYtwfgNrivyXHGEIKllCmkpTlSTgZcJPlxit9luDt30hDuD6Uh2TDS44B03FPP8A
bUmxfR+3fZGvcFT6UpSlKqtSuJYsTz6lIQGXGnNy+idriTk+Tp17Kz3z6f8APtt9rb+NVr7u
hZVyXcpMmxvy1thsuuvtLO0dBzPKq/UMnQ6NO3EtPWEOmK4G9imd24pOMY55zXRt6esgbSBZ
oAAA/wCWR8K+u96yeZ4HsyPhTvesnmeB7Mj4U73rJ5ngezI+FO96yeZ4HsyPhXNydC6c01pO
9Lt1ubDyoT6i+4N6x4CuhPTr2YrrLd82Rf6lHuio6rLZX3HHFWuA4sqO9RYQTu6nPLrzqkcs
loGuozPyVC4ZtjqinudGMh1sZxj0mreRZ7BEivSH7VAbZaQVuK7mRgJAyT09FR7SzpO8MCXa
Y1qlNpI8Nhls7T6cDINYuWiNNXd+I7NtEZzuTPCSlG1PPsIGNw5dDyrXEixIWtlR4sZDCEWp
GxDSQlCRxVZ8ED1VMvVuZecZuKrm5bHIqFo7oQUAbF43BW4EdUpI8hA9VSW4ce2WRMKMnZHj
R+GgE9EpTgZr4sJB09bSDkGI1gj6grF7v9t07DbmXWSI7DjqWg4QSAo5xnHqNb7fcoN1iJl2
+W1KYX0caWFD9nQ+iuQnR79I1XKKDKZtsW5xXgQTiRuSygoT/QT+MUrszjyGqS3w9XMXWKqe
/KTa3Fzw2tkLLrO9KyFLHPptGz63Kr/RMO6Rrq8ufCMRD1tjKCA644nfucB3FXReNuQOnLrX
a1//0fZqqtSpCrDISoAglAIPb4aal/Jdv/kEb9Cn4VxltuEh252+XLiW1Ntuk1+G1HEUBbJb
4mxW/PhbuGcjAxkY7a6a9WiC7Yp7aITCVLjOJBS0nIJSenSrCC8ZECO+cZcaSs4GOoBrfSlK
qtU/RK8fYH/8NVTLd82Rf6lHuiquNorTsWXMlptra3prxeeU6SvKj1xnp1PSq13T1m7+4zPy
bG4ZtjyijhjBPFbGcfnNWs3SdhkwX2F26O0l1pSC4hCQUAjGQewioGkdA6c0qEy7U0XpDjQS
Zbjm8rSefLHIA8ugrqaoU/7wF/kpP+KqrC8WeDfrY7bbkzxor2N6NxTnBBHMc+oFRH9L6fRE
cCbFbhtbOP3Ijly9VRrJpqwLsNvUqyW5SjFaJJioJJ2j0Vi86E0xeISIkm1xmG+IFgxm0tKJ
8mQM4P8AlVraLJbLDCEO1QmojA57Wx4x8pPUn0moDutNPMXc2ly4bZoXs4XBcyVchgHbg9R2
1Lj6itEq7O2pic2uY1uCmwD1TjcAcYJGeYByO2su3+0MMLfduDCG0R0yVKKujSuSVeonkPLU
J7W+nWICZzlwKY5WpBX3O4dik43BQ25T1HXHUVawJ8e5xEyoqlqaWSAVtqbJx6FAGoOqnm42
m5b7p2ttBK1HBOAFgnkK0d+un/5Y77K9/prmYUy0RLlCUu/rcgwZciVHji1vBSS4FjapznkJ
DiscgTy8lXtw1lYXbdJaTKfUVsrGERHs+KT1CeXrq7tHzNC+zt+6KmUpSq3UbSn9M3VlHjOQ
nkp9ZQRVbB1pplu2xgu+QkkNJSQXRkEAZqniztKRZ8+WjXEjM57iqb7tSUNnyJBHIfAeSv/S
6qD3BetbsqtmoZctDVud3uNPhW0lxvCScdvM/mro5WnlyIjzAvFySXG1IzxhyyMf9Nc/oP8A
BsdGumQ5fJctxQwWEEtsdO1GTuI8vL1V3NcrcbrBs+u0vXGQI7b1s2trWk7VFLhUoZx1A51o
v2otP6gsj8OHqowHCtIEmIVb0nxsDHM5AOcenyGtb16twjuoGrrqshJGO42zk+vgc6n2KxTO
92Ahy/XZG6M2S2eCCglA5Z4eeXkz2dtQNW6CmaisYtreoJaiX23FLl7FBASCCQEpSSeflq80
tYXtOWdEB+7S7osHPGkqyR6E9SE+gk1LdiOLvsSaNvCZjPtK589y1NEe4a5Wx6bnw7+wmXbN
zMGRIfanqnrUlQcK8BDO7CVYXg5GORxzpb9J3e0aactbBYlL2x5CHH3CVqebUhSmlKxzR4GE
nsHLHKrdUW63fTt3amwY8J+c24lhgLClJy2EjiLHIncCeXQYHPFdDVZqFJXZHwkZOUHp5Fg1
Z1wUG5yuLaLmZ8lb1wvUiI6ytai0GwXQEbCcAp2JwoDJxz6mu0uHzbK/qV//AA18Wj5mhfZ2
/dFTKUpSlKUpSlKUpSlKV//T9mpVZqRfB03cH9hXwY6nQgHBUUjdj8+K0/L0vCD3s3fCiQf9
n8H1ji1UQoTDF1VOb05eeJxlyER3ZEcoacXne4lPG5FWTz9JxirWddJy4EhA07csqaUPHjns
PkdqfafmaF9nb90VMpSlKUpSlKUpSlKUpSlVepjjS91OM/uN3kfqGrSvOoceKi5QrunCbo9q
SVGde35WtsKeSGz5UhKU4HZgGvQX0hUdxJ3YKCPB69OyolheEjT1tfCSkORGlgHsygGp9KUp
Sv/U9mpSlKUpSlKUpSlVWqSU6Tu5CSoiE9yHU+Aaz8q3D+b079Kx95UFLDaLj8op0g+Je4qD
u+PkKIwVD8ZyJHInqRyqaq63AJJGnpxOOQ4zHP8A9lZ0v9E7P2fuFj3BVpSlK1SX0xozshYJ
S0grIHUgDNVkedf5Edp9NqtyQ4gLANxXkZGf4mtbV3usl96NHj2Z19jk62i6KUps/wBIBnIp
Gu11bvsa2XODDa7qZddbcjSVOY4ZQCCFIT14n7KvKUpSlKUpSv/V9mpSqvU/0Wuv2N33DVpV
NNn39u/JiQrKw/ALG8y3ZfDAXnGzASo9OfTtraZGoMcrXbs/lBf3NVum5F9717Vw7ZAKO4md
pVPWCRsGCQGjj+81Zd0X/wA12/8AWC/uad0X/wA12/8AWC/uayl+/EjdbbekZGcT1nlnn/wv
JWxDt3La98KElYJ2AS1kEdhP4sYrioF3/CQ5qm4RHLLFetaHlhLkgltIR2BC8ZUP7J9ddrYn
C7YLc4UlJXFaVtPZlA5Vw+kRES9pERkhUruOWJZSfDByneV9v74Mc+2upn/Tqy/YZvvMVfUp
VU/qayxmluvT20IbjJlLOD4LSjhKjy6E0d1LaGnHGxL4rjbyWS2y2pxRWpG8JASDk7QTy7BU
u3XCNdISJcRSlNKKk+EgpIUlRSoEHmCCCPzVKpSlKUpVRqxRRpC8LGMpgvEbjgeIepr6TJ1C
pAJtdtyRn5xc+5rPdGoPNlt/WLn3NYMjUOOVstufyg59zWdMfRS0Z/kLHuCrSlKVhXin1V//
1vU9NfRa0/YmfcFQEPXZrUlwbjaYipjJSgtzzIS2XyRlQICSeR5c/J6ah3CTeBq6zLNrihzg
SkpHd3Ig8MkeJnPgg8vIauu6755pi+3H7uuT0BqDXt1cCdQ2NDcNQJEtz8QsejZ1P9w9degV
w6PwerTZHoLs1D70mNwH3lpI3ALRtH1QhAT+3tNIf4OG7fGfhxpzwadnNSUyC8oSGtqSFFKh
/COSn6qjXSacs5sNmRb1Pqf2PPOBxRJUQt1SxknqcKwT2mrSlKUpSlUmtfoNfvydI/w1VcM/
vKPqiuHixxJvK7265IRObvi4iTx1bSyMpCNudu3HhdM5513dU2jlJXoyzKStSx3C14Sup8AV
c0pSsK8U+qq3TX0WtP2Jn3BUN7W1hYucq2qkSHJUNQS8hmG87sJGRkoQRVNdNW2lzVNjdSZu
xrujcDbZAVzQAMAoyfzA1dd+dm/7j+q5X3dU2kvwp2jVU425MWVFmbiEoLanEqA7dwHL+0BX
aPKcSytTKEuOBJKEKVtCjjkCcHHrwa5d7Vtzgw7pMuNkYYj2zwXS3O3qUsoQoAAoAx4ackkY
51qjfhGti7fNmSFxktwH2W33I0njtBLmMKCgkZwcgjHUemprmo7qp6NFj2DdLfYekKYelpQW
20KCUZISoFS8jl2dprfIvF2Zu0OEm1RtkxKlJW5NKVI2hJUFJDZ58+wnp1FXlKV//9f2alKV
Av1uXd9P3G2NuJbXMiuMJWoZCSpJGT/fWhtWoUNNoVFtpUlICiJLgBPoGyq5emZCrx8qBi3p
kB3ipJW+Uhe3bu2bgjdg43Yzy9PKzKdQZ5PW0D0tOf6q2WG2GzWGDbC6HjEYQ0XAnG7AxnHZ
VhSlKwRkEVQ21jUdttUSCItse7maQzxO6nEbwkAZxwzjp0yfXUhKr8lSli32tK1+MRKXk+TJ
4XOtPyfdpl9t8+YiGy1CDvgsuqcUsrSB2pTjFXtR4cCHbmOBBisxmslWxlASMnqcCpFV0qxQ
ZkS4xX0rLVxXveAVg52JSCCOnJCT66jRNO7YimblcpNzWt1Dilv7QPB8VO1IAA5c+XPnWt3S
bAjxmYdxnQzFQtplbbgWUtL27m/DCsjwRgnmMcjU5NlhIetzjaFI+TEKbjpB5JSUhOD5eQFW
FKUpSlKUpSlKUr//0PZqUpSlKUpSlKUpWCM49FZr/9k=</binary>
 <binary id="fig8_1.png" content-type="image/png">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</binary>
 <binary id="fig8_2.png" content-type="image/png">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
ntlSAcyvAAAAAElFTkSuQmCC</binary>
 <binary id="fig5_2.jpg" content-type="image/jpeg">/9j/4QDmRXhpZgAASUkqAAgAAAAFABIBAwABAAAAAQAAADEBAgAcAAAASgAAADIBAgAUAAAA
ZgAAABMCAwABAAAAAQAAAGmHBAABAAAAegAAAAAAAABBQ0QgU3lzdGVtcyBEaWdpdGFsIElt
YWdpbmcAMjAwOToxMDowOSAxNDo0Mzo0MwAFAACQBwAEAAAAMDIyMJCSAgAEAAAAOTA2AAKg
BAABAAAArgAAAAOgBAABAAAA9AAAAAWgBAABAAAAvAAAAAAAAAACAAEAAgAEAAAAUjk4AAIA
BwAEAAAAMDEwMAAAAADYAAAA//4AJ0ZpbGUgd3JpdHRlbiBieSBBZG9iZSBQaG90b3Nob3Co
IDUuMgD/wAALCAD0AK4BAREA/9sAQwADAgICAgEDAgICAwMDAwQHBAQEBAQJBgYFBwoJCwsK
CQoKDA0RDgwMEAwKCg8UDxAREhMTEwsOFRYVEhYREhMS/8QAcgABAAEFAQEBAAAAAAAAAAAA
AAcBAgUGCAMECRAAAQIFAwEDBAoLCg0FAAAAAQIDAAQFBhEHCBIhEzFBCRQiURUWGDIzOWFx
dpEXI1ZXhpaxs7XT1DhCUlNVd4GU0fAKGSQ1N1hjdJKVl6HSJjZip7T/2gAIAQEAAD8A/VOK
E4inNI7+nzxRLiFDKTkZI6dYryHqP1Q5D1H6och6j9UOQ9R+qHIeo/VDkPUfqgFA+Bi6EIQh
CEIQhEG726p7EeS01Fmit1AepIkiWnEoVh95tk4USMfCeB5fwcqwI+5Gz7bIGkp+wjaagg9O
UiFHp45J7/li4bP9sqRhOiFpAZJwJADqe/xivuQds33kbT/qA/th7kHbN95G0/6gP7Ye5B2z
feRtP+oD+2HuQds33kbT/qA/th7kHbN95G0/6gP7Ye5B2y/eRtP+oj+2IhurR3TXSXywugT+
m1oSNuGts3LL1BFPK2m5lDVPSpvm3y4khS1EHGevf0EdfDuisIQhCEIQhEJb0pOVnvJfaiMT
gfLaaOXk9ipQVzQ62tGePXjySnPhjOemYmtHvT85i6EIQhCOc9bvjedtv4V/o1uOix3RWEIQ
hCEIQiG94Xa/4srUjsez5GgPZ55xx9Hl3eOM4+XGYmJHcfnMXRQnCYh07tNDTUZuWlrirM6Z
GbfkX3JG1arNMpeZcU26gONyqkKKVpUk4JGQYu91hov/ACjdH4k1r9kjymN3Oh8pIOzc3Wbk
YYYQpx112zKyhDaQMlRJlMAADJJiTbSuygXxpzTLutapsVGj1iUbnpGcYJLb7LieSVjIBwQf
EAxmY5z1u+N522/hX+jW46LHdFYQhCEIQhCIe3ffFmalfR6Y/II2vV29bmsDQifuKzbFmbur
SHGmJOltTKZZDi3HEo5vPKBS0ygErW4QQlKSY0HRHcbUdYNut5V2Stekzl1WTUZyjzNLoNeR
UJKemmmUutJl5vilKkuhaE5UBxVyBHoxKlj1yv3JpBRq5dNqvW1V5+TamJ6kPTKZhcg8oAqZ
LifRUUnpkdDEe7TxnZhKZJ/z9X/3x/lmdiYOA+X/AIjGJusFOm9VKVKBEi/3KP8AFqiKtlZA
8ktpD359p1O/MiJepVbpNbk1zNIqUpOsturYW5LPpdSlxCilaCUkjklQII7wRgxAOt3xvO23
8K/0a3HRgMVhCEIQhCEIh7d98WZqT9Hpj8gizdLojVNettbFpUWvSlNnqdW5OuMNVCXU/T6g
qWWViUnG0kKVLuZwoDPcDg4xGq7fNANSdHLZ1QRNVyxZaevWqezFHTb1CclJClPGTSwEGWKs
FpCm2yADleFFRyvCZusuRuamaW0qn3lWZWr1yWlGmqjPysp5qzNPpAC3EtZPAKPXjnpmI92n
nGzGU6H/AD9X/wBMzsTByEYm7DnTWrYBP+Qv+H+zVHCtN2r3Vuc8i1o2zaeu132O/I2LKMIp
ss4tFKn19kRmYbTxcOT6PLKhx6hJzk53Zjsz3BaI7X3rauDcDWrVnPZibfFIoctT6jTVNq4p
S8FTEspfJfAqxkYBTlIOY+PVu1d0dqeUa0IlpXVqzb5r7ntk9h37gtpdKaaPmSC925k3FdoO
yKQjihBCkknIPSaaPqru1tmTVL6kbY6bcKpeXVMPVGxbsl3G3T3htuVneyc5gZz6ZBIGM5wM
zbO8TRCvastaf1qt1Ky7qfbbcZot40p+iTLxWMhLfbpShxXhhCj8mYm1K0qSCD390VyIrCEI
QhCIe3ffFmak/R6Y/IIl9PcfnMVxAgEYjnGc2N2Avz5NC1W1gtxuer8zcZZot7TEqwzMvrUt
YbaALaU81FQ9HOT1Jj5FbF6OulPSK9zO4cy8y8Zl5v7IDnpuEg889lkHIB6EDPhHi5sLtt6S
al3tyG4RxthtxppKr/cPBLgIcHwfXkCQc574nvTmwaBpdobQdPLWEwKRblOZpkkJh3tHOyaS
Ep5KwMqwOpxGyY/vmOc9b/jettv4V/o1uOjMDEY+s29Q7ipapCu0eRqMstCm1MTcsh9tSVDC
gUqBGCOhHjEITO2WoadsVqrbbdR6tY89P/b5egTyzUrYS9y5K/yNY5MBz3pLDiOOchJxiPOj
blLg09nabb26iyG7CnZ0pl2rokprzy1px/jkjzrAVKFRCilEylIwOi1RP0rNS05TmpuUfbeY
eQHG3G1hSFpIyCCOhBHiI9YrCEIQiHt33xZmpP0emPyCJfT3H5zF0UhyAGScRTknHf3wKk4x
nH9MeKJRhNSM4Bl0oDfLP73Ocervj6I5z1u+N522/hX+jW46LHdFYpHy1KmSNXokxTKlKszU
pNtKYmGH2w4282oYUhaT0UkgkEHoQesc51bRvUnbxNJuDbEoVaz2lvTVV0yqM0eyd5ZUVUmZ
Xy80WCekuftCsAANkkmWdIdarE1qsJ2tWbPTCX5Jzzep0qoS6pSpUt/rlmZllgLaX0OMjCgM
pJHWN9isIQhEPbvvizNSfo9MfkEbVqzqpQ9H9LWLrr8nNzMtMViQoyUS3AKDs5NNy7aiVEAI
SpwKUc9wOMmNlolwUS47abrVArEjUqe9y7Kbk5lD7LnFRSritJKThSSD16EEeEfY2+zMyKH5
d5DrTgCkrQoKSoHxBHfHMGhWjUtqLok/fFxao6q+yVTuGuFxMpfdQlpdtKKrNNoQ2yhwIQkJ
bSAAI38bXbXEw479k7V/m8OKz9kaqdRgDu7bA7h3Rjp7bLbFtabzYo2pWrcs3JSrrjDY1Eqa
koISpQ986c9fXGa2l1+uXV5NDTC5rnq03U6tVLWkZudnJt0uPTDq2gVLWo9SSeuYlzI8DHOm
t3xvO238K/0a3HRY7orCEUIyIhnVjQufrGrUrrJpJXJe2NTKfLokjPTTanZCtSSV8zIz7QOV
NE+9dRhxo4KSRlJz+ius0jq3Zs8Jy3521rpoMz5jcNs1NxJnaU/jkjlx9804jDjTo6OIIIwQ
QJHisIQiHt33xZmpP0emPyCNF8oabXT5ORxd7paNuIuy31VjtkqU35n7KMdtzCfS49nyzjr6
usaRtFlrFRu614m9HvMxoY83SjS/YskUcz3mZM/5tgYyE8Avh0BIHfHTuj/2Ovcw2v8AYk7D
2mexcv7A9h2nZ+Z8R2XHtPTxx/hdfXGibPZhD+zx1tM+JksXbcjJQG+Pm5FZnPtX/wAuOffe
OYnCMPdv+jSrf7i/+bVHAFC153IaMeRf0pXt/wBuM7eNPFiy0zM3C7NKmESL+T2g8xSe3cSO
qs5COKhx9FJEbNtU3h7qNQNnFHuyvbX67fZdnn5eauGkVunSXnKRMPBRTJuFCkqbwlvjkA8c
5Hj76l691mb8qHoNVr20E1OtNyke2NSJZ2lN1R2eS9T0IHYCSceK1JKSVpIBSnCj0MT7Sd5+
2Oq6gOWovV+jUist8eUhX0P0Z/0gSkBM221kkDuHyesRMspPSc/TkTclNNTDDmeLrTgWhXXH
RQ6d8e+R64QgR0iCdf8ASe6hc8lrtol2MtqPbDXF2TP2tq6qcgla6VMKH8LqWnCCW3MYwFEi
RdJdUbX1k0ApGotnvOrplXZK0IfQW3mHEqKHWXUH3rjbiVoUPApPhiNxisIRD2774szUn6PT
H5BEszMnLT0iuWm2G3mVnCm3EBSVdfEHoY+emUGk0ahJpdIpsrJSaStSZeWYQ00CtRUohKQB
kqUonp1JJPfH0S8oxJyaJeVaQ002AlDaEhKUgeAA6COObHn972jNIrFjWrtmtu66O3cdXqFP
qr1+syqn2JqeemEfalIJQAHQMH1Rsf2Zd/v+pnan/UiX/Vx41LVLftVLZekF7QbPbE625LKJ
1HZJaCk45H7X1HpHoCT6J7umZh20abVfSLYZYmmdwFg1O3KHLyE6qXmFvtF9I+2FC1dSnkTj
oMDAAAAAkmXk5aVbUhhhttKlFZCEBIKick9PEkk5jnnW5IHledtuBj/3X+jW4m257Bsu96YJ
K9LSotflkqCgzVae1NoBGcEBxKh0yfriHLu2oaKUl1mfsSuVfR6qzk6ESc1Z1bVSWXppfUJM
mSZV5SsEcS0SoZA7unzzrW8jTKryKKI7aWsVttLPnXnwFBuPsvRACXEnzN5zqo5KWQeODjlk
bNa26zSe4NaEaZVqaqlm3o62HGqBdUgumzD/AEJUGHFZZmCMHJZcWOmQSIlqWl326lMPOTy3
W3OPZsqQkBrA64IGTk9euceEfXFFAFJBjnCpoO3fyg0rWpZya9outlURT56X6lmkXH2f2h5t
KR6KJxCFIcOPhW21E+kY6OSQUZ9cXQhEPbvvizNSfo9MfkES+nuPzmLoRTEVimP75hiKxznr
d8bztt/Cv9Gtx0WO6PN5ht9Se0QlXBQUnkkHBHcR8vyx6Y6Rr94WBZuoNlTVuXxbNMrtMnWl
MPylQlUPtrQcEjCh06gHpg5APeIhJ/RzWvQyQZf27Xuq6bbln1OO2Hes8p5KWSclqn1IgvMF
ISlKG3u1b6nJEb7pNr/aWqlWqFtGn1O17woquFVtWvNJlqnK9AQ4Gwoh1hWQUvNlSFDxHdEo
AxomuGm8vq7tUufTh94S667TXZaWmckGVmccmHwR1BbdS2sEdQU9IxG2m/K7qLs2t2vXeOzu
mWYVSrkYKAhTFUlVql5tCkgnB7VtSvlCknuIiU4QiG94TiWvJiamvOHCGramnVnBPFKUgqP9
ABP9EeCN6G09Un26NxenZRgr63CwFAZA6pznvI6Y/IcZqW3Q7b5t1KGNfdOVKWyiYSPbTJjL
as8VdXO44PyxSp7pNt1HpC5+o6+adtMIICle2eUX3nA6JcJ/7RWS3QbcahLIelde9OnEONJe
SRdMoMpVnBwXAfA9O/pH0+6Q29/f207/ABpkv1sWObltvLbraFa76d5dVwT/AOqpPqcE/wAZ
6gYv90ht7+/tp3+NUl+th7o/b54a66d/jTJfrYhS/wDU3TnUDywm3eXsW/7buN2RRdLk0ikV
ZicLCVU5ASV9mpXEEpVjOM8T6o6yHdFYQihGREeataF2FrJRqcLqkn2qrQpoT9ErUg+qWqFK
mAOjjDyCFAetBJSrA5AxHdh603ppnqvTtGtzb0mK3VFFm3b3lJYSdGuRfemXUknErPYz9pJ4
r45bJyEx0LkKbPXvjnTReRZ048qDrNp4mbS1JXein6i0mR58jyfC5WoOAnr1mGGyR3DmnHfg
dGjqIrCPJ9huYYU06kLQsFKkqGQoHvBHiIxntRtjln2u0vPr8ya/8Y8zZNoqGFWvRyCc9ae1
3+v3searCstbra1WlRCppYWgmms5SoeI9Hoflj0VZNorOV2vRySc9ae0ev8AwxT2jWd9ylG/
5c1/4x5u2BZLxR2toUNfZrC08qaycKHcR6PQ/LHp7RrO+5Sjf8ua/wDGLXLCst1hTTtpURaF
gpUlVNZIIPeCOMfRT7TtukvIcpVApsktscUKl5NtopGMYBSBjp0jLAYEVhCEI1fUfTi0NV9I
Z+x74pDdRpNRSA42olK0KSeSHG1j0kOIUApK0kFKgCDERaPahX3YW4ib27621d6r1FaXJ6y7
tm0JZVc8mMrcYcSkBHnkskgLCMBSOK+I658NSa2/avlmNHFq7NMrd9s3Fbyj2iUqU615rON5
BGVD7UoAA5yv589FJ970i6EIRQkD1wBBinIZ8YrkQyM46wyM+MAYrCEIQhCIv3B6Qtau6Euy
FLfRTbsoy/ZW1K2lI7WlVNocmHkqx0SVAIWO5SFKB745/rurdP1a1q2uVGqUpmnXk3fFUla5
SG0l1dHnJSlzLU9LKXjoEOrZ8cLSUKGRgx2a38CPmi+EIRyj5SaSqJ8noKxblfnqLcEpcNLl
abNy1fdpKQZmbbZcQ46haR2ZQo55ZCcc+nHMad5OK472m9UdeLLu64JmYatq6pduQphuRyvS
1LQ626S0zOuqLjifQSDyxgo6jkVAaXTazU6P5Qir6vVDUa47qshzUxukIuWhXg5LewUyt5Mn
7BTtDeHZuMlwgF1tPPg4h1KuhiEWtxW6qevOl7YKqq4VUJy5GtLZ24mpgtTIqzVZS+t9ua6O
FZkeDYQs+9OTy65mKydUrhmfKdWBeNvuXW1bF66jV6hO1+v3rzTWWm0TKRJtUXlxlmmXG2ko
WUhfot5wpzjHlZiKlSLxsjWqW1qu966K5uDqFoz9Km7mefkJinrnZlhUqJMqKAUMobWnoOIX
n+Lx3To3QLatnR40u1L6qF2yPslOvmoz9YFTe7RyYWpxkvAnIbUS2Ek5SE4PWN7hCEIQhFCA
UxxFUtI6Tav+EzWrcNOuFqUp1yW1VbrVReacKqyGkSTzyUdCkuMrQsqGSpTLnqJHbqfexWEI
Rg7ssez76ojdNvS1aPXpRlztm5eqSDU20heCOQS4kgKwSM4zgn1wtWyLPsaiLplmWrRqDJuL
7VcvS5BqUaUrGORS2kAnGOsYd3RvS6Y1uGpMxYFvvXSAB7LuU9tU10GAeePfAdAr3wHTOIyz
VjWgxNF9m2KQ24qomrlaZBoKM6QUmZyE/DFJILnvsHvjVH9uGg81qw5fUzpBZ71wu1JusKqa
6OyZnzts8kvheMhzODyHUkAnJAxidJ9ruk+lNVcuKRtKhz12Pz8/Pv3GulNInnFTU04+QV9S
CkLS3yByUtjPqiSrftmg2rRFUy26NIUuTU+7NGXkpZDDXauuFxxfFIA5KWpSlHvJJMZWEIQh
CEWqOEGPz8qtPndRvK9I3L1OWm0UrTvU6n6XUUofwlbCpaZYm1lsnrmfnGPSH70Hp0Of0Db+
CHzRdCEIQhCEUUcIJ9Uc+07WTXq+tzOo1m6c6fWMKTYFYYoxqFcuCaYdnXXJVqYJS0zLOcQl
LqR1PXPTuMbD7JbtvuN0j/GapfsMPZLdt9xukf4zVL9hh7JbtvuN0j/GapfsMPZLdt9xukf4
zVL9hh7JbtvuN0j/ABmqX7DF7NT3Xh0mZs7SYI4KxwuWpZ5YPHvke7OM/JHyzVa3fsJb82sD
SKZK3AlebsqLQbT4qyZA5x06Dqcxgr21G3a2LorXr3qGmOlU3L0CTmKg9Ky93z4ddYZSpalJ
KpEJCilJIST8mY+m9NySR5L2k63WdTUGu3pSZEWpSHlc1TNVn0pTKy2OhXh1eVHA9BtSugjT
7vsR7Q7ybulVnTziqtP0C9bW9kXpUKUqenHKs0uZeSFdTzedcX18D4d0dVo+DA9XSLoQhCEI
Qi1fwKvmiAtuH7rvcV/ODL/oaQif4QhCKQxGgbgWnpjYtqLKy4y69aVVQ2D/AAjJugf945V2
P0FevelOl9/122Z2TsTSa2pOlWbLz6jyn6yGUonqiRxAWhop7Bk9wPbnBPEia9zNYZf1u0M0
6E+5LuXFqHLz60NKTzcZp0s9OEFJBJR2qJcKIxjI69Ynxv4EfNF8IQhCEIRav4FXzRAO3D91
3uK/nBl/0NIR0BCEIQihPSOQd3+pF76m6Zag6J6IT3mLVt0CbnL9ukt82aayJVTyabL9cOTb
6AAvwaaWSSFKSIlXZi1SmvJT6TposiqTlFWjIOJaUoKIUpoKWSQACSsqVnHj16xrSpSlal+W
0TUGUJeRozaCpd9wLOUVGsLCko49x4ykuST/ALcDw6dHJ97FYQhCEIQi1fwKvmjn3bc24N4+
4xwu5Qq/5UBHEeiRR5Ik58c5HTwx8sdB5HrhkQJjnm8Nzl+s7zrl0Y0m0ImL7n7RpclUKrM+
2aWpSGVzYWppsJfT6Q4pyVJJxnGI8fs3bvP9SX/7Lpv6uMvT9ZtxjoR7K7QqtLEoRyEvfFJe
wsqUFAZcRkABBB6ZKiMDAJjCkbitWt10pVdKNJLTn9NqpSKjNUi9rqmnmalL0MNniGae62Q3
MzbngoYSyAVHJKMyfcuj9i6H+SZvqwNPqSJOmydoVZxxxxXOYnH1SbpcmH3O9x1Z6qUfkAwA
AMXtkvKg6eeQy08vq6JrzakUDT6UqU86BkoZaluayB4nA6DxOIyu0K0piR24zOqVdp7kpcur
VRXfFYYW8p3zUzQSZeWSVAHi1LhlGD3K5Y6EATrCEIQhCEItX8CfmiANuX7rncV/ODLfoaQi
KbB1a3G1OaktVbh1HoczbMzq9MWGLXRR2GwqnqqC5Ft3zgDtUzCHPS454qQgZ6kk5qw9wOq9
e8pfMbYqtcNsqnbVqE5WatWmZUJVVKSG2FSsmy1khM2DMjtyMcEtApBK8jpWjUq9ZbWeu1Wq
3XKTltzkvKopNJRTA09IuoC+3Wt/kS6HCUEDiOPHHzwLo4yo+XX3BzCZNKEChWs2p5Th5OK8
3dPRJPvcdMgEZT35yIlvXvXnT7bht4mtTNSp2YZpMu+1KoblWw7MTLzhwltpBI5KwFKxkYSh
R8Ig+3L/AL73w2c3VdOapUrE0Tn23JacqiXPNborD7a8ONSxQpaJWXBT2a1qy4r0wkJGFRvm
06zLW09lNUbIsmiS1HoVFv5+VkJGWBDbDfsdTzgZ65JJJJOSSSepjetwv7grUj6I1X/8bscg
6as1XWzZzt52x0Z1o241ZlIurUgKC0qVTEcDJySVpIwqZfaXyT0PZtE5A6K79bAS2AP+0XQh
CEIQhCLV/An5o5623vPL3o7jpYyq0tIv2TWl8rSUrUaRJZSB3gpCUnJGDzGO44xuh2zS17Gr
r9z3tMTtVrSL5qt5Skq1W5pyktTL8w95tMeZqIa84RLuJTy49FDIJIBjf7f2uaN2vbttSFEt
2Yl3LTuF+6KdPGoPLnfP3yvzhx2YKi46HQ4UrSslKkhIIISMbhRtOLcoOuNwahyBqHsvcrEr
LT3a1B1yX4S6SloNslXBsgKVkpA5EknJMc40DVOz7N8ubrCnUW9KDbUui0balKYusTzNPEwg
edOr7NTqx2uFOqypPd70jpkyBqze+0PW3Qqo6b6jav6eVKg1Xs/OGE3dKNLyhaVpKVpdCkkK
SOoIPePGL9Lr62g6MaHyGnem2q+m9HoNLSoS8qi7ZVzBUoqWpS1vFSlKUSSSTkmL9sNxUC66
5q7cFr1uQq9Mm9RposTsjMofYd40+npVxWklKsKSR0PeDH37utRLU0x8nVf1x3bVpeRl3aBO
0+WDoSozE0+wttllCD0WpSlD0e7AUT0BiPvJzaQU3TPyY9pVt2VdVcV40yWrFXnJlS1PuAth
Ms1lYBS21LpaQlA9EYJGeWT1JCEIQhCEIRa58Cr5o5+23tFO8XcY9zcPO/5ZPEn0BijyJyB6
znr8wjoKKxQ90YyftqgVWbExVKLT5x0DiFzEqhxQHqyoE4jHOabWA7U/PXbJt9cx2SpftVUp
gr7NRBUjPHPEkAkd3QR8ErozpLJUx+SktMLRl5eacLswy1QpVCHlkYKlAIwSR0yfCM3IUm2r
KtNbFIplNo1NYCn1tyzDcsw2AMqWQkBI6DJPqEciX1Jze5bR+/td640hzTG2LUrB05psywtC
qhNiTeQ5XXEKA9EpK25dKwr0CXQElaTE17MX35ryUWkcxMvuPOKs6mhS3FFSjhhIHU/IB9UT
TCEIQhCEIRav4E/NHOu2tSjvm3Jo9jXkJF8yJE4SOzeJpErlsDOeSMAnIHR1PU9cdGQih7oi
DVHdnt+0X1OaszUzUeUo1cflEz6JHzSZmXSwpSkpWQ00vAJQrv8AVGnO+UU2bsFXnGtUozwG
VdpSJ9HEdBk5l+gyR3+seuLZfyjGy6an2pZrXmjIW8sISXpScaRknHVSmQkDPeSQBg57jGEr
d6UvfHUvaBpfXZ5zR+VIVdl1UyYUwKw8CQqiNpWlKy2ttSVvOpGOJSgHKjicNVKNS5TZdd1D
lnJWk09u15+VbIlebEmyJRaQQykdUITj0AO4YAjUdlPxS2kP0Op35kRNkIQhCEIQhFq/gT80
cybZWpxHlJt0D7gcEou7KShol4lJcFLb54R3JOFIyodT0B96Iy1sb1tP7s1zdtem2VezdEau
dyyTdT9MQmlezKVlCZUlLhdHIgBLhbCOS0pJBMZqQ3c6UVTb/b+olOTXX5O47sasiVkk04ie
aqi3lNFl1oq+18ShRUSfejIzkZkun3a5P6y1azza9dl26XJy02mrvSoTT5wvFYLTLucqcRwB
WMDHNPfEBaW0qalfLya4zk5KtNpnbSth+TdSvktbWJhCiep4+m0ocRgEJScdcnpOYp0pNS62
5qXaeQ4MLS42FhQ9RBzkdB9Uc2aw12s61ap1LbdoxKop7Uphi+70blEcbeacQViUlM45z7iF
d4yGEuc1ekQBndn9hWvpdbmpmnllU9UjQ6DfsxKybBeW6Up9j6epRKlkqJUtSlEk96j3d0SX
rW1OP7Qb5Yp02JSbctqpJYmO17LslmVcCVc/3uDg58MZjStlPxS2kP0Op35kRNkIQhCEIQhF
q/giPkjmjbbKSEr5Src4pUvONVR66KM68XE4ZXLGmN9gUHxVy7fPycIgHb5pNr9fkpdNlVCi
USi6a/ZzqN1TlUmZh5qsupk50PJZYYLfAoXMMNDtSvontBxPQxJNi6XT8/5cu7n6DN9tpzaC
jdM3IOM9mzL3bUpdLTqmiGwHSJZrtTlSuzVMkjCldOoqM/qGvXeuMVin0Buz25SVNHmJd91V
QcmDy84D6CAhKB6HDiST1z6hD2nymh5cfVzHngPtItnl5wVdnntZ74LPThjGePTnz8cx578d
EtWtwGyYWDo7d8vRao5VpeZm25idXKsz0sgL5NLcQlShhZbWB3Eo6+EbHs/0Vqe37YBbem1y
PUt+vyrb01WJqQRhExNPOqWpSlkBTqgClHaK6qCB3AACu3qmts66651ZLzhXPaiKSps+8R2d
Kp6QU/ODkxu+ttKma7s8vqhSfHt6jbVSlGuQJTyXKuJGcAnGSO4E/IY0nZT8UtpD9Dqd+ZET
ZCEIQhCEIR886qZTIL80DRdx6PaEhP8ATjr3ZjmjbHPTy/KX7oqW5OpVJMXXSJhmXBGW3HKY
gOLxjPpBtsd/7z6+nsf3zDA/uYY6RFt37drJvDXCa1FXW7yotdnpBimTUxQbnm6YH2GFOKaS
tLK0hXEuuEE/wjHw+5ot/wC+jq9/1DqX62HuaLf++jq9/wBQ6l+tjbtMNKLX0ltapUq2Hau+
KvUnKvPTNVqj1QmZiZcShC1rddUpR9FpAxnA49Izd2f6Nat/uL/5tURXsp+KW0h+h1O/MiJs
hCEIQhCEItX8EfmjlnbA4f8AGq7qW+xQONx0NXMI9I5p3cT6hjp859cdTch6j9UOQ9R+qHIe
o/VDkPUfqMOQ9SvqMOY9SvqMOY9SvqMYS9JliV0nrU1MupZYZp0y4664eKEJDSiSSegAHiYj
DZT8UvpD9Dqd+ZETZCEIQhCEIRQjKcRD93bRtvN9asVO+rl01k369WkoTUJ9mbmZZ2Z4ABBX
2TqQVDCcKxn0U9fRGPkmNm23WYrzVVRYC5SdZk0yAmJGtT8o6tkJCQlamn0lz0UpGVZJAHXp
H1SW0vQ+nybMtKUCtpYl0oSyyu7KstpsIIKOKFTRSOJSnGB0x0j1p21XRelBCZGi11CELS4l
Crsqq0ApVyHoqmiMZ7x3HuORHzzm0bQ2oKSZ2h3C8EOpfQld41gpQ4k8kqSPOsAg9QR3eEen
uT9Fv5Oun8d6z+1w9yfov/J10/jvWf2uHuT9F/5Oun8d6z+1x5Te0TQyfpb0jPUS4pqWmW1M
vMP3lWHG3UKGFJUkzZCkkEgg9CDEnWnadv2PpxTLRtWmM02j0aVbkpGTZB4MMoHFKBkk4AA7
zmMxCEIQhCEIQhCEIQhCEIQhH//Z</binary>
</FictionBook>